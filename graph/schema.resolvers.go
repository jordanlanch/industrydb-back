package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/jordanlanch/industrydb/ent"
	"github.com/jordanlanch/industrydb/ent/subscription"
	"github.com/jordanlanch/industrydb/ent/user"
	"github.com/jordanlanch/industrydb/graph/model"
	"github.com/jordanlanch/industrydb/pkg/auth"
	"github.com/jordanlanch/industrydb/pkg/models"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	// Hash password
	hashedPassword, err := auth.HashPassword(input.Password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password")
	}

	// Create user
	u, err := r.Resolver.DB.User.Create().
		SetEmail(input.Email).
		SetPasswordHash(hashedPassword).
		SetName(input.Name).
		SetAcceptedTermsAt(time.Now()).
		Save(ctx)
	if err != nil {
		return nil, err
	}

	// Generate JWT token
	token, err := auth.GenerateJWT(u.ID, u.Email, u.SubscriptionTier.String(), r.Resolver.JWTSecret, r.Resolver.JWTExpirationHours)
	if err != nil {
		return nil, err
	}

	// Map to GraphQL response
	return &model.AuthResponse{
		Token: token,
		User: &model.User{
			ID:               strconv.Itoa(u.ID),
			Email:            u.Email,
			Name:             u.Name,
			SubscriptionTier: u.SubscriptionTier.String(),
			UsageCount:       u.UsageCount,
			UsageLimit:       u.UsageLimit,
			EmailVerified:    u.EmailVerified,
			CreatedAt:        u.CreatedAt,
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthResponse, error) {
	// Find user by email
	u, err := r.Resolver.DB.User.Query().Where(user.EmailEQ(input.Email)).Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, fmt.Errorf("invalid credentials")
		}
		return nil, err
	}

	// Verify password
	if !auth.CheckPassword(u.PasswordHash, input.Password) {
		return nil, fmt.Errorf("invalid credentials")
	}

	// Generate JWT token
	token, err := auth.GenerateJWT(u.ID, u.Email, u.SubscriptionTier.String(), r.Resolver.JWTSecret, r.Resolver.JWTExpirationHours)
	if err != nil {
		return nil, err
	}

	// Map to GraphQL response
	return &model.AuthResponse{
		Token: token,
		User: &model.User{
			ID:               strconv.Itoa(u.ID),
			Email:            u.Email,
			Name:             u.Name,
			SubscriptionTier: u.SubscriptionTier.String(),
			UsageCount:       u.UsageCount,
			UsageLimit:       u.UsageLimit,
			EmailVerified:    u.EmailVerified,
			CreatedAt:        u.CreatedAt,
		},
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (*model.GenericResponse, error) {
	// Get token from context
	token, ok := ctx.Value("token").(string)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Add token to blacklist in Redis
	// Token will expire after JWT expiration time
	expiration := time.Duration(r.Resolver.JWTExpirationHours) * time.Hour
	if err := r.Resolver.TokenBlacklist.Add(ctx, token, expiration); err != nil {
		return nil, fmt.Errorf("failed to logout: %w", err)
	}

	return &model.GenericResponse{
		Success: true,
		Message: "Logged out successfully",
	}, nil
}

// ExportLeads is the resolver for the exportLeads field.
func (r *mutationResolver) ExportLeads(ctx context.Context, input model.LeadSearchInput) (*model.GenericResponse, error) {
	// Get user from context
	userID, ok := ctx.Value("user_id").(int)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Map GraphQL input to lead search filters
	filters := models.LeadSearchRequest{
		HasEmail: input.HasEmail,
		HasPhone: input.HasPhone,
	}
	if input.Industry != nil {
		filters.Industry = *input.Industry
	}
	if input.Country != nil {
		filters.Country = *input.Country
	}
	if input.City != nil {
		filters.City = *input.City
	}
	if input.Limit != nil {
		filters.Limit = *input.Limit
	}

	// Create export request
	exportReq := models.ExportRequest{
		Format:   "csv", // Default to CSV
		Filters:  filters,
		MaxLeads: 1000, // Default limit
	}

	// Create export via service (async processing)
	_, err := r.Resolver.ExportService.CreateExport(ctx, userID, nil, exportReq)
	if err != nil {
		return nil, fmt.Errorf("failed to create export: %w", err)
	}

	return &model.GenericResponse{
		Success: true,
		Message: "Export queued successfully. Check your exports page for download link.",
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Get user ID from context
	userID, ok := ctx.Value("user_id").(int)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Get user from database
	u, err := r.Resolver.DB.User.Query().Where(user.IDEQ(userID)).Only(ctx)
	if err != nil {
		return nil, err
	}

	// Map to GraphQL response
	return &model.User{
		ID:               strconv.Itoa(u.ID),
		Email:            u.Email,
		Name:             u.Name,
		SubscriptionTier: u.SubscriptionTier.String(),
		UsageCount:       u.UsageCount,
		UsageLimit:       u.UsageLimit,
		EmailVerified:    u.EmailVerified,
		CreatedAt:        u.CreatedAt,
	}, nil
}

// Lead is the resolver for the lead field.
func (r *queryResolver) Lead(ctx context.Context, id string) (*model.Lead, error) {
	// Parse ID
	leadID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid lead ID")
	}

	// Get lead from service
	lead, err := r.Resolver.LeadService.GetByID(ctx, leadID)
	if err != nil {
		return nil, err
	}

	// Map to GraphQL response
	return mapLeadResponseToGraphQL(lead), nil
}

// Leads is the resolver for the leads field.
func (r *queryResolver) Leads(ctx context.Context, input model.LeadSearchInput) (*model.LeadConnection, error) {
	// Map GraphQL input to lead search request
	req := models.LeadSearchRequest{
		HasEmail: input.HasEmail,
		HasPhone: input.HasPhone,
	}
	if input.Industry != nil {
		req.Industry = *input.Industry
	}
	if input.Country != nil {
		req.Country = *input.Country
	}
	if input.City != nil {
		req.City = *input.City
	}
	if input.MinQualityScore != nil {
		// Note: MinQualityScore not in LeadSearchRequest, would need to add
		_ = *input.MinQualityScore
	}
	if input.Limit != nil {
		req.Limit = *input.Limit
	} else {
		req.Limit = 50
	}
	req.Page = 1
	if input.Offset != nil {
		req.Page = (*input.Offset / req.Limit) + 1
	}

	// Search leads via service
	response, err := r.Resolver.LeadService.Search(ctx, req)
	if err != nil {
		return nil, err
	}

	// Map to GraphQL connection
	edges := make([]*model.LeadEdge, len(response.Data))
	for i, lead := range response.Data {
		edges[i] = &model.LeadEdge{
			Cursor: strconv.Itoa(lead.ID),
			Node:   mapLeadResponseToGraphQL(&lead),
		}
	}

	// Calculate pagination info
	hasNextPage := response.Pagination.HasNext
	hasPreviousPage := response.Pagination.HasPrev

	var startCursor, endCursor *string
	if len(edges) > 0 {
		start := edges[0].Cursor
		end := edges[len(edges)-1].Cursor
		startCursor = &start
		endCursor = &end
	}

	return &model.LeadConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: hasPreviousPage,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		TotalCount: response.Pagination.Total,
	}, nil
}

// UsageStats is the resolver for the usageStats field.
func (r *queryResolver) UsageStats(ctx context.Context) (*model.UsageStats, error) {
	// Get user ID from context
	userID, ok := ctx.Value("user_id").(int)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Get user from database
	u, err := r.Resolver.DB.User.Query().Where(user.IDEQ(userID)).Only(ctx)
	if err != nil {
		return nil, err
	}

	// Calculate usage stats
	leadsRemaining := u.UsageLimit - u.UsageCount
	usagePercentage := float64(u.UsageCount) / float64(u.UsageLimit) * 100.0

	// Get actual search and export counts from usage logs (last 30 days)
	summary, err := r.Resolver.AnalyticsService.GetUsageSummary(ctx, userID, 30)
	if err != nil {
		// If analytics fail, return zeros (non-critical)
		return &model.UsageStats{
			TotalSearches:   0,
			TotalExports:    0,
			LeadsRemaining:  leadsRemaining,
			UsagePercentage: usagePercentage,
		}, nil
	}

	return &model.UsageStats{
		TotalSearches:   summary.TotalSearches,
		TotalExports:    summary.TotalExports,
		LeadsRemaining:  leadsRemaining,
		UsagePercentage: usagePercentage,
	}, nil
}

// RevenueMetrics is the resolver for the revenueMetrics field.
func (r *queryResolver) RevenueMetrics(ctx context.Context, periodStart time.Time, periodEnd time.Time) (*model.RevenueMetrics, error) {
	// Pricing for each tier (in dollars)
	tierPricing := map[string]float64{
		"free":     0,
		"starter":  49,
		"pro":      149,
		"business": 349,
	}

	// Query all active subscriptions (simplified - actual period filtering can be added later)
	subscriptions, err := r.Resolver.DB.Subscription.Query().
		Where(subscription.StatusEQ(subscription.StatusActive)).
		All(ctx)

	if err != nil {
		return nil, fmt.Errorf("failed to query subscriptions: %w", err)
	}

	// Calculate metrics
	paidUsers := 0
	mrr := 0.0

	for _, sub := range subscriptions {
		tierStr := string(sub.Tier)
		if price, exists := tierPricing[tierStr]; exists && price > 0 {
			mrr += price
			paidUsers++
		}
	}

	// Calculate ARR (Annual Recurring Revenue)
	arr := mrr * 12

	// Calculate ARPU (Average Revenue Per User)
	arpu := 0.0
	if paidUsers > 0 {
		arpu = mrr / float64(paidUsers)
	}

	// Calculate revenue growth (compare to previous period)
	// For simplicity, return 0 for now (requires historical comparison)
	revenueGrowth := 0.0

	return &model.RevenueMetrics{
		Mrr:           mrr,
		Arr:           arr,
		RevenueGrowth: revenueGrowth,
		Arpu:          arpu,
		PaidUsers:     paidUsers,
	}, nil
}

// Helper function to map models.LeadResponse to GraphQL Lead
func mapLeadResponseToGraphQL(lead *models.LeadResponse) *model.Lead {
	// Parse CreatedAt timestamp
	createdAt, _ := time.Parse(time.RFC3339, lead.CreatedAt)
	if createdAt.IsZero() {
		createdAt = time.Now() // Fallback to current time if parsing fails
	}

	return &model.Lead{
		ID:           strconv.Itoa(lead.ID),
		Name:         lead.Name,
		Industry:     lead.Industry,
		Country:      lead.Country,
		City:         &lead.City,
		Email:        &lead.Email,
		Phone:        &lead.Phone,
		Website:      &lead.Website,
		Address:      &lead.Address,
		Latitude:     &lead.Latitude,
		Longitude:    &lead.Longitude,
		Verified:     lead.Verified,
		QualityScore: lead.QualityScore,
		CreatedAt:    createdAt,
	}
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
