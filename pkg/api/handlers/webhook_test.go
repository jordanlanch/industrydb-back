package handlers

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/jordanlanch/industrydb/ent"
	"github.com/jordanlanch/industrydb/ent/enttest"
	"github.com/jordanlanch/industrydb/ent/user"
	"github.com/jordanlanch/industrydb/pkg/webhook"
	"github.com/labstack/echo/v4"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	_ "github.com/mattn/go-sqlite3"
)

// setupWebhookTest creates test database and webhook handler
func setupWebhookTest(t *testing.T) (*ent.Client, *WebhookHandler, func()) {
	client := enttest.Open(t, "sqlite3", "file:ent?mode=memory&cache=shared&_fk=1")
	service := webhook.NewService(client)
	handler := NewWebhookHandler(service)
	cleanup := func() {
		client.Close()
	}
	return client, handler, cleanup
}

// createWebhookTestUser creates a test user for webhook tests
func createWebhookTestUser(t *testing.T, client *ent.Client, email string) *ent.User {
	ctx := context.Background()
	user, err := client.User.Create().
		SetEmail(email).
		SetPasswordHash("$2a$10$dummyhash").
		SetName("Test User").
		SetSubscriptionTier(user.SubscriptionTierBusiness).
		SetUsageLimit(10000).
		SetUsageCount(0).
		SetLastResetAt(time.Now()).
		SetEmailVerified(true).
		Save(ctx)
	require.NoError(t, err)
	return user
}

// --- CreateWebhook Tests ---

func TestWebhookHandler_Create_Success(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	e := echo.New()
	body := `{"url":"https://example.com/webhook","events":["lead.created","export.completed"],"description":"Test webhook"}`
	req := httptest.NewRequest(http.MethodPost, "/api/v1/webhooks", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)

	err := handler.CreateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusCreated, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, "https://example.com/webhook", response["url"])
	assert.True(t, response["active"].(bool))
	assert.Equal(t, "Test webhook", response["description"])
	assert.NotEmpty(t, response["secret"], "Secret should be auto-generated on create")
	assert.NotNil(t, response["created_at"])

	// Verify events
	events := response["events"].([]interface{})
	assert.Len(t, events, 2)
	assert.Equal(t, "lead.created", events[0])
	assert.Equal(t, "export.completed", events[1])
}

func TestWebhookHandler_Create_SecretAutoGenerated(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	e := echo.New()
	body := `{"url":"https://example.com/hook","events":["lead.created"]}`
	req := httptest.NewRequest(http.MethodPost, "/api/v1/webhooks", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)

	err := handler.CreateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusCreated, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)

	secret := response["secret"].(string)
	assert.NotEmpty(t, secret)
	assert.Len(t, secret, 64, "Secret should be 32 bytes hex-encoded (64 chars)")
}

func TestWebhookHandler_Create_MissingURL(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	e := echo.New()
	body := `{"url":"","events":["lead.created"]}`
	req := httptest.NewRequest(http.MethodPost, "/api/v1/webhooks", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)

	err := handler.CreateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusBadRequest, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "URL is required", response["error"])
}

func TestWebhookHandler_Create_MissingEvents(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	e := echo.New()
	body := `{"url":"https://example.com/hook","events":[]}`
	req := httptest.NewRequest(http.MethodPost, "/api/v1/webhooks", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)

	err := handler.CreateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusBadRequest, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "At least one event is required", response["error"])
}

func TestWebhookHandler_Create_InvalidJSON(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	e := echo.New()
	body := `{invalid json}`
	req := httptest.NewRequest(http.MethodPost, "/api/v1/webhooks", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)

	err := handler.CreateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusBadRequest, rec.Code)
}

// --- ListWebhooks Tests ---

func TestWebhookHandler_List_Success(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	ctx := context.Background()
	service := webhook.NewService(client)
	_, err := service.CreateWebhook(ctx, user.ID, "https://example.com/hook1", []string{"lead.created"}, "Hook 1")
	require.NoError(t, err)
	_, err = service.CreateWebhook(ctx, user.ID, "https://example.com/hook2", []string{"export.completed"}, "Hook 2")
	require.NoError(t, err)

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/api/v1/webhooks", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)

	err = handler.ListWebhooks(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, float64(2), response["count"])
	webhooks := response["webhooks"].([]interface{})
	assert.Len(t, webhooks, 2)

	// Verify secret is NOT included in list response
	wh := webhooks[0].(map[string]interface{})
	_, hasSecret := wh["secret"]
	assert.False(t, hasSecret, "Secret should not be included in list response")
}

func TestWebhookHandler_List_ReturnsOnlyUsersWebhooks(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user1 := createWebhookTestUser(t, client, "user1@example.com")
	user2 := createWebhookTestUser(t, client, "user2@example.com")

	ctx := context.Background()
	service := webhook.NewService(client)
	_, err := service.CreateWebhook(ctx, user1.ID, "https://example.com/u1", []string{"lead.created"}, "User1")
	require.NoError(t, err)
	_, err = service.CreateWebhook(ctx, user2.ID, "https://example.com/u2", []string{"lead.created"}, "User2")
	require.NoError(t, err)

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/api/v1/webhooks", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user1.ID)

	err = handler.ListWebhooks(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, float64(1), response["count"])
}

func TestWebhookHandler_List_Empty(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/api/v1/webhooks", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)

	err := handler.ListWebhooks(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, float64(0), response["count"])
}

// --- GetWebhook Tests ---

func TestWebhookHandler_Get_Success(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	ctx := context.Background()
	service := webhook.NewService(client)
	created, err := service.CreateWebhook(ctx, user.ID, "https://example.com/hook", []string{"lead.created"}, "Test")
	require.NoError(t, err)

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/api/v1/webhooks/"+itoa(created.ID), nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)
	c.SetParamNames("id")
	c.SetParamValues(itoa(created.ID))

	err = handler.GetWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "https://example.com/hook", response["url"])
	assert.True(t, response["active"].(bool))
}

func TestWebhookHandler_Get_NotFound(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/api/v1/webhooks/99999", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)
	c.SetParamNames("id")
	c.SetParamValues("99999")

	err := handler.GetWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusNotFound, rec.Code)
}

func TestWebhookHandler_Get_InvalidID(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/api/v1/webhooks/abc", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)
	c.SetParamNames("id")
	c.SetParamValues("abc")

	err := handler.GetWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusBadRequest, rec.Code)
}

// --- UpdateWebhook Tests ---

func TestWebhookHandler_Update_URL(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	ctx := context.Background()
	service := webhook.NewService(client)
	created, err := service.CreateWebhook(ctx, user.ID, "https://old.com/hook", []string{"lead.created"}, "Test")
	require.NoError(t, err)

	e := echo.New()
	body := `{"url":"https://new.com/hook"}`
	req := httptest.NewRequest(http.MethodPatch, "/api/v1/webhooks/"+itoa(created.ID), strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)
	c.SetParamNames("id")
	c.SetParamValues(itoa(created.ID))

	err = handler.UpdateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "https://new.com/hook", response["url"])
}

func TestWebhookHandler_Update_Events(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	ctx := context.Background()
	service := webhook.NewService(client)
	created, err := service.CreateWebhook(ctx, user.ID, "https://example.com/hook", []string{"lead.created"}, "Test")
	require.NoError(t, err)

	e := echo.New()
	body := `{"events":["export.completed","export.failed"]}`
	req := httptest.NewRequest(http.MethodPatch, "/api/v1/webhooks/"+itoa(created.ID), strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)
	c.SetParamNames("id")
	c.SetParamValues(itoa(created.ID))

	err = handler.UpdateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	events := response["events"].([]interface{})
	assert.Len(t, events, 2)
	assert.Equal(t, "export.completed", events[0])
	assert.Equal(t, "export.failed", events[1])
}

func TestWebhookHandler_Update_Active(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	ctx := context.Background()
	service := webhook.NewService(client)
	created, err := service.CreateWebhook(ctx, user.ID, "https://example.com/hook", []string{"lead.created"}, "Test")
	require.NoError(t, err)

	e := echo.New()
	body := `{"active":false}`
	req := httptest.NewRequest(http.MethodPatch, "/api/v1/webhooks/"+itoa(created.ID), strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)
	c.SetParamNames("id")
	c.SetParamValues(itoa(created.ID))

	err = handler.UpdateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.False(t, response["active"].(bool))
}

func TestWebhookHandler_Update_NotFound(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	e := echo.New()
	body := `{"url":"https://new.com/hook"}`
	req := httptest.NewRequest(http.MethodPatch, "/api/v1/webhooks/99999", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)
	c.SetParamNames("id")
	c.SetParamValues("99999")

	err := handler.UpdateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusNotFound, rec.Code)
}

// --- DeleteWebhook Tests ---

func TestWebhookHandler_Delete_Success(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	ctx := context.Background()
	service := webhook.NewService(client)
	created, err := service.CreateWebhook(ctx, user.ID, "https://example.com/hook", []string{"lead.created"}, "Test")
	require.NoError(t, err)

	e := echo.New()
	req := httptest.NewRequest(http.MethodDelete, "/api/v1/webhooks/"+itoa(created.ID), nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)
	c.SetParamNames("id")
	c.SetParamValues(itoa(created.ID))

	err = handler.DeleteWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "Webhook deleted successfully", response["message"])

	// Verify webhook is gone
	_, err = service.GetWebhook(ctx, created.ID, user.ID)
	assert.Error(t, err)
}

func TestWebhookHandler_Delete_OwnershipCheck(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user1 := createWebhookTestUser(t, client, "user1@example.com")
	user2 := createWebhookTestUser(t, client, "user2@example.com")

	ctx := context.Background()
	service := webhook.NewService(client)
	created, err := service.CreateWebhook(ctx, user1.ID, "https://example.com/hook", []string{"lead.created"}, "User1 Hook")
	require.NoError(t, err)

	// User2 tries to delete User1's webhook
	e := echo.New()
	req := httptest.NewRequest(http.MethodDelete, "/api/v1/webhooks/"+itoa(created.ID), nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user2.ID)
	c.SetParamNames("id")
	c.SetParamValues(itoa(created.ID))

	err = handler.DeleteWebhook(c)
	require.NoError(t, err)
	// Should fail - webhook belongs to user1
	assert.Equal(t, http.StatusNotFound, rec.Code)
}

func TestWebhookHandler_Delete_NotFound(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	e := echo.New()
	req := httptest.NewRequest(http.MethodDelete, "/api/v1/webhooks/99999", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)
	c.SetParamNames("id")
	c.SetParamValues("99999")

	err := handler.DeleteWebhook(c)
	require.NoError(t, err)
	// DeleteWebhook returns not found status for non-existent webhooks
	assert.NotEqual(t, http.StatusOK, rec.Code)
}

func TestWebhookHandler_Delete_InvalidID(t *testing.T) {
	client, handler, cleanup := setupWebhookTest(t)
	defer cleanup()

	user := createWebhookTestUser(t, client, "webhook@example.com")

	e := echo.New()
	req := httptest.NewRequest(http.MethodDelete, "/api/v1/webhooks/abc", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user.ID)
	c.SetParamNames("id")
	c.SetParamValues("abc")

	err := handler.DeleteWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusBadRequest, rec.Code)
}
