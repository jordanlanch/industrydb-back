package handlers

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strconv"
	"strings"
	"testing"
	"time"

	"github.com/jordanlanch/industrydb/ent"
	"github.com/jordanlanch/industrydb/ent/enttest"
	"github.com/jordanlanch/industrydb/pkg/webhook"
	"github.com/labstack/echo/v4"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	_ "github.com/mattn/go-sqlite3"
)

// setupWebhookHandler creates a WebhookHandler with in-memory database
func setupWebhookHandler(t *testing.T) (*WebhookHandler, *webhook.Service, *ent.Client, func()) {
	client := enttest.Open(t, "sqlite3", "file:webhook_test?mode=memory&cache=shared&_fk=1")
	svc := webhook.NewService(client)
	handler := NewWebhookHandler(svc)
	cleanup := func() { client.Close() }
	return handler, svc, client, cleanup
}

// createWebhookTestUser creates a user for webhook tests
func createWebhookTestUser(t *testing.T, client *ent.Client, email string) int {
	u, err := client.User.Create().
		SetEmail(email).
		SetPasswordHash("$2a$10$hash").
		SetName("Webhook User").
		SetSubscriptionTier("business").
		SetUsageCount(0).
		SetUsageLimit(10000).
		SetEmailVerified(true).
		SetAcceptedTermsAt(time.Now()).
		Save(context.Background())
	require.NoError(t, err)
	return u.ID
}

// --- CreateWebhook Tests ---

func TestWebhookHandler_Create_Success(t *testing.T) {
	handler, _, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-create@example.com")

	e := echo.New()
	body := `{"url":"https://example.com/webhook","events":["lead.created","export.completed"],"description":"Test webhook"}`
	req := httptest.NewRequest(http.MethodPost, "/api/v1/webhooks", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)

	err := handler.CreateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusCreated, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)

	assert.Equal(t, "https://example.com/webhook", response["url"])
	assert.True(t, response["active"].(bool))
	assert.Equal(t, "Test webhook", response["description"])
	assert.NotEmpty(t, response["secret"], "Secret should be auto-generated on create")
	assert.NotEmpty(t, response["id"])

	// Verify events
	events, ok := response["events"].([]interface{})
	require.True(t, ok)
	assert.Len(t, events, 2)
}

func TestWebhookHandler_Create_SecretAutoGenerated(t *testing.T) {
	handler, _, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-secret@example.com")

	e := echo.New()
	body := `{"url":"https://example.com/hook","events":["lead.created"]}`
	req := httptest.NewRequest(http.MethodPost, "/api/v1/webhooks", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)

	err := handler.CreateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusCreated, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)

	secret := response["secret"].(string)
	assert.Len(t, secret, 64, "Secret should be 32 bytes hex-encoded (64 chars)")
}

func TestWebhookHandler_Create_EmptyURL(t *testing.T) {
	handler, _, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-nourl@example.com")

	e := echo.New()
	body := `{"url":"","events":["lead.created"]}`
	req := httptest.NewRequest(http.MethodPost, "/api/v1/webhooks", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)

	err := handler.CreateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusBadRequest, rec.Code)

	var response map[string]string
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "URL is required", response["error"])
}

func TestWebhookHandler_Create_NoEvents(t *testing.T) {
	handler, _, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-noevt@example.com")

	e := echo.New()
	body := `{"url":"https://example.com/webhook","events":[]}`
	req := httptest.NewRequest(http.MethodPost, "/api/v1/webhooks", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)

	err := handler.CreateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusBadRequest, rec.Code)

	var response map[string]string
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "At least one event is required", response["error"])
}

func TestWebhookHandler_Create_InvalidJSON(t *testing.T) {
	handler, _, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-badjson@example.com")

	e := echo.New()
	body := `{invalid}`
	req := httptest.NewRequest(http.MethodPost, "/api/v1/webhooks", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)

	err := handler.CreateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusBadRequest, rec.Code)
}

// --- ListWebhooks Tests ---

func TestWebhookHandler_List_ReturnsUserWebhooksOnly(t *testing.T) {
	handler, svc, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	user1ID := createWebhookTestUser(t, client, "wh-list1@example.com")
	user2ID := createWebhookTestUser(t, client, "wh-list2@example.com")

	ctx := context.Background()
	_, err := svc.CreateWebhook(ctx, user1ID, "https://example.com/hook1", []string{"lead.created"}, "Hook 1")
	require.NoError(t, err)
	_, err = svc.CreateWebhook(ctx, user1ID, "https://example.com/hook2", []string{"export.completed"}, "Hook 2")
	require.NoError(t, err)
	_, err = svc.CreateWebhook(ctx, user2ID, "https://other.com/hook", []string{"lead.created"}, "Other Hook")
	require.NoError(t, err)

	// List for user1 — should see 2
	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/api/v1/webhooks", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", user1ID)

	err = handler.ListWebhooks(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, float64(2), response["count"])

	// Verify secrets are NOT included in list response
	webhooks := response["webhooks"].([]interface{})
	for _, wh := range webhooks {
		whMap := wh.(map[string]interface{})
		_, hasSecret := whMap["secret"]
		assert.False(t, hasSecret, "Secret should not be included in list response")
	}
}

func TestWebhookHandler_List_EmptyResults(t *testing.T) {
	handler, _, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-empty@example.com")

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/api/v1/webhooks", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)

	err := handler.ListWebhooks(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, float64(0), response["count"])
}

// --- GetWebhook Tests ---

func TestWebhookHandler_Get_Success(t *testing.T) {
	handler, svc, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-get@example.com")
	ctx := context.Background()
	wh, err := svc.CreateWebhook(ctx, userID, "https://example.com/hook", []string{"lead.created"}, "Test")
	require.NoError(t, err)

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)
	c.SetParamNames("id")
	c.SetParamValues(intToStr(wh.ID))

	err = handler.GetWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "https://example.com/hook", response["url"])
}

func TestWebhookHandler_Get_NotFound(t *testing.T) {
	handler, _, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-getnf@example.com")

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)
	c.SetParamNames("id")
	c.SetParamValues("99999")

	err := handler.GetWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusNotFound, rec.Code)
}

func TestWebhookHandler_Get_InvalidID(t *testing.T) {
	handler, _, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-getbad@example.com")

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)
	c.SetParamNames("id")
	c.SetParamValues("abc")

	err := handler.GetWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusBadRequest, rec.Code)
}

// --- UpdateWebhook Tests ---

func TestWebhookHandler_Update_URL(t *testing.T) {
	handler, svc, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-upd@example.com")
	ctx := context.Background()
	wh, err := svc.CreateWebhook(ctx, userID, "https://old.com/hook", []string{"lead.created"}, "Test")
	require.NoError(t, err)

	e := echo.New()
	body := `{"url":"https://new.com/hook"}`
	req := httptest.NewRequest(http.MethodPatch, "/", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)
	c.SetParamNames("id")
	c.SetParamValues(intToStr(wh.ID))

	err = handler.UpdateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "https://new.com/hook", response["url"])
}

func TestWebhookHandler_Update_Events(t *testing.T) {
	handler, svc, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-updevt@example.com")
	ctx := context.Background()
	wh, err := svc.CreateWebhook(ctx, userID, "https://example.com/hook", []string{"lead.created"}, "Test")
	require.NoError(t, err)

	e := echo.New()
	body := `{"events":["lead.created","export.completed","export.failed"]}`
	req := httptest.NewRequest(http.MethodPatch, "/", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)
	c.SetParamNames("id")
	c.SetParamValues(intToStr(wh.ID))

	err = handler.UpdateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	events := response["events"].([]interface{})
	assert.Len(t, events, 3)
}

func TestWebhookHandler_Update_Active(t *testing.T) {
	handler, svc, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-updact@example.com")
	ctx := context.Background()
	wh, err := svc.CreateWebhook(ctx, userID, "https://example.com/hook", []string{"lead.created"}, "Test")
	require.NoError(t, err)

	e := echo.New()
	body := `{"active":false}`
	req := httptest.NewRequest(http.MethodPatch, "/", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)
	c.SetParamNames("id")
	c.SetParamValues(intToStr(wh.ID))

	err = handler.UpdateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.False(t, response["active"].(bool))
}

func TestWebhookHandler_Update_NotFound(t *testing.T) {
	handler, _, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-updnf@example.com")

	e := echo.New()
	body := `{"url":"https://new.com/hook"}`
	req := httptest.NewRequest(http.MethodPatch, "/", strings.NewReader(body))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)
	c.SetParamNames("id")
	c.SetParamValues("99999")

	err := handler.UpdateWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusNotFound, rec.Code)
}

// --- DeleteWebhook Tests ---

func TestWebhookHandler_Delete_Success(t *testing.T) {
	handler, svc, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-del@example.com")
	ctx := context.Background()
	wh, err := svc.CreateWebhook(ctx, userID, "https://example.com/hook", []string{"lead.created"}, "Test")
	require.NoError(t, err)

	e := echo.New()
	req := httptest.NewRequest(http.MethodDelete, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)
	c.SetParamNames("id")
	c.SetParamValues(intToStr(wh.ID))

	err = handler.DeleteWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]string
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	require.NoError(t, err)
	assert.Equal(t, "Webhook deleted successfully", response["message"])
}

func TestWebhookHandler_Delete_Ownership(t *testing.T) {
	handler, svc, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	ownerID := createWebhookTestUser(t, client, "wh-own@example.com")
	otherID := createWebhookTestUser(t, client, "wh-other@example.com")

	ctx := context.Background()
	wh, err := svc.CreateWebhook(ctx, ownerID, "https://example.com/hook", []string{"lead.created"}, "Owner Hook")
	require.NoError(t, err)

	// Other user tries to delete — service deletes 0 rows but doesn't error
	e := echo.New()
	req := httptest.NewRequest(http.MethodDelete, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", otherID)
	c.SetParamNames("id")
	c.SetParamValues(intToStr(wh.ID))

	err = handler.DeleteWebhook(c)
	require.NoError(t, err)
	// Current implementation returns 200 even with 0 rows deleted
	assert.Equal(t, http.StatusOK, rec.Code)

	// Verify the webhook still exists (was not actually deleted)
	_, err = svc.GetWebhook(ctx, wh.ID, ownerID)
	assert.NoError(t, err, "Webhook should still exist since another user tried to delete it")
}

func TestWebhookHandler_Delete_NonExistentID(t *testing.T) {
	handler, _, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-delnf@example.com")

	e := echo.New()
	req := httptest.NewRequest(http.MethodDelete, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)
	c.SetParamNames("id")
	c.SetParamValues("99999")

	err := handler.DeleteWebhook(c)
	require.NoError(t, err)
	// Current implementation: delete with Where returns 0 rows, no error
	assert.Equal(t, http.StatusOK, rec.Code)
}

func TestWebhookHandler_Delete_InvalidID(t *testing.T) {
	handler, _, client, cleanup := setupWebhookHandler(t)
	defer cleanup()

	userID := createWebhookTestUser(t, client, "wh-delbad@example.com")

	e := echo.New()
	req := httptest.NewRequest(http.MethodDelete, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user_id", userID)
	c.SetParamNames("id")
	c.SetParamValues("xyz")

	err := handler.DeleteWebhook(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusBadRequest, rec.Code)
}

// --- Helper ---

func intToStr(i int) string {
	return strconv.Itoa(i)
}
