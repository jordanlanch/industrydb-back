// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/jordanlanch/industrydb/ent/apikey"
	"github.com/jordanlanch/industrydb/ent/auditlog"
	"github.com/jordanlanch/industrydb/ent/emailsequence"
	"github.com/jordanlanch/industrydb/ent/emailsequenceenrollment"
	"github.com/jordanlanch/industrydb/ent/emailsequencesend"
	"github.com/jordanlanch/industrydb/ent/emailsequencestep"
	"github.com/jordanlanch/industrydb/ent/export"
	"github.com/jordanlanch/industrydb/ent/industry"
	"github.com/jordanlanch/industrydb/ent/lead"
	"github.com/jordanlanch/industrydb/ent/leadassignment"
	"github.com/jordanlanch/industrydb/ent/leadnote"
	"github.com/jordanlanch/industrydb/ent/leadstatushistory"
	"github.com/jordanlanch/industrydb/ent/organization"
	"github.com/jordanlanch/industrydb/ent/organizationmember"
	"github.com/jordanlanch/industrydb/ent/predicate"
	"github.com/jordanlanch/industrydb/ent/savedsearch"
	"github.com/jordanlanch/industrydb/ent/subscription"
	"github.com/jordanlanch/industrydb/ent/usagelog"
	"github.com/jordanlanch/industrydb/ent/user"
	"github.com/jordanlanch/industrydb/ent/webhook"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey                  = "APIKey"
	TypeAuditLog                = "AuditLog"
	TypeEmailSequence           = "EmailSequence"
	TypeEmailSequenceEnrollment = "EmailSequenceEnrollment"
	TypeEmailSequenceSend       = "EmailSequenceSend"
	TypeEmailSequenceStep       = "EmailSequenceStep"
	TypeExport                  = "Export"
	TypeIndustry                = "Industry"
	TypeLead                    = "Lead"
	TypeLeadAssignment          = "LeadAssignment"
	TypeLeadNote                = "LeadNote"
	TypeLeadStatusHistory       = "LeadStatusHistory"
	TypeOrganization            = "Organization"
	TypeOrganizationMember      = "OrganizationMember"
	TypeSavedSearch             = "SavedSearch"
	TypeSubscription            = "Subscription"
	TypeUsageLog                = "UsageLog"
	TypeUser                    = "User"
	TypeWebhook                 = "Webhook"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op             Op
	typ            string
	id             *int
	key_hash       *string
	name           *string
	prefix         *string
	last_used_at   *time.Time
	usage_count    *int
	addusage_count *int
	revoked        *bool
	revoked_at     *time.Time
	expires_at     *time.Time
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*APIKey, error)
	predicates     []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id int) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *APIKeyMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *APIKeyMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *APIKeyMutation) ResetUserID() {
	m.user = nil
}

// SetKeyHash sets the "key_hash" field.
func (m *APIKeyMutation) SetKeyHash(s string) {
	m.key_hash = &s
}

// KeyHash returns the value of the "key_hash" field in the mutation.
func (m *APIKeyMutation) KeyHash() (r string, exists bool) {
	v := m.key_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyHash returns the old "key_hash" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKeyHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyHash: %w", err)
	}
	return oldValue.KeyHash, nil
}

// ResetKeyHash resets all changes to the "key_hash" field.
func (m *APIKeyMutation) ResetKeyHash() {
	m.key_hash = nil
}

// SetName sets the "name" field.
func (m *APIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIKeyMutation) ResetName() {
	m.name = nil
}

// SetPrefix sets the "prefix" field.
func (m *APIKeyMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the value of the "prefix" field in the mutation.
func (m *APIKeyMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old "prefix" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix resets all changes to the "prefix" field.
func (m *APIKeyMutation) ResetPrefix() {
	m.prefix = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *APIKeyMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *APIKeyMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *APIKeyMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[apikey.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *APIKeyMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *APIKeyMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, apikey.FieldLastUsedAt)
}

// SetUsageCount sets the "usage_count" field.
func (m *APIKeyMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *APIKeyMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *APIKeyMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *APIKeyMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *APIKeyMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetRevoked sets the "revoked" field.
func (m *APIKeyMutation) SetRevoked(b bool) {
	m.revoked = &b
}

// Revoked returns the value of the "revoked" field in the mutation.
func (m *APIKeyMutation) Revoked() (r bool, exists bool) {
	v := m.revoked
	if v == nil {
		return
	}
	return *v, true
}

// OldRevoked returns the old "revoked" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldRevoked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevoked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevoked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevoked: %w", err)
	}
	return oldValue.Revoked, nil
}

// ResetRevoked resets all changes to the "revoked" field.
func (m *APIKeyMutation) ResetRevoked() {
	m.revoked = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *APIKeyMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *APIKeyMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *APIKeyMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[apikey.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *APIKeyMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *APIKeyMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, apikey.FieldRevokedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *APIKeyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *APIKeyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *APIKeyMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apikey.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *APIKeyMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *APIKeyMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apikey.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *APIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *APIKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APIKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APIKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.key_hash != nil {
		fields = append(fields, apikey.FieldKeyHash)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.prefix != nil {
		fields = append(fields, apikey.FieldPrefix)
	}
	if m.last_used_at != nil {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.usage_count != nil {
		fields = append(fields, apikey.FieldUsageCount)
	}
	if m.revoked != nil {
		fields = append(fields, apikey.FieldRevoked)
	}
	if m.revoked_at != nil {
		fields = append(fields, apikey.FieldRevokedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldKeyHash:
		return m.KeyHash()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldPrefix:
		return m.Prefix()
	case apikey.FieldLastUsedAt:
		return m.LastUsedAt()
	case apikey.FieldUsageCount:
		return m.UsageCount()
	case apikey.FieldRevoked:
		return m.Revoked()
	case apikey.FieldRevokedAt:
		return m.RevokedAt()
	case apikey.FieldExpiresAt:
		return m.ExpiresAt()
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldKeyHash:
		return m.OldKeyHash(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldPrefix:
		return m.OldPrefix(ctx)
	case apikey.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case apikey.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case apikey.FieldRevoked:
		return m.OldRevoked(ctx)
	case apikey.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case apikey.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldKeyHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyHash(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	case apikey.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case apikey.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case apikey.FieldRevoked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevoked(v)
		return nil
	case apikey.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case apikey.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, apikey.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldLastUsedAt) {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.FieldCleared(apikey.FieldRevokedAt) {
		fields = append(fields, apikey.FieldRevokedAt)
	}
	if m.FieldCleared(apikey.FieldExpiresAt) {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case apikey.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case apikey.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldKeyHash:
		m.ResetKeyHash()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldPrefix:
		m.ResetPrefix()
		return nil
	case apikey.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case apikey.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case apikey.FieldRevoked:
		m.ResetRevoked()
		return nil
	case apikey.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case apikey.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	action        *auditlog.Action
	resource_type *string
	resource_id   *string
	ip_address    *string
	user_agent    *string
	metadata      *map[string]interface{}
	severity      *auditlog.Severity
	description   *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*AuditLog, error)
	predicates    []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id int) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AuditLogMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuditLogMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AuditLogMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[auditlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AuditLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuditLogMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, auditlog.FieldUserID)
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(a auditlog.Action) {
	m.action = &a
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r auditlog.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v auditlog.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetResourceType sets the "resource_type" field.
func (m *AuditLogMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *AuditLogMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ClearResourceType clears the value of the "resource_type" field.
func (m *AuditLogMutation) ClearResourceType() {
	m.resource_type = nil
	m.clearedFields[auditlog.FieldResourceType] = struct{}{}
}

// ResourceTypeCleared returns if the "resource_type" field was cleared in this mutation.
func (m *AuditLogMutation) ResourceTypeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResourceType]
	return ok
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *AuditLogMutation) ResetResourceType() {
	m.resource_type = nil
	delete(m.clearedFields, auditlog.FieldResourceType)
}

// SetResourceID sets the "resource_id" field.
func (m *AuditLogMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *AuditLogMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *AuditLogMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[auditlog.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *AuditLogMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *AuditLogMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, auditlog.FieldResourceID)
}

// SetIPAddress sets the "ip_address" field.
func (m *AuditLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *AuditLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *AuditLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[auditlog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *AuditLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *AuditLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, auditlog.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *AuditLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *AuditLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *AuditLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[auditlog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *AuditLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *AuditLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, auditlog.FieldUserAgent)
}

// SetMetadata sets the "metadata" field.
func (m *AuditLogMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuditLogMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuditLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[auditlog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuditLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuditLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, auditlog.FieldMetadata)
}

// SetSeverity sets the "severity" field.
func (m *AuditLogMutation) SetSeverity(a auditlog.Severity) {
	m.severity = &a
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AuditLogMutation) Severity() (r auditlog.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSeverity(ctx context.Context) (v auditlog.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AuditLogMutation) ResetSeverity() {
	m.severity = nil
}

// SetDescription sets the "description" field.
func (m *AuditLogMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AuditLogMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AuditLogMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[auditlog.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AuditLogMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AuditLogMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, auditlog.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *AuditLogMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[auditlog.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AuditLogMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuditLogMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AuditLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.user != nil {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m.resource_type != nil {
		fields = append(fields, auditlog.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.ip_address != nil {
		fields = append(fields, auditlog.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, auditlog.FieldUserAgent)
	}
	if m.metadata != nil {
		fields = append(fields, auditlog.FieldMetadata)
	}
	if m.severity != nil {
		fields = append(fields, auditlog.FieldSeverity)
	}
	if m.description != nil {
		fields = append(fields, auditlog.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldUserID:
		return m.UserID()
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldResourceType:
		return m.ResourceType()
	case auditlog.FieldResourceID:
		return m.ResourceID()
	case auditlog.FieldIPAddress:
		return m.IPAddress()
	case auditlog.FieldUserAgent:
		return m.UserAgent()
	case auditlog.FieldMetadata:
		return m.Metadata()
	case auditlog.FieldSeverity:
		return m.Severity()
	case auditlog.FieldDescription:
		return m.Description()
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldUserID:
		return m.OldUserID(ctx)
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldResourceType:
		return m.OldResourceType(ctx)
	case auditlog.FieldResourceID:
		return m.OldResourceID(ctx)
	case auditlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case auditlog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case auditlog.FieldMetadata:
		return m.OldMetadata(ctx)
	case auditlog.FieldSeverity:
		return m.OldSeverity(ctx)
	case auditlog.FieldDescription:
		return m.OldDescription(ctx)
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case auditlog.FieldAction:
		v, ok := value.(auditlog.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case auditlog.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case auditlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case auditlog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case auditlog.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case auditlog.FieldSeverity:
		v, ok := value.(auditlog.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case auditlog.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldUserID) {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.FieldCleared(auditlog.FieldResourceType) {
		fields = append(fields, auditlog.FieldResourceType)
	}
	if m.FieldCleared(auditlog.FieldResourceID) {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.FieldCleared(auditlog.FieldIPAddress) {
		fields = append(fields, auditlog.FieldIPAddress)
	}
	if m.FieldCleared(auditlog.FieldUserAgent) {
		fields = append(fields, auditlog.FieldUserAgent)
	}
	if m.FieldCleared(auditlog.FieldMetadata) {
		fields = append(fields, auditlog.FieldMetadata)
	}
	if m.FieldCleared(auditlog.FieldDescription) {
		fields = append(fields, auditlog.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldUserID:
		m.ClearUserID()
		return nil
	case auditlog.FieldResourceType:
		m.ClearResourceType()
		return nil
	case auditlog.FieldResourceID:
		m.ClearResourceID()
		return nil
	case auditlog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case auditlog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case auditlog.FieldMetadata:
		m.ClearMetadata()
		return nil
	case auditlog.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldUserID:
		m.ResetUserID()
		return nil
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldResourceType:
		m.ResetResourceType()
		return nil
	case auditlog.FieldResourceID:
		m.ResetResourceID()
		return nil
	case auditlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case auditlog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case auditlog.FieldMetadata:
		m.ResetMetadata()
		return nil
	case auditlog.FieldSeverity:
		m.ResetSeverity()
		return nil
	case auditlog.FieldDescription:
		m.ResetDescription()
		return nil
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, auditlog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auditlog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, auditlog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	switch name {
	case auditlog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	switch name {
	case auditlog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	switch name {
	case auditlog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// EmailSequenceMutation represents an operation that mutates the EmailSequence nodes in the graph.
type EmailSequenceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	description        *string
	status             *emailsequence.Status
	trigger            *emailsequence.Trigger
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	created_by         *int
	clearedcreated_by  bool
	steps              map[int]struct{}
	removedsteps       map[int]struct{}
	clearedsteps       bool
	enrollments        map[int]struct{}
	removedenrollments map[int]struct{}
	clearedenrollments bool
	done               bool
	oldValue           func(context.Context) (*EmailSequence, error)
	predicates         []predicate.EmailSequence
}

var _ ent.Mutation = (*EmailSequenceMutation)(nil)

// emailsequenceOption allows management of the mutation configuration using functional options.
type emailsequenceOption func(*EmailSequenceMutation)

// newEmailSequenceMutation creates new mutation for the EmailSequence entity.
func newEmailSequenceMutation(c config, op Op, opts ...emailsequenceOption) *EmailSequenceMutation {
	m := &EmailSequenceMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailSequence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailSequenceID sets the ID field of the mutation.
func withEmailSequenceID(id int) emailsequenceOption {
	return func(m *EmailSequenceMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailSequence
		)
		m.oldValue = func(ctx context.Context) (*EmailSequence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailSequence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailSequence sets the old EmailSequence of the mutation.
func withEmailSequence(node *EmailSequence) emailsequenceOption {
	return func(m *EmailSequenceMutation) {
		m.oldValue = func(context.Context) (*EmailSequence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailSequenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailSequenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailSequenceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailSequenceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailSequence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *EmailSequenceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmailSequenceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EmailSequence entity.
// If the EmailSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmailSequenceMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EmailSequenceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EmailSequenceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EmailSequence entity.
// If the EmailSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EmailSequenceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[emailsequence.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EmailSequenceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[emailsequence.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EmailSequenceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, emailsequence.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *EmailSequenceMutation) SetStatus(e emailsequence.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EmailSequenceMutation) Status() (r emailsequence.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EmailSequence entity.
// If the EmailSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceMutation) OldStatus(ctx context.Context) (v emailsequence.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EmailSequenceMutation) ResetStatus() {
	m.status = nil
}

// SetTrigger sets the "trigger" field.
func (m *EmailSequenceMutation) SetTrigger(e emailsequence.Trigger) {
	m.trigger = &e
}

// Trigger returns the value of the "trigger" field in the mutation.
func (m *EmailSequenceMutation) Trigger() (r emailsequence.Trigger, exists bool) {
	v := m.trigger
	if v == nil {
		return
	}
	return *v, true
}

// OldTrigger returns the old "trigger" field's value of the EmailSequence entity.
// If the EmailSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceMutation) OldTrigger(ctx context.Context) (v emailsequence.Trigger, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrigger is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrigger requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrigger: %w", err)
	}
	return oldValue.Trigger, nil
}

// ResetTrigger resets all changes to the "trigger" field.
func (m *EmailSequenceMutation) ResetTrigger() {
	m.trigger = nil
}

// SetCreatedByUserID sets the "created_by_user_id" field.
func (m *EmailSequenceMutation) SetCreatedByUserID(i int) {
	m.created_by = &i
}

// CreatedByUserID returns the value of the "created_by_user_id" field in the mutation.
func (m *EmailSequenceMutation) CreatedByUserID() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByUserID returns the old "created_by_user_id" field's value of the EmailSequence entity.
// If the EmailSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceMutation) OldCreatedByUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByUserID: %w", err)
	}
	return oldValue.CreatedByUserID, nil
}

// ResetCreatedByUserID resets all changes to the "created_by_user_id" field.
func (m *EmailSequenceMutation) ResetCreatedByUserID() {
	m.created_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailSequenceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailSequenceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailSequence entity.
// If the EmailSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailSequenceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailSequenceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailSequenceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailSequence entity.
// If the EmailSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailSequenceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *EmailSequenceMutation) SetCreatedByID(id int) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *EmailSequenceMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
	m.clearedFields[emailsequence.FieldCreatedByUserID] = struct{}{}
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *EmailSequenceMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *EmailSequenceMutation) CreatedByID() (id int, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *EmailSequenceMutation) CreatedByIDs() (ids []int) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *EmailSequenceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddStepIDs adds the "steps" edge to the EmailSequenceStep entity by ids.
func (m *EmailSequenceMutation) AddStepIDs(ids ...int) {
	if m.steps == nil {
		m.steps = make(map[int]struct{})
	}
	for i := range ids {
		m.steps[ids[i]] = struct{}{}
	}
}

// ClearSteps clears the "steps" edge to the EmailSequenceStep entity.
func (m *EmailSequenceMutation) ClearSteps() {
	m.clearedsteps = true
}

// StepsCleared reports if the "steps" edge to the EmailSequenceStep entity was cleared.
func (m *EmailSequenceMutation) StepsCleared() bool {
	return m.clearedsteps
}

// RemoveStepIDs removes the "steps" edge to the EmailSequenceStep entity by IDs.
func (m *EmailSequenceMutation) RemoveStepIDs(ids ...int) {
	if m.removedsteps == nil {
		m.removedsteps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.steps, ids[i])
		m.removedsteps[ids[i]] = struct{}{}
	}
}

// RemovedSteps returns the removed IDs of the "steps" edge to the EmailSequenceStep entity.
func (m *EmailSequenceMutation) RemovedStepsIDs() (ids []int) {
	for id := range m.removedsteps {
		ids = append(ids, id)
	}
	return
}

// StepsIDs returns the "steps" edge IDs in the mutation.
func (m *EmailSequenceMutation) StepsIDs() (ids []int) {
	for id := range m.steps {
		ids = append(ids, id)
	}
	return
}

// ResetSteps resets all changes to the "steps" edge.
func (m *EmailSequenceMutation) ResetSteps() {
	m.steps = nil
	m.clearedsteps = false
	m.removedsteps = nil
}

// AddEnrollmentIDs adds the "enrollments" edge to the EmailSequenceEnrollment entity by ids.
func (m *EmailSequenceMutation) AddEnrollmentIDs(ids ...int) {
	if m.enrollments == nil {
		m.enrollments = make(map[int]struct{})
	}
	for i := range ids {
		m.enrollments[ids[i]] = struct{}{}
	}
}

// ClearEnrollments clears the "enrollments" edge to the EmailSequenceEnrollment entity.
func (m *EmailSequenceMutation) ClearEnrollments() {
	m.clearedenrollments = true
}

// EnrollmentsCleared reports if the "enrollments" edge to the EmailSequenceEnrollment entity was cleared.
func (m *EmailSequenceMutation) EnrollmentsCleared() bool {
	return m.clearedenrollments
}

// RemoveEnrollmentIDs removes the "enrollments" edge to the EmailSequenceEnrollment entity by IDs.
func (m *EmailSequenceMutation) RemoveEnrollmentIDs(ids ...int) {
	if m.removedenrollments == nil {
		m.removedenrollments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.enrollments, ids[i])
		m.removedenrollments[ids[i]] = struct{}{}
	}
}

// RemovedEnrollments returns the removed IDs of the "enrollments" edge to the EmailSequenceEnrollment entity.
func (m *EmailSequenceMutation) RemovedEnrollmentsIDs() (ids []int) {
	for id := range m.removedenrollments {
		ids = append(ids, id)
	}
	return
}

// EnrollmentsIDs returns the "enrollments" edge IDs in the mutation.
func (m *EmailSequenceMutation) EnrollmentsIDs() (ids []int) {
	for id := range m.enrollments {
		ids = append(ids, id)
	}
	return
}

// ResetEnrollments resets all changes to the "enrollments" edge.
func (m *EmailSequenceMutation) ResetEnrollments() {
	m.enrollments = nil
	m.clearedenrollments = false
	m.removedenrollments = nil
}

// Where appends a list predicates to the EmailSequenceMutation builder.
func (m *EmailSequenceMutation) Where(ps ...predicate.EmailSequence) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailSequenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailSequenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailSequence, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailSequenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailSequenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailSequence).
func (m *EmailSequenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailSequenceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, emailsequence.FieldName)
	}
	if m.description != nil {
		fields = append(fields, emailsequence.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, emailsequence.FieldStatus)
	}
	if m.trigger != nil {
		fields = append(fields, emailsequence.FieldTrigger)
	}
	if m.created_by != nil {
		fields = append(fields, emailsequence.FieldCreatedByUserID)
	}
	if m.created_at != nil {
		fields = append(fields, emailsequence.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailsequence.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailSequenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailsequence.FieldName:
		return m.Name()
	case emailsequence.FieldDescription:
		return m.Description()
	case emailsequence.FieldStatus:
		return m.Status()
	case emailsequence.FieldTrigger:
		return m.Trigger()
	case emailsequence.FieldCreatedByUserID:
		return m.CreatedByUserID()
	case emailsequence.FieldCreatedAt:
		return m.CreatedAt()
	case emailsequence.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailSequenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailsequence.FieldName:
		return m.OldName(ctx)
	case emailsequence.FieldDescription:
		return m.OldDescription(ctx)
	case emailsequence.FieldStatus:
		return m.OldStatus(ctx)
	case emailsequence.FieldTrigger:
		return m.OldTrigger(ctx)
	case emailsequence.FieldCreatedByUserID:
		return m.OldCreatedByUserID(ctx)
	case emailsequence.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailsequence.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailSequence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSequenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailsequence.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case emailsequence.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case emailsequence.FieldStatus:
		v, ok := value.(emailsequence.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case emailsequence.FieldTrigger:
		v, ok := value.(emailsequence.Trigger)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrigger(v)
		return nil
	case emailsequence.FieldCreatedByUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByUserID(v)
		return nil
	case emailsequence.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailsequence.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailSequence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailSequenceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailSequenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSequenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailSequence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailSequenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailsequence.FieldDescription) {
		fields = append(fields, emailsequence.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailSequenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailSequenceMutation) ClearField(name string) error {
	switch name {
	case emailsequence.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown EmailSequence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailSequenceMutation) ResetField(name string) error {
	switch name {
	case emailsequence.FieldName:
		m.ResetName()
		return nil
	case emailsequence.FieldDescription:
		m.ResetDescription()
		return nil
	case emailsequence.FieldStatus:
		m.ResetStatus()
		return nil
	case emailsequence.FieldTrigger:
		m.ResetTrigger()
		return nil
	case emailsequence.FieldCreatedByUserID:
		m.ResetCreatedByUserID()
		return nil
	case emailsequence.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailsequence.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailSequence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailSequenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.created_by != nil {
		edges = append(edges, emailsequence.EdgeCreatedBy)
	}
	if m.steps != nil {
		edges = append(edges, emailsequence.EdgeSteps)
	}
	if m.enrollments != nil {
		edges = append(edges, emailsequence.EdgeEnrollments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailSequenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailsequence.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case emailsequence.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.steps))
		for id := range m.steps {
			ids = append(ids, id)
		}
		return ids
	case emailsequence.EdgeEnrollments:
		ids := make([]ent.Value, 0, len(m.enrollments))
		for id := range m.enrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailSequenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsteps != nil {
		edges = append(edges, emailsequence.EdgeSteps)
	}
	if m.removedenrollments != nil {
		edges = append(edges, emailsequence.EdgeEnrollments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailSequenceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case emailsequence.EdgeSteps:
		ids := make([]ent.Value, 0, len(m.removedsteps))
		for id := range m.removedsteps {
			ids = append(ids, id)
		}
		return ids
	case emailsequence.EdgeEnrollments:
		ids := make([]ent.Value, 0, len(m.removedenrollments))
		for id := range m.removedenrollments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailSequenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreated_by {
		edges = append(edges, emailsequence.EdgeCreatedBy)
	}
	if m.clearedsteps {
		edges = append(edges, emailsequence.EdgeSteps)
	}
	if m.clearedenrollments {
		edges = append(edges, emailsequence.EdgeEnrollments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailSequenceMutation) EdgeCleared(name string) bool {
	switch name {
	case emailsequence.EdgeCreatedBy:
		return m.clearedcreated_by
	case emailsequence.EdgeSteps:
		return m.clearedsteps
	case emailsequence.EdgeEnrollments:
		return m.clearedenrollments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailSequenceMutation) ClearEdge(name string) error {
	switch name {
	case emailsequence.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown EmailSequence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailSequenceMutation) ResetEdge(name string) error {
	switch name {
	case emailsequence.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case emailsequence.EdgeSteps:
		m.ResetSteps()
		return nil
	case emailsequence.EdgeEnrollments:
		m.ResetEnrollments()
		return nil
	}
	return fmt.Errorf("unknown EmailSequence edge %s", name)
}

// EmailSequenceEnrollmentMutation represents an operation that mutates the EmailSequenceEnrollment nodes in the graph.
type EmailSequenceEnrollmentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	status             *emailsequenceenrollment.Status
	current_step       *int
	addcurrent_step    *int
	enrolled_at        *time.Time
	completed_at       *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	sequence           *int
	clearedsequence    bool
	lead               *int
	clearedlead        bool
	enrolled_by        *int
	clearedenrolled_by bool
	sends              map[int]struct{}
	removedsends       map[int]struct{}
	clearedsends       bool
	done               bool
	oldValue           func(context.Context) (*EmailSequenceEnrollment, error)
	predicates         []predicate.EmailSequenceEnrollment
}

var _ ent.Mutation = (*EmailSequenceEnrollmentMutation)(nil)

// emailsequenceenrollmentOption allows management of the mutation configuration using functional options.
type emailsequenceenrollmentOption func(*EmailSequenceEnrollmentMutation)

// newEmailSequenceEnrollmentMutation creates new mutation for the EmailSequenceEnrollment entity.
func newEmailSequenceEnrollmentMutation(c config, op Op, opts ...emailsequenceenrollmentOption) *EmailSequenceEnrollmentMutation {
	m := &EmailSequenceEnrollmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailSequenceEnrollment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailSequenceEnrollmentID sets the ID field of the mutation.
func withEmailSequenceEnrollmentID(id int) emailsequenceenrollmentOption {
	return func(m *EmailSequenceEnrollmentMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailSequenceEnrollment
		)
		m.oldValue = func(ctx context.Context) (*EmailSequenceEnrollment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailSequenceEnrollment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailSequenceEnrollment sets the old EmailSequenceEnrollment of the mutation.
func withEmailSequenceEnrollment(node *EmailSequenceEnrollment) emailsequenceenrollmentOption {
	return func(m *EmailSequenceEnrollmentMutation) {
		m.oldValue = func(context.Context) (*EmailSequenceEnrollment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailSequenceEnrollmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailSequenceEnrollmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailSequenceEnrollmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailSequenceEnrollmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailSequenceEnrollment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSequenceID sets the "sequence_id" field.
func (m *EmailSequenceEnrollmentMutation) SetSequenceID(i int) {
	m.sequence = &i
}

// SequenceID returns the value of the "sequence_id" field in the mutation.
func (m *EmailSequenceEnrollmentMutation) SequenceID() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceID returns the old "sequence_id" field's value of the EmailSequenceEnrollment entity.
// If the EmailSequenceEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceEnrollmentMutation) OldSequenceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceID: %w", err)
	}
	return oldValue.SequenceID, nil
}

// ResetSequenceID resets all changes to the "sequence_id" field.
func (m *EmailSequenceEnrollmentMutation) ResetSequenceID() {
	m.sequence = nil
}

// SetLeadID sets the "lead_id" field.
func (m *EmailSequenceEnrollmentMutation) SetLeadID(i int) {
	m.lead = &i
}

// LeadID returns the value of the "lead_id" field in the mutation.
func (m *EmailSequenceEnrollmentMutation) LeadID() (r int, exists bool) {
	v := m.lead
	if v == nil {
		return
	}
	return *v, true
}

// OldLeadID returns the old "lead_id" field's value of the EmailSequenceEnrollment entity.
// If the EmailSequenceEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceEnrollmentMutation) OldLeadID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeadID: %w", err)
	}
	return oldValue.LeadID, nil
}

// ResetLeadID resets all changes to the "lead_id" field.
func (m *EmailSequenceEnrollmentMutation) ResetLeadID() {
	m.lead = nil
}

// SetEnrolledByUserID sets the "enrolled_by_user_id" field.
func (m *EmailSequenceEnrollmentMutation) SetEnrolledByUserID(i int) {
	m.enrolled_by = &i
}

// EnrolledByUserID returns the value of the "enrolled_by_user_id" field in the mutation.
func (m *EmailSequenceEnrollmentMutation) EnrolledByUserID() (r int, exists bool) {
	v := m.enrolled_by
	if v == nil {
		return
	}
	return *v, true
}

// OldEnrolledByUserID returns the old "enrolled_by_user_id" field's value of the EmailSequenceEnrollment entity.
// If the EmailSequenceEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceEnrollmentMutation) OldEnrolledByUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnrolledByUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnrolledByUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnrolledByUserID: %w", err)
	}
	return oldValue.EnrolledByUserID, nil
}

// ResetEnrolledByUserID resets all changes to the "enrolled_by_user_id" field.
func (m *EmailSequenceEnrollmentMutation) ResetEnrolledByUserID() {
	m.enrolled_by = nil
}

// SetStatus sets the "status" field.
func (m *EmailSequenceEnrollmentMutation) SetStatus(e emailsequenceenrollment.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EmailSequenceEnrollmentMutation) Status() (r emailsequenceenrollment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EmailSequenceEnrollment entity.
// If the EmailSequenceEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceEnrollmentMutation) OldStatus(ctx context.Context) (v emailsequenceenrollment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EmailSequenceEnrollmentMutation) ResetStatus() {
	m.status = nil
}

// SetCurrentStep sets the "current_step" field.
func (m *EmailSequenceEnrollmentMutation) SetCurrentStep(i int) {
	m.current_step = &i
	m.addcurrent_step = nil
}

// CurrentStep returns the value of the "current_step" field in the mutation.
func (m *EmailSequenceEnrollmentMutation) CurrentStep() (r int, exists bool) {
	v := m.current_step
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentStep returns the old "current_step" field's value of the EmailSequenceEnrollment entity.
// If the EmailSequenceEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceEnrollmentMutation) OldCurrentStep(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentStep: %w", err)
	}
	return oldValue.CurrentStep, nil
}

// AddCurrentStep adds i to the "current_step" field.
func (m *EmailSequenceEnrollmentMutation) AddCurrentStep(i int) {
	if m.addcurrent_step != nil {
		*m.addcurrent_step += i
	} else {
		m.addcurrent_step = &i
	}
}

// AddedCurrentStep returns the value that was added to the "current_step" field in this mutation.
func (m *EmailSequenceEnrollmentMutation) AddedCurrentStep() (r int, exists bool) {
	v := m.addcurrent_step
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentStep resets all changes to the "current_step" field.
func (m *EmailSequenceEnrollmentMutation) ResetCurrentStep() {
	m.current_step = nil
	m.addcurrent_step = nil
}

// SetEnrolledAt sets the "enrolled_at" field.
func (m *EmailSequenceEnrollmentMutation) SetEnrolledAt(t time.Time) {
	m.enrolled_at = &t
}

// EnrolledAt returns the value of the "enrolled_at" field in the mutation.
func (m *EmailSequenceEnrollmentMutation) EnrolledAt() (r time.Time, exists bool) {
	v := m.enrolled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEnrolledAt returns the old "enrolled_at" field's value of the EmailSequenceEnrollment entity.
// If the EmailSequenceEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceEnrollmentMutation) OldEnrolledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnrolledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnrolledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnrolledAt: %w", err)
	}
	return oldValue.EnrolledAt, nil
}

// ResetEnrolledAt resets all changes to the "enrolled_at" field.
func (m *EmailSequenceEnrollmentMutation) ResetEnrolledAt() {
	m.enrolled_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *EmailSequenceEnrollmentMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *EmailSequenceEnrollmentMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the EmailSequenceEnrollment entity.
// If the EmailSequenceEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceEnrollmentMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *EmailSequenceEnrollmentMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[emailsequenceenrollment.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *EmailSequenceEnrollmentMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[emailsequenceenrollment.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *EmailSequenceEnrollmentMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, emailsequenceenrollment.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailSequenceEnrollmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailSequenceEnrollmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailSequenceEnrollment entity.
// If the EmailSequenceEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceEnrollmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailSequenceEnrollmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailSequenceEnrollmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailSequenceEnrollmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailSequenceEnrollment entity.
// If the EmailSequenceEnrollment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceEnrollmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailSequenceEnrollmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearSequence clears the "sequence" edge to the EmailSequence entity.
func (m *EmailSequenceEnrollmentMutation) ClearSequence() {
	m.clearedsequence = true
	m.clearedFields[emailsequenceenrollment.FieldSequenceID] = struct{}{}
}

// SequenceCleared reports if the "sequence" edge to the EmailSequence entity was cleared.
func (m *EmailSequenceEnrollmentMutation) SequenceCleared() bool {
	return m.clearedsequence
}

// SequenceIDs returns the "sequence" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SequenceID instead. It exists only for internal usage by the builders.
func (m *EmailSequenceEnrollmentMutation) SequenceIDs() (ids []int) {
	if id := m.sequence; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSequence resets all changes to the "sequence" edge.
func (m *EmailSequenceEnrollmentMutation) ResetSequence() {
	m.sequence = nil
	m.clearedsequence = false
}

// ClearLead clears the "lead" edge to the Lead entity.
func (m *EmailSequenceEnrollmentMutation) ClearLead() {
	m.clearedlead = true
	m.clearedFields[emailsequenceenrollment.FieldLeadID] = struct{}{}
}

// LeadCleared reports if the "lead" edge to the Lead entity was cleared.
func (m *EmailSequenceEnrollmentMutation) LeadCleared() bool {
	return m.clearedlead
}

// LeadIDs returns the "lead" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeadID instead. It exists only for internal usage by the builders.
func (m *EmailSequenceEnrollmentMutation) LeadIDs() (ids []int) {
	if id := m.lead; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLead resets all changes to the "lead" edge.
func (m *EmailSequenceEnrollmentMutation) ResetLead() {
	m.lead = nil
	m.clearedlead = false
}

// SetEnrolledByID sets the "enrolled_by" edge to the User entity by id.
func (m *EmailSequenceEnrollmentMutation) SetEnrolledByID(id int) {
	m.enrolled_by = &id
}

// ClearEnrolledBy clears the "enrolled_by" edge to the User entity.
func (m *EmailSequenceEnrollmentMutation) ClearEnrolledBy() {
	m.clearedenrolled_by = true
	m.clearedFields[emailsequenceenrollment.FieldEnrolledByUserID] = struct{}{}
}

// EnrolledByCleared reports if the "enrolled_by" edge to the User entity was cleared.
func (m *EmailSequenceEnrollmentMutation) EnrolledByCleared() bool {
	return m.clearedenrolled_by
}

// EnrolledByID returns the "enrolled_by" edge ID in the mutation.
func (m *EmailSequenceEnrollmentMutation) EnrolledByID() (id int, exists bool) {
	if m.enrolled_by != nil {
		return *m.enrolled_by, true
	}
	return
}

// EnrolledByIDs returns the "enrolled_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnrolledByID instead. It exists only for internal usage by the builders.
func (m *EmailSequenceEnrollmentMutation) EnrolledByIDs() (ids []int) {
	if id := m.enrolled_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnrolledBy resets all changes to the "enrolled_by" edge.
func (m *EmailSequenceEnrollmentMutation) ResetEnrolledBy() {
	m.enrolled_by = nil
	m.clearedenrolled_by = false
}

// AddSendIDs adds the "sends" edge to the EmailSequenceSend entity by ids.
func (m *EmailSequenceEnrollmentMutation) AddSendIDs(ids ...int) {
	if m.sends == nil {
		m.sends = make(map[int]struct{})
	}
	for i := range ids {
		m.sends[ids[i]] = struct{}{}
	}
}

// ClearSends clears the "sends" edge to the EmailSequenceSend entity.
func (m *EmailSequenceEnrollmentMutation) ClearSends() {
	m.clearedsends = true
}

// SendsCleared reports if the "sends" edge to the EmailSequenceSend entity was cleared.
func (m *EmailSequenceEnrollmentMutation) SendsCleared() bool {
	return m.clearedsends
}

// RemoveSendIDs removes the "sends" edge to the EmailSequenceSend entity by IDs.
func (m *EmailSequenceEnrollmentMutation) RemoveSendIDs(ids ...int) {
	if m.removedsends == nil {
		m.removedsends = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sends, ids[i])
		m.removedsends[ids[i]] = struct{}{}
	}
}

// RemovedSends returns the removed IDs of the "sends" edge to the EmailSequenceSend entity.
func (m *EmailSequenceEnrollmentMutation) RemovedSendsIDs() (ids []int) {
	for id := range m.removedsends {
		ids = append(ids, id)
	}
	return
}

// SendsIDs returns the "sends" edge IDs in the mutation.
func (m *EmailSequenceEnrollmentMutation) SendsIDs() (ids []int) {
	for id := range m.sends {
		ids = append(ids, id)
	}
	return
}

// ResetSends resets all changes to the "sends" edge.
func (m *EmailSequenceEnrollmentMutation) ResetSends() {
	m.sends = nil
	m.clearedsends = false
	m.removedsends = nil
}

// Where appends a list predicates to the EmailSequenceEnrollmentMutation builder.
func (m *EmailSequenceEnrollmentMutation) Where(ps ...predicate.EmailSequenceEnrollment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailSequenceEnrollmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailSequenceEnrollmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailSequenceEnrollment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailSequenceEnrollmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailSequenceEnrollmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailSequenceEnrollment).
func (m *EmailSequenceEnrollmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailSequenceEnrollmentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.sequence != nil {
		fields = append(fields, emailsequenceenrollment.FieldSequenceID)
	}
	if m.lead != nil {
		fields = append(fields, emailsequenceenrollment.FieldLeadID)
	}
	if m.enrolled_by != nil {
		fields = append(fields, emailsequenceenrollment.FieldEnrolledByUserID)
	}
	if m.status != nil {
		fields = append(fields, emailsequenceenrollment.FieldStatus)
	}
	if m.current_step != nil {
		fields = append(fields, emailsequenceenrollment.FieldCurrentStep)
	}
	if m.enrolled_at != nil {
		fields = append(fields, emailsequenceenrollment.FieldEnrolledAt)
	}
	if m.completed_at != nil {
		fields = append(fields, emailsequenceenrollment.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, emailsequenceenrollment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailsequenceenrollment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailSequenceEnrollmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailsequenceenrollment.FieldSequenceID:
		return m.SequenceID()
	case emailsequenceenrollment.FieldLeadID:
		return m.LeadID()
	case emailsequenceenrollment.FieldEnrolledByUserID:
		return m.EnrolledByUserID()
	case emailsequenceenrollment.FieldStatus:
		return m.Status()
	case emailsequenceenrollment.FieldCurrentStep:
		return m.CurrentStep()
	case emailsequenceenrollment.FieldEnrolledAt:
		return m.EnrolledAt()
	case emailsequenceenrollment.FieldCompletedAt:
		return m.CompletedAt()
	case emailsequenceenrollment.FieldCreatedAt:
		return m.CreatedAt()
	case emailsequenceenrollment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailSequenceEnrollmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailsequenceenrollment.FieldSequenceID:
		return m.OldSequenceID(ctx)
	case emailsequenceenrollment.FieldLeadID:
		return m.OldLeadID(ctx)
	case emailsequenceenrollment.FieldEnrolledByUserID:
		return m.OldEnrolledByUserID(ctx)
	case emailsequenceenrollment.FieldStatus:
		return m.OldStatus(ctx)
	case emailsequenceenrollment.FieldCurrentStep:
		return m.OldCurrentStep(ctx)
	case emailsequenceenrollment.FieldEnrolledAt:
		return m.OldEnrolledAt(ctx)
	case emailsequenceenrollment.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case emailsequenceenrollment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailsequenceenrollment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailSequenceEnrollment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSequenceEnrollmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailsequenceenrollment.FieldSequenceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceID(v)
		return nil
	case emailsequenceenrollment.FieldLeadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeadID(v)
		return nil
	case emailsequenceenrollment.FieldEnrolledByUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnrolledByUserID(v)
		return nil
	case emailsequenceenrollment.FieldStatus:
		v, ok := value.(emailsequenceenrollment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case emailsequenceenrollment.FieldCurrentStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentStep(v)
		return nil
	case emailsequenceenrollment.FieldEnrolledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnrolledAt(v)
		return nil
	case emailsequenceenrollment.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case emailsequenceenrollment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailsequenceenrollment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceEnrollment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailSequenceEnrollmentMutation) AddedFields() []string {
	var fields []string
	if m.addcurrent_step != nil {
		fields = append(fields, emailsequenceenrollment.FieldCurrentStep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailSequenceEnrollmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case emailsequenceenrollment.FieldCurrentStep:
		return m.AddedCurrentStep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSequenceEnrollmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case emailsequenceenrollment.FieldCurrentStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentStep(v)
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceEnrollment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailSequenceEnrollmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailsequenceenrollment.FieldCompletedAt) {
		fields = append(fields, emailsequenceenrollment.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailSequenceEnrollmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailSequenceEnrollmentMutation) ClearField(name string) error {
	switch name {
	case emailsequenceenrollment.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceEnrollment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailSequenceEnrollmentMutation) ResetField(name string) error {
	switch name {
	case emailsequenceenrollment.FieldSequenceID:
		m.ResetSequenceID()
		return nil
	case emailsequenceenrollment.FieldLeadID:
		m.ResetLeadID()
		return nil
	case emailsequenceenrollment.FieldEnrolledByUserID:
		m.ResetEnrolledByUserID()
		return nil
	case emailsequenceenrollment.FieldStatus:
		m.ResetStatus()
		return nil
	case emailsequenceenrollment.FieldCurrentStep:
		m.ResetCurrentStep()
		return nil
	case emailsequenceenrollment.FieldEnrolledAt:
		m.ResetEnrolledAt()
		return nil
	case emailsequenceenrollment.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case emailsequenceenrollment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailsequenceenrollment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceEnrollment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailSequenceEnrollmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.sequence != nil {
		edges = append(edges, emailsequenceenrollment.EdgeSequence)
	}
	if m.lead != nil {
		edges = append(edges, emailsequenceenrollment.EdgeLead)
	}
	if m.enrolled_by != nil {
		edges = append(edges, emailsequenceenrollment.EdgeEnrolledBy)
	}
	if m.sends != nil {
		edges = append(edges, emailsequenceenrollment.EdgeSends)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailSequenceEnrollmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailsequenceenrollment.EdgeSequence:
		if id := m.sequence; id != nil {
			return []ent.Value{*id}
		}
	case emailsequenceenrollment.EdgeLead:
		if id := m.lead; id != nil {
			return []ent.Value{*id}
		}
	case emailsequenceenrollment.EdgeEnrolledBy:
		if id := m.enrolled_by; id != nil {
			return []ent.Value{*id}
		}
	case emailsequenceenrollment.EdgeSends:
		ids := make([]ent.Value, 0, len(m.sends))
		for id := range m.sends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailSequenceEnrollmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsends != nil {
		edges = append(edges, emailsequenceenrollment.EdgeSends)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailSequenceEnrollmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case emailsequenceenrollment.EdgeSends:
		ids := make([]ent.Value, 0, len(m.removedsends))
		for id := range m.removedsends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailSequenceEnrollmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsequence {
		edges = append(edges, emailsequenceenrollment.EdgeSequence)
	}
	if m.clearedlead {
		edges = append(edges, emailsequenceenrollment.EdgeLead)
	}
	if m.clearedenrolled_by {
		edges = append(edges, emailsequenceenrollment.EdgeEnrolledBy)
	}
	if m.clearedsends {
		edges = append(edges, emailsequenceenrollment.EdgeSends)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailSequenceEnrollmentMutation) EdgeCleared(name string) bool {
	switch name {
	case emailsequenceenrollment.EdgeSequence:
		return m.clearedsequence
	case emailsequenceenrollment.EdgeLead:
		return m.clearedlead
	case emailsequenceenrollment.EdgeEnrolledBy:
		return m.clearedenrolled_by
	case emailsequenceenrollment.EdgeSends:
		return m.clearedsends
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailSequenceEnrollmentMutation) ClearEdge(name string) error {
	switch name {
	case emailsequenceenrollment.EdgeSequence:
		m.ClearSequence()
		return nil
	case emailsequenceenrollment.EdgeLead:
		m.ClearLead()
		return nil
	case emailsequenceenrollment.EdgeEnrolledBy:
		m.ClearEnrolledBy()
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceEnrollment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailSequenceEnrollmentMutation) ResetEdge(name string) error {
	switch name {
	case emailsequenceenrollment.EdgeSequence:
		m.ResetSequence()
		return nil
	case emailsequenceenrollment.EdgeLead:
		m.ResetLead()
		return nil
	case emailsequenceenrollment.EdgeEnrolledBy:
		m.ResetEnrolledBy()
		return nil
	case emailsequenceenrollment.EdgeSends:
		m.ResetSends()
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceEnrollment edge %s", name)
}

// EmailSequenceSendMutation represents an operation that mutates the EmailSequenceSend nodes in the graph.
type EmailSequenceSendMutation struct {
	config
	op                Op
	typ               string
	id                *int
	status            *emailsequencesend.Status
	scheduled_for     *time.Time
	sent_at           *time.Time
	opened_at         *time.Time
	clicked_at        *time.Time
	bounced           *bool
	error_message     *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	enrollment        *int
	clearedenrollment bool
	step              *int
	clearedstep       bool
	lead              *int
	clearedlead       bool
	done              bool
	oldValue          func(context.Context) (*EmailSequenceSend, error)
	predicates        []predicate.EmailSequenceSend
}

var _ ent.Mutation = (*EmailSequenceSendMutation)(nil)

// emailsequencesendOption allows management of the mutation configuration using functional options.
type emailsequencesendOption func(*EmailSequenceSendMutation)

// newEmailSequenceSendMutation creates new mutation for the EmailSequenceSend entity.
func newEmailSequenceSendMutation(c config, op Op, opts ...emailsequencesendOption) *EmailSequenceSendMutation {
	m := &EmailSequenceSendMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailSequenceSend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailSequenceSendID sets the ID field of the mutation.
func withEmailSequenceSendID(id int) emailsequencesendOption {
	return func(m *EmailSequenceSendMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailSequenceSend
		)
		m.oldValue = func(ctx context.Context) (*EmailSequenceSend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailSequenceSend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailSequenceSend sets the old EmailSequenceSend of the mutation.
func withEmailSequenceSend(node *EmailSequenceSend) emailsequencesendOption {
	return func(m *EmailSequenceSendMutation) {
		m.oldValue = func(context.Context) (*EmailSequenceSend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailSequenceSendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailSequenceSendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailSequenceSendMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailSequenceSendMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailSequenceSend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnrollmentID sets the "enrollment_id" field.
func (m *EmailSequenceSendMutation) SetEnrollmentID(i int) {
	m.enrollment = &i
}

// EnrollmentID returns the value of the "enrollment_id" field in the mutation.
func (m *EmailSequenceSendMutation) EnrollmentID() (r int, exists bool) {
	v := m.enrollment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnrollmentID returns the old "enrollment_id" field's value of the EmailSequenceSend entity.
// If the EmailSequenceSend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceSendMutation) OldEnrollmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnrollmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnrollmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnrollmentID: %w", err)
	}
	return oldValue.EnrollmentID, nil
}

// ResetEnrollmentID resets all changes to the "enrollment_id" field.
func (m *EmailSequenceSendMutation) ResetEnrollmentID() {
	m.enrollment = nil
}

// SetStepID sets the "step_id" field.
func (m *EmailSequenceSendMutation) SetStepID(i int) {
	m.step = &i
}

// StepID returns the value of the "step_id" field in the mutation.
func (m *EmailSequenceSendMutation) StepID() (r int, exists bool) {
	v := m.step
	if v == nil {
		return
	}
	return *v, true
}

// OldStepID returns the old "step_id" field's value of the EmailSequenceSend entity.
// If the EmailSequenceSend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceSendMutation) OldStepID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepID: %w", err)
	}
	return oldValue.StepID, nil
}

// ResetStepID resets all changes to the "step_id" field.
func (m *EmailSequenceSendMutation) ResetStepID() {
	m.step = nil
}

// SetLeadID sets the "lead_id" field.
func (m *EmailSequenceSendMutation) SetLeadID(i int) {
	m.lead = &i
}

// LeadID returns the value of the "lead_id" field in the mutation.
func (m *EmailSequenceSendMutation) LeadID() (r int, exists bool) {
	v := m.lead
	if v == nil {
		return
	}
	return *v, true
}

// OldLeadID returns the old "lead_id" field's value of the EmailSequenceSend entity.
// If the EmailSequenceSend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceSendMutation) OldLeadID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeadID: %w", err)
	}
	return oldValue.LeadID, nil
}

// ResetLeadID resets all changes to the "lead_id" field.
func (m *EmailSequenceSendMutation) ResetLeadID() {
	m.lead = nil
}

// SetStatus sets the "status" field.
func (m *EmailSequenceSendMutation) SetStatus(e emailsequencesend.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EmailSequenceSendMutation) Status() (r emailsequencesend.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EmailSequenceSend entity.
// If the EmailSequenceSend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceSendMutation) OldStatus(ctx context.Context) (v emailsequencesend.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EmailSequenceSendMutation) ResetStatus() {
	m.status = nil
}

// SetScheduledFor sets the "scheduled_for" field.
func (m *EmailSequenceSendMutation) SetScheduledFor(t time.Time) {
	m.scheduled_for = &t
}

// ScheduledFor returns the value of the "scheduled_for" field in the mutation.
func (m *EmailSequenceSendMutation) ScheduledFor() (r time.Time, exists bool) {
	v := m.scheduled_for
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledFor returns the old "scheduled_for" field's value of the EmailSequenceSend entity.
// If the EmailSequenceSend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceSendMutation) OldScheduledFor(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledFor: %w", err)
	}
	return oldValue.ScheduledFor, nil
}

// ResetScheduledFor resets all changes to the "scheduled_for" field.
func (m *EmailSequenceSendMutation) ResetScheduledFor() {
	m.scheduled_for = nil
}

// SetSentAt sets the "sent_at" field.
func (m *EmailSequenceSendMutation) SetSentAt(t time.Time) {
	m.sent_at = &t
}

// SentAt returns the value of the "sent_at" field in the mutation.
func (m *EmailSequenceSendMutation) SentAt() (r time.Time, exists bool) {
	v := m.sent_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSentAt returns the old "sent_at" field's value of the EmailSequenceSend entity.
// If the EmailSequenceSend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceSendMutation) OldSentAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentAt: %w", err)
	}
	return oldValue.SentAt, nil
}

// ClearSentAt clears the value of the "sent_at" field.
func (m *EmailSequenceSendMutation) ClearSentAt() {
	m.sent_at = nil
	m.clearedFields[emailsequencesend.FieldSentAt] = struct{}{}
}

// SentAtCleared returns if the "sent_at" field was cleared in this mutation.
func (m *EmailSequenceSendMutation) SentAtCleared() bool {
	_, ok := m.clearedFields[emailsequencesend.FieldSentAt]
	return ok
}

// ResetSentAt resets all changes to the "sent_at" field.
func (m *EmailSequenceSendMutation) ResetSentAt() {
	m.sent_at = nil
	delete(m.clearedFields, emailsequencesend.FieldSentAt)
}

// SetOpenedAt sets the "opened_at" field.
func (m *EmailSequenceSendMutation) SetOpenedAt(t time.Time) {
	m.opened_at = &t
}

// OpenedAt returns the value of the "opened_at" field in the mutation.
func (m *EmailSequenceSendMutation) OpenedAt() (r time.Time, exists bool) {
	v := m.opened_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenedAt returns the old "opened_at" field's value of the EmailSequenceSend entity.
// If the EmailSequenceSend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceSendMutation) OldOpenedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenedAt: %w", err)
	}
	return oldValue.OpenedAt, nil
}

// ClearOpenedAt clears the value of the "opened_at" field.
func (m *EmailSequenceSendMutation) ClearOpenedAt() {
	m.opened_at = nil
	m.clearedFields[emailsequencesend.FieldOpenedAt] = struct{}{}
}

// OpenedAtCleared returns if the "opened_at" field was cleared in this mutation.
func (m *EmailSequenceSendMutation) OpenedAtCleared() bool {
	_, ok := m.clearedFields[emailsequencesend.FieldOpenedAt]
	return ok
}

// ResetOpenedAt resets all changes to the "opened_at" field.
func (m *EmailSequenceSendMutation) ResetOpenedAt() {
	m.opened_at = nil
	delete(m.clearedFields, emailsequencesend.FieldOpenedAt)
}

// SetClickedAt sets the "clicked_at" field.
func (m *EmailSequenceSendMutation) SetClickedAt(t time.Time) {
	m.clicked_at = &t
}

// ClickedAt returns the value of the "clicked_at" field in the mutation.
func (m *EmailSequenceSendMutation) ClickedAt() (r time.Time, exists bool) {
	v := m.clicked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClickedAt returns the old "clicked_at" field's value of the EmailSequenceSend entity.
// If the EmailSequenceSend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceSendMutation) OldClickedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClickedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClickedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClickedAt: %w", err)
	}
	return oldValue.ClickedAt, nil
}

// ClearClickedAt clears the value of the "clicked_at" field.
func (m *EmailSequenceSendMutation) ClearClickedAt() {
	m.clicked_at = nil
	m.clearedFields[emailsequencesend.FieldClickedAt] = struct{}{}
}

// ClickedAtCleared returns if the "clicked_at" field was cleared in this mutation.
func (m *EmailSequenceSendMutation) ClickedAtCleared() bool {
	_, ok := m.clearedFields[emailsequencesend.FieldClickedAt]
	return ok
}

// ResetClickedAt resets all changes to the "clicked_at" field.
func (m *EmailSequenceSendMutation) ResetClickedAt() {
	m.clicked_at = nil
	delete(m.clearedFields, emailsequencesend.FieldClickedAt)
}

// SetBounced sets the "bounced" field.
func (m *EmailSequenceSendMutation) SetBounced(b bool) {
	m.bounced = &b
}

// Bounced returns the value of the "bounced" field in the mutation.
func (m *EmailSequenceSendMutation) Bounced() (r bool, exists bool) {
	v := m.bounced
	if v == nil {
		return
	}
	return *v, true
}

// OldBounced returns the old "bounced" field's value of the EmailSequenceSend entity.
// If the EmailSequenceSend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceSendMutation) OldBounced(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBounced is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBounced requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBounced: %w", err)
	}
	return oldValue.Bounced, nil
}

// ResetBounced resets all changes to the "bounced" field.
func (m *EmailSequenceSendMutation) ResetBounced() {
	m.bounced = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *EmailSequenceSendMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *EmailSequenceSendMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the EmailSequenceSend entity.
// If the EmailSequenceSend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceSendMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *EmailSequenceSendMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[emailsequencesend.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *EmailSequenceSendMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[emailsequencesend.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *EmailSequenceSendMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, emailsequencesend.FieldErrorMessage)
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailSequenceSendMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailSequenceSendMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailSequenceSend entity.
// If the EmailSequenceSend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceSendMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailSequenceSendMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailSequenceSendMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailSequenceSendMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailSequenceSend entity.
// If the EmailSequenceSend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceSendMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailSequenceSendMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearEnrollment clears the "enrollment" edge to the EmailSequenceEnrollment entity.
func (m *EmailSequenceSendMutation) ClearEnrollment() {
	m.clearedenrollment = true
	m.clearedFields[emailsequencesend.FieldEnrollmentID] = struct{}{}
}

// EnrollmentCleared reports if the "enrollment" edge to the EmailSequenceEnrollment entity was cleared.
func (m *EmailSequenceSendMutation) EnrollmentCleared() bool {
	return m.clearedenrollment
}

// EnrollmentIDs returns the "enrollment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnrollmentID instead. It exists only for internal usage by the builders.
func (m *EmailSequenceSendMutation) EnrollmentIDs() (ids []int) {
	if id := m.enrollment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnrollment resets all changes to the "enrollment" edge.
func (m *EmailSequenceSendMutation) ResetEnrollment() {
	m.enrollment = nil
	m.clearedenrollment = false
}

// ClearStep clears the "step" edge to the EmailSequenceStep entity.
func (m *EmailSequenceSendMutation) ClearStep() {
	m.clearedstep = true
	m.clearedFields[emailsequencesend.FieldStepID] = struct{}{}
}

// StepCleared reports if the "step" edge to the EmailSequenceStep entity was cleared.
func (m *EmailSequenceSendMutation) StepCleared() bool {
	return m.clearedstep
}

// StepIDs returns the "step" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StepID instead. It exists only for internal usage by the builders.
func (m *EmailSequenceSendMutation) StepIDs() (ids []int) {
	if id := m.step; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStep resets all changes to the "step" edge.
func (m *EmailSequenceSendMutation) ResetStep() {
	m.step = nil
	m.clearedstep = false
}

// ClearLead clears the "lead" edge to the Lead entity.
func (m *EmailSequenceSendMutation) ClearLead() {
	m.clearedlead = true
	m.clearedFields[emailsequencesend.FieldLeadID] = struct{}{}
}

// LeadCleared reports if the "lead" edge to the Lead entity was cleared.
func (m *EmailSequenceSendMutation) LeadCleared() bool {
	return m.clearedlead
}

// LeadIDs returns the "lead" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeadID instead. It exists only for internal usage by the builders.
func (m *EmailSequenceSendMutation) LeadIDs() (ids []int) {
	if id := m.lead; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLead resets all changes to the "lead" edge.
func (m *EmailSequenceSendMutation) ResetLead() {
	m.lead = nil
	m.clearedlead = false
}

// Where appends a list predicates to the EmailSequenceSendMutation builder.
func (m *EmailSequenceSendMutation) Where(ps ...predicate.EmailSequenceSend) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailSequenceSendMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailSequenceSendMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailSequenceSend, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailSequenceSendMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailSequenceSendMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailSequenceSend).
func (m *EmailSequenceSendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailSequenceSendMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.enrollment != nil {
		fields = append(fields, emailsequencesend.FieldEnrollmentID)
	}
	if m.step != nil {
		fields = append(fields, emailsequencesend.FieldStepID)
	}
	if m.lead != nil {
		fields = append(fields, emailsequencesend.FieldLeadID)
	}
	if m.status != nil {
		fields = append(fields, emailsequencesend.FieldStatus)
	}
	if m.scheduled_for != nil {
		fields = append(fields, emailsequencesend.FieldScheduledFor)
	}
	if m.sent_at != nil {
		fields = append(fields, emailsequencesend.FieldSentAt)
	}
	if m.opened_at != nil {
		fields = append(fields, emailsequencesend.FieldOpenedAt)
	}
	if m.clicked_at != nil {
		fields = append(fields, emailsequencesend.FieldClickedAt)
	}
	if m.bounced != nil {
		fields = append(fields, emailsequencesend.FieldBounced)
	}
	if m.error_message != nil {
		fields = append(fields, emailsequencesend.FieldErrorMessage)
	}
	if m.created_at != nil {
		fields = append(fields, emailsequencesend.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailsequencesend.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailSequenceSendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailsequencesend.FieldEnrollmentID:
		return m.EnrollmentID()
	case emailsequencesend.FieldStepID:
		return m.StepID()
	case emailsequencesend.FieldLeadID:
		return m.LeadID()
	case emailsequencesend.FieldStatus:
		return m.Status()
	case emailsequencesend.FieldScheduledFor:
		return m.ScheduledFor()
	case emailsequencesend.FieldSentAt:
		return m.SentAt()
	case emailsequencesend.FieldOpenedAt:
		return m.OpenedAt()
	case emailsequencesend.FieldClickedAt:
		return m.ClickedAt()
	case emailsequencesend.FieldBounced:
		return m.Bounced()
	case emailsequencesend.FieldErrorMessage:
		return m.ErrorMessage()
	case emailsequencesend.FieldCreatedAt:
		return m.CreatedAt()
	case emailsequencesend.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailSequenceSendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailsequencesend.FieldEnrollmentID:
		return m.OldEnrollmentID(ctx)
	case emailsequencesend.FieldStepID:
		return m.OldStepID(ctx)
	case emailsequencesend.FieldLeadID:
		return m.OldLeadID(ctx)
	case emailsequencesend.FieldStatus:
		return m.OldStatus(ctx)
	case emailsequencesend.FieldScheduledFor:
		return m.OldScheduledFor(ctx)
	case emailsequencesend.FieldSentAt:
		return m.OldSentAt(ctx)
	case emailsequencesend.FieldOpenedAt:
		return m.OldOpenedAt(ctx)
	case emailsequencesend.FieldClickedAt:
		return m.OldClickedAt(ctx)
	case emailsequencesend.FieldBounced:
		return m.OldBounced(ctx)
	case emailsequencesend.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case emailsequencesend.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailsequencesend.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailSequenceSend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSequenceSendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailsequencesend.FieldEnrollmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnrollmentID(v)
		return nil
	case emailsequencesend.FieldStepID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepID(v)
		return nil
	case emailsequencesend.FieldLeadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeadID(v)
		return nil
	case emailsequencesend.FieldStatus:
		v, ok := value.(emailsequencesend.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case emailsequencesend.FieldScheduledFor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledFor(v)
		return nil
	case emailsequencesend.FieldSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentAt(v)
		return nil
	case emailsequencesend.FieldOpenedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenedAt(v)
		return nil
	case emailsequencesend.FieldClickedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickedAt(v)
		return nil
	case emailsequencesend.FieldBounced:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBounced(v)
		return nil
	case emailsequencesend.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case emailsequencesend.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailsequencesend.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceSend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailSequenceSendMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailSequenceSendMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSequenceSendMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailSequenceSend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailSequenceSendMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailsequencesend.FieldSentAt) {
		fields = append(fields, emailsequencesend.FieldSentAt)
	}
	if m.FieldCleared(emailsequencesend.FieldOpenedAt) {
		fields = append(fields, emailsequencesend.FieldOpenedAt)
	}
	if m.FieldCleared(emailsequencesend.FieldClickedAt) {
		fields = append(fields, emailsequencesend.FieldClickedAt)
	}
	if m.FieldCleared(emailsequencesend.FieldErrorMessage) {
		fields = append(fields, emailsequencesend.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailSequenceSendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailSequenceSendMutation) ClearField(name string) error {
	switch name {
	case emailsequencesend.FieldSentAt:
		m.ClearSentAt()
		return nil
	case emailsequencesend.FieldOpenedAt:
		m.ClearOpenedAt()
		return nil
	case emailsequencesend.FieldClickedAt:
		m.ClearClickedAt()
		return nil
	case emailsequencesend.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceSend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailSequenceSendMutation) ResetField(name string) error {
	switch name {
	case emailsequencesend.FieldEnrollmentID:
		m.ResetEnrollmentID()
		return nil
	case emailsequencesend.FieldStepID:
		m.ResetStepID()
		return nil
	case emailsequencesend.FieldLeadID:
		m.ResetLeadID()
		return nil
	case emailsequencesend.FieldStatus:
		m.ResetStatus()
		return nil
	case emailsequencesend.FieldScheduledFor:
		m.ResetScheduledFor()
		return nil
	case emailsequencesend.FieldSentAt:
		m.ResetSentAt()
		return nil
	case emailsequencesend.FieldOpenedAt:
		m.ResetOpenedAt()
		return nil
	case emailsequencesend.FieldClickedAt:
		m.ResetClickedAt()
		return nil
	case emailsequencesend.FieldBounced:
		m.ResetBounced()
		return nil
	case emailsequencesend.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case emailsequencesend.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailsequencesend.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceSend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailSequenceSendMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.enrollment != nil {
		edges = append(edges, emailsequencesend.EdgeEnrollment)
	}
	if m.step != nil {
		edges = append(edges, emailsequencesend.EdgeStep)
	}
	if m.lead != nil {
		edges = append(edges, emailsequencesend.EdgeLead)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailSequenceSendMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailsequencesend.EdgeEnrollment:
		if id := m.enrollment; id != nil {
			return []ent.Value{*id}
		}
	case emailsequencesend.EdgeStep:
		if id := m.step; id != nil {
			return []ent.Value{*id}
		}
	case emailsequencesend.EdgeLead:
		if id := m.lead; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailSequenceSendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailSequenceSendMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailSequenceSendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedenrollment {
		edges = append(edges, emailsequencesend.EdgeEnrollment)
	}
	if m.clearedstep {
		edges = append(edges, emailsequencesend.EdgeStep)
	}
	if m.clearedlead {
		edges = append(edges, emailsequencesend.EdgeLead)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailSequenceSendMutation) EdgeCleared(name string) bool {
	switch name {
	case emailsequencesend.EdgeEnrollment:
		return m.clearedenrollment
	case emailsequencesend.EdgeStep:
		return m.clearedstep
	case emailsequencesend.EdgeLead:
		return m.clearedlead
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailSequenceSendMutation) ClearEdge(name string) error {
	switch name {
	case emailsequencesend.EdgeEnrollment:
		m.ClearEnrollment()
		return nil
	case emailsequencesend.EdgeStep:
		m.ClearStep()
		return nil
	case emailsequencesend.EdgeLead:
		m.ClearLead()
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceSend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailSequenceSendMutation) ResetEdge(name string) error {
	switch name {
	case emailsequencesend.EdgeEnrollment:
		m.ResetEnrollment()
		return nil
	case emailsequencesend.EdgeStep:
		m.ResetStep()
		return nil
	case emailsequencesend.EdgeLead:
		m.ResetLead()
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceSend edge %s", name)
}

// EmailSequenceStepMutation represents an operation that mutates the EmailSequenceStep nodes in the graph.
type EmailSequenceStepMutation struct {
	config
	op              Op
	typ             string
	id              *int
	step_order      *int
	addstep_order   *int
	delay_days      *int
	adddelay_days   *int
	subject         *string
	body            *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	sequence        *int
	clearedsequence bool
	sends           map[int]struct{}
	removedsends    map[int]struct{}
	clearedsends    bool
	done            bool
	oldValue        func(context.Context) (*EmailSequenceStep, error)
	predicates      []predicate.EmailSequenceStep
}

var _ ent.Mutation = (*EmailSequenceStepMutation)(nil)

// emailsequencestepOption allows management of the mutation configuration using functional options.
type emailsequencestepOption func(*EmailSequenceStepMutation)

// newEmailSequenceStepMutation creates new mutation for the EmailSequenceStep entity.
func newEmailSequenceStepMutation(c config, op Op, opts ...emailsequencestepOption) *EmailSequenceStepMutation {
	m := &EmailSequenceStepMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailSequenceStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailSequenceStepID sets the ID field of the mutation.
func withEmailSequenceStepID(id int) emailsequencestepOption {
	return func(m *EmailSequenceStepMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailSequenceStep
		)
		m.oldValue = func(ctx context.Context) (*EmailSequenceStep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailSequenceStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailSequenceStep sets the old EmailSequenceStep of the mutation.
func withEmailSequenceStep(node *EmailSequenceStep) emailsequencestepOption {
	return func(m *EmailSequenceStepMutation) {
		m.oldValue = func(context.Context) (*EmailSequenceStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailSequenceStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailSequenceStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailSequenceStepMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailSequenceStepMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailSequenceStep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSequenceID sets the "sequence_id" field.
func (m *EmailSequenceStepMutation) SetSequenceID(i int) {
	m.sequence = &i
}

// SequenceID returns the value of the "sequence_id" field in the mutation.
func (m *EmailSequenceStepMutation) SequenceID() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceID returns the old "sequence_id" field's value of the EmailSequenceStep entity.
// If the EmailSequenceStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceStepMutation) OldSequenceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceID: %w", err)
	}
	return oldValue.SequenceID, nil
}

// ResetSequenceID resets all changes to the "sequence_id" field.
func (m *EmailSequenceStepMutation) ResetSequenceID() {
	m.sequence = nil
}

// SetStepOrder sets the "step_order" field.
func (m *EmailSequenceStepMutation) SetStepOrder(i int) {
	m.step_order = &i
	m.addstep_order = nil
}

// StepOrder returns the value of the "step_order" field in the mutation.
func (m *EmailSequenceStepMutation) StepOrder() (r int, exists bool) {
	v := m.step_order
	if v == nil {
		return
	}
	return *v, true
}

// OldStepOrder returns the old "step_order" field's value of the EmailSequenceStep entity.
// If the EmailSequenceStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceStepMutation) OldStepOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepOrder: %w", err)
	}
	return oldValue.StepOrder, nil
}

// AddStepOrder adds i to the "step_order" field.
func (m *EmailSequenceStepMutation) AddStepOrder(i int) {
	if m.addstep_order != nil {
		*m.addstep_order += i
	} else {
		m.addstep_order = &i
	}
}

// AddedStepOrder returns the value that was added to the "step_order" field in this mutation.
func (m *EmailSequenceStepMutation) AddedStepOrder() (r int, exists bool) {
	v := m.addstep_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetStepOrder resets all changes to the "step_order" field.
func (m *EmailSequenceStepMutation) ResetStepOrder() {
	m.step_order = nil
	m.addstep_order = nil
}

// SetDelayDays sets the "delay_days" field.
func (m *EmailSequenceStepMutation) SetDelayDays(i int) {
	m.delay_days = &i
	m.adddelay_days = nil
}

// DelayDays returns the value of the "delay_days" field in the mutation.
func (m *EmailSequenceStepMutation) DelayDays() (r int, exists bool) {
	v := m.delay_days
	if v == nil {
		return
	}
	return *v, true
}

// OldDelayDays returns the old "delay_days" field's value of the EmailSequenceStep entity.
// If the EmailSequenceStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceStepMutation) OldDelayDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelayDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelayDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelayDays: %w", err)
	}
	return oldValue.DelayDays, nil
}

// AddDelayDays adds i to the "delay_days" field.
func (m *EmailSequenceStepMutation) AddDelayDays(i int) {
	if m.adddelay_days != nil {
		*m.adddelay_days += i
	} else {
		m.adddelay_days = &i
	}
}

// AddedDelayDays returns the value that was added to the "delay_days" field in this mutation.
func (m *EmailSequenceStepMutation) AddedDelayDays() (r int, exists bool) {
	v := m.adddelay_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetDelayDays resets all changes to the "delay_days" field.
func (m *EmailSequenceStepMutation) ResetDelayDays() {
	m.delay_days = nil
	m.adddelay_days = nil
}

// SetSubject sets the "subject" field.
func (m *EmailSequenceStepMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *EmailSequenceStepMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the EmailSequenceStep entity.
// If the EmailSequenceStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceStepMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *EmailSequenceStepMutation) ResetSubject() {
	m.subject = nil
}

// SetBody sets the "body" field.
func (m *EmailSequenceStepMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *EmailSequenceStepMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the EmailSequenceStep entity.
// If the EmailSequenceStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceStepMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *EmailSequenceStepMutation) ResetBody() {
	m.body = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailSequenceStepMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailSequenceStepMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailSequenceStep entity.
// If the EmailSequenceStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailSequenceStepMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailSequenceStepMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearSequence clears the "sequence" edge to the EmailSequence entity.
func (m *EmailSequenceStepMutation) ClearSequence() {
	m.clearedsequence = true
	m.clearedFields[emailsequencestep.FieldSequenceID] = struct{}{}
}

// SequenceCleared reports if the "sequence" edge to the EmailSequence entity was cleared.
func (m *EmailSequenceStepMutation) SequenceCleared() bool {
	return m.clearedsequence
}

// SequenceIDs returns the "sequence" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SequenceID instead. It exists only for internal usage by the builders.
func (m *EmailSequenceStepMutation) SequenceIDs() (ids []int) {
	if id := m.sequence; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSequence resets all changes to the "sequence" edge.
func (m *EmailSequenceStepMutation) ResetSequence() {
	m.sequence = nil
	m.clearedsequence = false
}

// AddSendIDs adds the "sends" edge to the EmailSequenceSend entity by ids.
func (m *EmailSequenceStepMutation) AddSendIDs(ids ...int) {
	if m.sends == nil {
		m.sends = make(map[int]struct{})
	}
	for i := range ids {
		m.sends[ids[i]] = struct{}{}
	}
}

// ClearSends clears the "sends" edge to the EmailSequenceSend entity.
func (m *EmailSequenceStepMutation) ClearSends() {
	m.clearedsends = true
}

// SendsCleared reports if the "sends" edge to the EmailSequenceSend entity was cleared.
func (m *EmailSequenceStepMutation) SendsCleared() bool {
	return m.clearedsends
}

// RemoveSendIDs removes the "sends" edge to the EmailSequenceSend entity by IDs.
func (m *EmailSequenceStepMutation) RemoveSendIDs(ids ...int) {
	if m.removedsends == nil {
		m.removedsends = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sends, ids[i])
		m.removedsends[ids[i]] = struct{}{}
	}
}

// RemovedSends returns the removed IDs of the "sends" edge to the EmailSequenceSend entity.
func (m *EmailSequenceStepMutation) RemovedSendsIDs() (ids []int) {
	for id := range m.removedsends {
		ids = append(ids, id)
	}
	return
}

// SendsIDs returns the "sends" edge IDs in the mutation.
func (m *EmailSequenceStepMutation) SendsIDs() (ids []int) {
	for id := range m.sends {
		ids = append(ids, id)
	}
	return
}

// ResetSends resets all changes to the "sends" edge.
func (m *EmailSequenceStepMutation) ResetSends() {
	m.sends = nil
	m.clearedsends = false
	m.removedsends = nil
}

// Where appends a list predicates to the EmailSequenceStepMutation builder.
func (m *EmailSequenceStepMutation) Where(ps ...predicate.EmailSequenceStep) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailSequenceStepMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailSequenceStepMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailSequenceStep, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailSequenceStepMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailSequenceStepMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailSequenceStep).
func (m *EmailSequenceStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailSequenceStepMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.sequence != nil {
		fields = append(fields, emailsequencestep.FieldSequenceID)
	}
	if m.step_order != nil {
		fields = append(fields, emailsequencestep.FieldStepOrder)
	}
	if m.delay_days != nil {
		fields = append(fields, emailsequencestep.FieldDelayDays)
	}
	if m.subject != nil {
		fields = append(fields, emailsequencestep.FieldSubject)
	}
	if m.body != nil {
		fields = append(fields, emailsequencestep.FieldBody)
	}
	if m.created_at != nil {
		fields = append(fields, emailsequencestep.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailSequenceStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailsequencestep.FieldSequenceID:
		return m.SequenceID()
	case emailsequencestep.FieldStepOrder:
		return m.StepOrder()
	case emailsequencestep.FieldDelayDays:
		return m.DelayDays()
	case emailsequencestep.FieldSubject:
		return m.Subject()
	case emailsequencestep.FieldBody:
		return m.Body()
	case emailsequencestep.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailSequenceStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailsequencestep.FieldSequenceID:
		return m.OldSequenceID(ctx)
	case emailsequencestep.FieldStepOrder:
		return m.OldStepOrder(ctx)
	case emailsequencestep.FieldDelayDays:
		return m.OldDelayDays(ctx)
	case emailsequencestep.FieldSubject:
		return m.OldSubject(ctx)
	case emailsequencestep.FieldBody:
		return m.OldBody(ctx)
	case emailsequencestep.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailSequenceStep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSequenceStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailsequencestep.FieldSequenceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceID(v)
		return nil
	case emailsequencestep.FieldStepOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepOrder(v)
		return nil
	case emailsequencestep.FieldDelayDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelayDays(v)
		return nil
	case emailsequencestep.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case emailsequencestep.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case emailsequencestep.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailSequenceStepMutation) AddedFields() []string {
	var fields []string
	if m.addstep_order != nil {
		fields = append(fields, emailsequencestep.FieldStepOrder)
	}
	if m.adddelay_days != nil {
		fields = append(fields, emailsequencestep.FieldDelayDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailSequenceStepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case emailsequencestep.FieldStepOrder:
		return m.AddedStepOrder()
	case emailsequencestep.FieldDelayDays:
		return m.AddedDelayDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailSequenceStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case emailsequencestep.FieldStepOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStepOrder(v)
		return nil
	case emailsequencestep.FieldDelayDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelayDays(v)
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailSequenceStepMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailSequenceStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailSequenceStepMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EmailSequenceStep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailSequenceStepMutation) ResetField(name string) error {
	switch name {
	case emailsequencestep.FieldSequenceID:
		m.ResetSequenceID()
		return nil
	case emailsequencestep.FieldStepOrder:
		m.ResetStepOrder()
		return nil
	case emailsequencestep.FieldDelayDays:
		m.ResetDelayDays()
		return nil
	case emailsequencestep.FieldSubject:
		m.ResetSubject()
		return nil
	case emailsequencestep.FieldBody:
		m.ResetBody()
		return nil
	case emailsequencestep.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailSequenceStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sequence != nil {
		edges = append(edges, emailsequencestep.EdgeSequence)
	}
	if m.sends != nil {
		edges = append(edges, emailsequencestep.EdgeSends)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailSequenceStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailsequencestep.EdgeSequence:
		if id := m.sequence; id != nil {
			return []ent.Value{*id}
		}
	case emailsequencestep.EdgeSends:
		ids := make([]ent.Value, 0, len(m.sends))
		for id := range m.sends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailSequenceStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsends != nil {
		edges = append(edges, emailsequencestep.EdgeSends)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailSequenceStepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case emailsequencestep.EdgeSends:
		ids := make([]ent.Value, 0, len(m.removedsends))
		for id := range m.removedsends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailSequenceStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsequence {
		edges = append(edges, emailsequencestep.EdgeSequence)
	}
	if m.clearedsends {
		edges = append(edges, emailsequencestep.EdgeSends)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailSequenceStepMutation) EdgeCleared(name string) bool {
	switch name {
	case emailsequencestep.EdgeSequence:
		return m.clearedsequence
	case emailsequencestep.EdgeSends:
		return m.clearedsends
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailSequenceStepMutation) ClearEdge(name string) error {
	switch name {
	case emailsequencestep.EdgeSequence:
		m.ClearSequence()
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceStep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailSequenceStepMutation) ResetEdge(name string) error {
	switch name {
	case emailsequencestep.EdgeSequence:
		m.ResetSequence()
		return nil
	case emailsequencestep.EdgeSends:
		m.ResetSends()
		return nil
	}
	return fmt.Errorf("unknown EmailSequenceStep edge %s", name)
}

// ExportMutation represents an operation that mutates the Export nodes in the graph.
type ExportMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	format              *export.Format
	filters_applied     *map[string]interface{}
	lead_count          *int
	addlead_count       *int
	file_url            *string
	file_path           *string
	status              *export.Status
	error_message       *string
	expires_at          *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	user                *int
	cleareduser         bool
	organization        *int
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*Export, error)
	predicates          []predicate.Export
}

var _ ent.Mutation = (*ExportMutation)(nil)

// exportOption allows management of the mutation configuration using functional options.
type exportOption func(*ExportMutation)

// newExportMutation creates new mutation for the Export entity.
func newExportMutation(c config, op Op, opts ...exportOption) *ExportMutation {
	m := &ExportMutation{
		config:        c,
		op:            op,
		typ:           TypeExport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExportID sets the ID field of the mutation.
func withExportID(id int) exportOption {
	return func(m *ExportMutation) {
		var (
			err   error
			once  sync.Once
			value *Export
		)
		m.oldValue = func(ctx context.Context) (*Export, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Export.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExport sets the old Export of the mutation.
func withExport(node *Export) exportOption {
	return func(m *ExportMutation) {
		m.oldValue = func(context.Context) (*Export, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Export.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ExportMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ExportMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ExportMutation) ResetUserID() {
	m.user = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ExportMutation) SetOrganizationID(i int) {
	m.organization = &i
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ExportMutation) OrganizationID() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldOrganizationID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *ExportMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[export.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *ExportMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[export.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ExportMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, export.FieldOrganizationID)
}

// SetFormat sets the "format" field.
func (m *ExportMutation) SetFormat(e export.Format) {
	m.format = &e
}

// Format returns the value of the "format" field in the mutation.
func (m *ExportMutation) Format() (r export.Format, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldFormat(ctx context.Context) (v export.Format, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *ExportMutation) ResetFormat() {
	m.format = nil
}

// SetFiltersApplied sets the "filters_applied" field.
func (m *ExportMutation) SetFiltersApplied(value map[string]interface{}) {
	m.filters_applied = &value
}

// FiltersApplied returns the value of the "filters_applied" field in the mutation.
func (m *ExportMutation) FiltersApplied() (r map[string]interface{}, exists bool) {
	v := m.filters_applied
	if v == nil {
		return
	}
	return *v, true
}

// OldFiltersApplied returns the old "filters_applied" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldFiltersApplied(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiltersApplied is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiltersApplied requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiltersApplied: %w", err)
	}
	return oldValue.FiltersApplied, nil
}

// ClearFiltersApplied clears the value of the "filters_applied" field.
func (m *ExportMutation) ClearFiltersApplied() {
	m.filters_applied = nil
	m.clearedFields[export.FieldFiltersApplied] = struct{}{}
}

// FiltersAppliedCleared returns if the "filters_applied" field was cleared in this mutation.
func (m *ExportMutation) FiltersAppliedCleared() bool {
	_, ok := m.clearedFields[export.FieldFiltersApplied]
	return ok
}

// ResetFiltersApplied resets all changes to the "filters_applied" field.
func (m *ExportMutation) ResetFiltersApplied() {
	m.filters_applied = nil
	delete(m.clearedFields, export.FieldFiltersApplied)
}

// SetLeadCount sets the "lead_count" field.
func (m *ExportMutation) SetLeadCount(i int) {
	m.lead_count = &i
	m.addlead_count = nil
}

// LeadCount returns the value of the "lead_count" field in the mutation.
func (m *ExportMutation) LeadCount() (r int, exists bool) {
	v := m.lead_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLeadCount returns the old "lead_count" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldLeadCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeadCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeadCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeadCount: %w", err)
	}
	return oldValue.LeadCount, nil
}

// AddLeadCount adds i to the "lead_count" field.
func (m *ExportMutation) AddLeadCount(i int) {
	if m.addlead_count != nil {
		*m.addlead_count += i
	} else {
		m.addlead_count = &i
	}
}

// AddedLeadCount returns the value that was added to the "lead_count" field in this mutation.
func (m *ExportMutation) AddedLeadCount() (r int, exists bool) {
	v := m.addlead_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLeadCount resets all changes to the "lead_count" field.
func (m *ExportMutation) ResetLeadCount() {
	m.lead_count = nil
	m.addlead_count = nil
}

// SetFileURL sets the "file_url" field.
func (m *ExportMutation) SetFileURL(s string) {
	m.file_url = &s
}

// FileURL returns the value of the "file_url" field in the mutation.
func (m *ExportMutation) FileURL() (r string, exists bool) {
	v := m.file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFileURL returns the old "file_url" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileURL: %w", err)
	}
	return oldValue.FileURL, nil
}

// ClearFileURL clears the value of the "file_url" field.
func (m *ExportMutation) ClearFileURL() {
	m.file_url = nil
	m.clearedFields[export.FieldFileURL] = struct{}{}
}

// FileURLCleared returns if the "file_url" field was cleared in this mutation.
func (m *ExportMutation) FileURLCleared() bool {
	_, ok := m.clearedFields[export.FieldFileURL]
	return ok
}

// ResetFileURL resets all changes to the "file_url" field.
func (m *ExportMutation) ResetFileURL() {
	m.file_url = nil
	delete(m.clearedFields, export.FieldFileURL)
}

// SetFilePath sets the "file_path" field.
func (m *ExportMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *ExportMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ClearFilePath clears the value of the "file_path" field.
func (m *ExportMutation) ClearFilePath() {
	m.file_path = nil
	m.clearedFields[export.FieldFilePath] = struct{}{}
}

// FilePathCleared returns if the "file_path" field was cleared in this mutation.
func (m *ExportMutation) FilePathCleared() bool {
	_, ok := m.clearedFields[export.FieldFilePath]
	return ok
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *ExportMutation) ResetFilePath() {
	m.file_path = nil
	delete(m.clearedFields, export.FieldFilePath)
}

// SetStatus sets the "status" field.
func (m *ExportMutation) SetStatus(e export.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *ExportMutation) Status() (r export.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldStatus(ctx context.Context) (v export.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ExportMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *ExportMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ExportMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ExportMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[export.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ExportMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[export.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ExportMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, export.FieldErrorMessage)
}

// SetExpiresAt sets the "expires_at" field.
func (m *ExportMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ExportMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ExportMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[export.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ExportMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[export.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ExportMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, export.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ExportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ExportMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[export.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ExportMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ExportMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ExportMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ExportMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[export.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ExportMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ExportMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ExportMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ExportMutation builder.
func (m *ExportMutation) Where(ps ...predicate.Export) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Export, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Export).
func (m *ExportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExportMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, export.FieldUserID)
	}
	if m.organization != nil {
		fields = append(fields, export.FieldOrganizationID)
	}
	if m.format != nil {
		fields = append(fields, export.FieldFormat)
	}
	if m.filters_applied != nil {
		fields = append(fields, export.FieldFiltersApplied)
	}
	if m.lead_count != nil {
		fields = append(fields, export.FieldLeadCount)
	}
	if m.file_url != nil {
		fields = append(fields, export.FieldFileURL)
	}
	if m.file_path != nil {
		fields = append(fields, export.FieldFilePath)
	}
	if m.status != nil {
		fields = append(fields, export.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, export.FieldErrorMessage)
	}
	if m.expires_at != nil {
		fields = append(fields, export.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, export.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, export.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case export.FieldUserID:
		return m.UserID()
	case export.FieldOrganizationID:
		return m.OrganizationID()
	case export.FieldFormat:
		return m.Format()
	case export.FieldFiltersApplied:
		return m.FiltersApplied()
	case export.FieldLeadCount:
		return m.LeadCount()
	case export.FieldFileURL:
		return m.FileURL()
	case export.FieldFilePath:
		return m.FilePath()
	case export.FieldStatus:
		return m.Status()
	case export.FieldErrorMessage:
		return m.ErrorMessage()
	case export.FieldExpiresAt:
		return m.ExpiresAt()
	case export.FieldCreatedAt:
		return m.CreatedAt()
	case export.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case export.FieldUserID:
		return m.OldUserID(ctx)
	case export.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case export.FieldFormat:
		return m.OldFormat(ctx)
	case export.FieldFiltersApplied:
		return m.OldFiltersApplied(ctx)
	case export.FieldLeadCount:
		return m.OldLeadCount(ctx)
	case export.FieldFileURL:
		return m.OldFileURL(ctx)
	case export.FieldFilePath:
		return m.OldFilePath(ctx)
	case export.FieldStatus:
		return m.OldStatus(ctx)
	case export.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case export.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case export.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case export.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Export field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case export.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case export.FieldOrganizationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case export.FieldFormat:
		v, ok := value.(export.Format)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case export.FieldFiltersApplied:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiltersApplied(v)
		return nil
	case export.FieldLeadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeadCount(v)
		return nil
	case export.FieldFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileURL(v)
		return nil
	case export.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case export.FieldStatus:
		v, ok := value.(export.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case export.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case export.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case export.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case export.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Export field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExportMutation) AddedFields() []string {
	var fields []string
	if m.addlead_count != nil {
		fields = append(fields, export.FieldLeadCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case export.FieldLeadCount:
		return m.AddedLeadCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case export.FieldLeadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeadCount(v)
		return nil
	}
	return fmt.Errorf("unknown Export numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(export.FieldOrganizationID) {
		fields = append(fields, export.FieldOrganizationID)
	}
	if m.FieldCleared(export.FieldFiltersApplied) {
		fields = append(fields, export.FieldFiltersApplied)
	}
	if m.FieldCleared(export.FieldFileURL) {
		fields = append(fields, export.FieldFileURL)
	}
	if m.FieldCleared(export.FieldFilePath) {
		fields = append(fields, export.FieldFilePath)
	}
	if m.FieldCleared(export.FieldErrorMessage) {
		fields = append(fields, export.FieldErrorMessage)
	}
	if m.FieldCleared(export.FieldExpiresAt) {
		fields = append(fields, export.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExportMutation) ClearField(name string) error {
	switch name {
	case export.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case export.FieldFiltersApplied:
		m.ClearFiltersApplied()
		return nil
	case export.FieldFileURL:
		m.ClearFileURL()
		return nil
	case export.FieldFilePath:
		m.ClearFilePath()
		return nil
	case export.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case export.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Export nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExportMutation) ResetField(name string) error {
	switch name {
	case export.FieldUserID:
		m.ResetUserID()
		return nil
	case export.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case export.FieldFormat:
		m.ResetFormat()
		return nil
	case export.FieldFiltersApplied:
		m.ResetFiltersApplied()
		return nil
	case export.FieldLeadCount:
		m.ResetLeadCount()
		return nil
	case export.FieldFileURL:
		m.ResetFileURL()
		return nil
	case export.FieldFilePath:
		m.ResetFilePath()
		return nil
	case export.FieldStatus:
		m.ResetStatus()
		return nil
	case export.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case export.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case export.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case export.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Export field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, export.EdgeUser)
	}
	if m.organization != nil {
		edges = append(edges, export.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case export.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case export.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, export.EdgeUser)
	}
	if m.clearedorganization {
		edges = append(edges, export.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExportMutation) EdgeCleared(name string) bool {
	switch name {
	case export.EdgeUser:
		return m.cleareduser
	case export.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExportMutation) ClearEdge(name string) error {
	switch name {
	case export.EdgeUser:
		m.ClearUser()
		return nil
	case export.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Export unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExportMutation) ResetEdge(name string) error {
	switch name {
	case export.EdgeUser:
		m.ResetUser()
		return nil
	case export.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown Export edge %s", name)
}

// IndustryMutation represents an operation that mutates the Industry nodes in the graph.
type IndustryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	name                      *string
	category                  *string
	icon                      *string
	osm_primary_tag           *string
	osm_additional_tags       *[]string
	appendosm_additional_tags []string
	description               *string
	active                    *bool
	sort_order                *int
	addsort_order             *int
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Industry, error)
	predicates                []predicate.Industry
}

var _ ent.Mutation = (*IndustryMutation)(nil)

// industryOption allows management of the mutation configuration using functional options.
type industryOption func(*IndustryMutation)

// newIndustryMutation creates new mutation for the Industry entity.
func newIndustryMutation(c config, op Op, opts ...industryOption) *IndustryMutation {
	m := &IndustryMutation{
		config:        c,
		op:            op,
		typ:           TypeIndustry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIndustryID sets the ID field of the mutation.
func withIndustryID(id string) industryOption {
	return func(m *IndustryMutation) {
		var (
			err   error
			once  sync.Once
			value *Industry
		)
		m.oldValue = func(ctx context.Context) (*Industry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Industry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIndustry sets the old Industry of the mutation.
func withIndustry(node *Industry) industryOption {
	return func(m *IndustryMutation) {
		m.oldValue = func(context.Context) (*Industry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IndustryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IndustryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Industry entities.
func (m *IndustryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IndustryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IndustryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Industry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IndustryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IndustryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IndustryMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *IndustryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *IndustryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *IndustryMutation) ResetCategory() {
	m.category = nil
}

// SetIcon sets the "icon" field.
func (m *IndustryMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *IndustryMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *IndustryMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[industry.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *IndustryMutation) IconCleared() bool {
	_, ok := m.clearedFields[industry.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *IndustryMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, industry.FieldIcon)
}

// SetOsmPrimaryTag sets the "osm_primary_tag" field.
func (m *IndustryMutation) SetOsmPrimaryTag(s string) {
	m.osm_primary_tag = &s
}

// OsmPrimaryTag returns the value of the "osm_primary_tag" field in the mutation.
func (m *IndustryMutation) OsmPrimaryTag() (r string, exists bool) {
	v := m.osm_primary_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldOsmPrimaryTag returns the old "osm_primary_tag" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldOsmPrimaryTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsmPrimaryTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsmPrimaryTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsmPrimaryTag: %w", err)
	}
	return oldValue.OsmPrimaryTag, nil
}

// ResetOsmPrimaryTag resets all changes to the "osm_primary_tag" field.
func (m *IndustryMutation) ResetOsmPrimaryTag() {
	m.osm_primary_tag = nil
}

// SetOsmAdditionalTags sets the "osm_additional_tags" field.
func (m *IndustryMutation) SetOsmAdditionalTags(s []string) {
	m.osm_additional_tags = &s
	m.appendosm_additional_tags = nil
}

// OsmAdditionalTags returns the value of the "osm_additional_tags" field in the mutation.
func (m *IndustryMutation) OsmAdditionalTags() (r []string, exists bool) {
	v := m.osm_additional_tags
	if v == nil {
		return
	}
	return *v, true
}

// OldOsmAdditionalTags returns the old "osm_additional_tags" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldOsmAdditionalTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsmAdditionalTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsmAdditionalTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsmAdditionalTags: %w", err)
	}
	return oldValue.OsmAdditionalTags, nil
}

// AppendOsmAdditionalTags adds s to the "osm_additional_tags" field.
func (m *IndustryMutation) AppendOsmAdditionalTags(s []string) {
	m.appendosm_additional_tags = append(m.appendosm_additional_tags, s...)
}

// AppendedOsmAdditionalTags returns the list of values that were appended to the "osm_additional_tags" field in this mutation.
func (m *IndustryMutation) AppendedOsmAdditionalTags() ([]string, bool) {
	if len(m.appendosm_additional_tags) == 0 {
		return nil, false
	}
	return m.appendosm_additional_tags, true
}

// ClearOsmAdditionalTags clears the value of the "osm_additional_tags" field.
func (m *IndustryMutation) ClearOsmAdditionalTags() {
	m.osm_additional_tags = nil
	m.appendosm_additional_tags = nil
	m.clearedFields[industry.FieldOsmAdditionalTags] = struct{}{}
}

// OsmAdditionalTagsCleared returns if the "osm_additional_tags" field was cleared in this mutation.
func (m *IndustryMutation) OsmAdditionalTagsCleared() bool {
	_, ok := m.clearedFields[industry.FieldOsmAdditionalTags]
	return ok
}

// ResetOsmAdditionalTags resets all changes to the "osm_additional_tags" field.
func (m *IndustryMutation) ResetOsmAdditionalTags() {
	m.osm_additional_tags = nil
	m.appendosm_additional_tags = nil
	delete(m.clearedFields, industry.FieldOsmAdditionalTags)
}

// SetDescription sets the "description" field.
func (m *IndustryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IndustryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IndustryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[industry.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IndustryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[industry.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IndustryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, industry.FieldDescription)
}

// SetActive sets the "active" field.
func (m *IndustryMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *IndustryMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *IndustryMutation) ResetActive() {
	m.active = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *IndustryMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *IndustryMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *IndustryMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *IndustryMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *IndustryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IndustryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IndustryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IndustryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IndustryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IndustryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IndustryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the IndustryMutation builder.
func (m *IndustryMutation) Where(ps ...predicate.Industry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IndustryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IndustryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Industry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IndustryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IndustryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Industry).
func (m *IndustryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IndustryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, industry.FieldName)
	}
	if m.category != nil {
		fields = append(fields, industry.FieldCategory)
	}
	if m.icon != nil {
		fields = append(fields, industry.FieldIcon)
	}
	if m.osm_primary_tag != nil {
		fields = append(fields, industry.FieldOsmPrimaryTag)
	}
	if m.osm_additional_tags != nil {
		fields = append(fields, industry.FieldOsmAdditionalTags)
	}
	if m.description != nil {
		fields = append(fields, industry.FieldDescription)
	}
	if m.active != nil {
		fields = append(fields, industry.FieldActive)
	}
	if m.sort_order != nil {
		fields = append(fields, industry.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, industry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, industry.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IndustryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case industry.FieldName:
		return m.Name()
	case industry.FieldCategory:
		return m.Category()
	case industry.FieldIcon:
		return m.Icon()
	case industry.FieldOsmPrimaryTag:
		return m.OsmPrimaryTag()
	case industry.FieldOsmAdditionalTags:
		return m.OsmAdditionalTags()
	case industry.FieldDescription:
		return m.Description()
	case industry.FieldActive:
		return m.Active()
	case industry.FieldSortOrder:
		return m.SortOrder()
	case industry.FieldCreatedAt:
		return m.CreatedAt()
	case industry.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IndustryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case industry.FieldName:
		return m.OldName(ctx)
	case industry.FieldCategory:
		return m.OldCategory(ctx)
	case industry.FieldIcon:
		return m.OldIcon(ctx)
	case industry.FieldOsmPrimaryTag:
		return m.OldOsmPrimaryTag(ctx)
	case industry.FieldOsmAdditionalTags:
		return m.OldOsmAdditionalTags(ctx)
	case industry.FieldDescription:
		return m.OldDescription(ctx)
	case industry.FieldActive:
		return m.OldActive(ctx)
	case industry.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case industry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case industry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Industry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndustryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case industry.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case industry.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case industry.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case industry.FieldOsmPrimaryTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsmPrimaryTag(v)
		return nil
	case industry.FieldOsmAdditionalTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsmAdditionalTags(v)
		return nil
	case industry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case industry.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case industry.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case industry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case industry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Industry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IndustryMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, industry.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IndustryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case industry.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndustryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case industry.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Industry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IndustryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(industry.FieldIcon) {
		fields = append(fields, industry.FieldIcon)
	}
	if m.FieldCleared(industry.FieldOsmAdditionalTags) {
		fields = append(fields, industry.FieldOsmAdditionalTags)
	}
	if m.FieldCleared(industry.FieldDescription) {
		fields = append(fields, industry.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IndustryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IndustryMutation) ClearField(name string) error {
	switch name {
	case industry.FieldIcon:
		m.ClearIcon()
		return nil
	case industry.FieldOsmAdditionalTags:
		m.ClearOsmAdditionalTags()
		return nil
	case industry.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Industry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IndustryMutation) ResetField(name string) error {
	switch name {
	case industry.FieldName:
		m.ResetName()
		return nil
	case industry.FieldCategory:
		m.ResetCategory()
		return nil
	case industry.FieldIcon:
		m.ResetIcon()
		return nil
	case industry.FieldOsmPrimaryTag:
		m.ResetOsmPrimaryTag()
		return nil
	case industry.FieldOsmAdditionalTags:
		m.ResetOsmAdditionalTags()
		return nil
	case industry.FieldDescription:
		m.ResetDescription()
		return nil
	case industry.FieldActive:
		m.ResetActive()
		return nil
	case industry.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case industry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case industry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Industry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IndustryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IndustryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IndustryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IndustryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IndustryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IndustryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IndustryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Industry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IndustryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Industry edge %s", name)
}

// LeadMutation represents an operation that mutates the Lead nodes in the graph.
type LeadMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	name                              *string
	industry                          *lead.Industry
	country                           *string
	city                              *string
	address                           *string
	postal_code                       *string
	phone                             *string
	email                             *string
	website                           *string
	social_media                      *map[string]string
	latitude                          *float64
	addlatitude                       *float64
	longitude                         *float64
	addlongitude                      *float64
	verified                          *bool
	quality_score                     *int
	addquality_score                  *int
	status                            *lead.Status
	status_changed_at                 *time.Time
	custom_fields                     *map[string]interface{}
	osm_id                            *string
	metadata                          *map[string]interface{}
	sub_niche                         *string
	specialties                       *[]string
	appendspecialties                 []string
	cuisine_type                      *string
	sport_type                        *string
	tattoo_style                      *string
	created_at                        *time.Time
	updated_at                        *time.Time
	clearedFields                     map[string]struct{}
	notes                             map[int]struct{}
	removednotes                      map[int]struct{}
	clearednotes                      bool
	status_history                    map[int]struct{}
	removedstatus_history             map[int]struct{}
	clearedstatus_history             bool
	assignments                       map[int]struct{}
	removedassignments                map[int]struct{}
	clearedassignments                bool
	email_sequence_enrollments        map[int]struct{}
	removedemail_sequence_enrollments map[int]struct{}
	clearedemail_sequence_enrollments bool
	email_sequence_sends              map[int]struct{}
	removedemail_sequence_sends       map[int]struct{}
	clearedemail_sequence_sends       bool
	done                              bool
	oldValue                          func(context.Context) (*Lead, error)
	predicates                        []predicate.Lead
}

var _ ent.Mutation = (*LeadMutation)(nil)

// leadOption allows management of the mutation configuration using functional options.
type leadOption func(*LeadMutation)

// newLeadMutation creates new mutation for the Lead entity.
func newLeadMutation(c config, op Op, opts ...leadOption) *LeadMutation {
	m := &LeadMutation{
		config:        c,
		op:            op,
		typ:           TypeLead,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeadID sets the ID field of the mutation.
func withLeadID(id int) leadOption {
	return func(m *LeadMutation) {
		var (
			err   error
			once  sync.Once
			value *Lead
		)
		m.oldValue = func(ctx context.Context) (*Lead, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lead.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLead sets the old Lead of the mutation.
func withLead(node *Lead) leadOption {
	return func(m *LeadMutation) {
		m.oldValue = func(context.Context) (*Lead, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lead.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LeadMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LeadMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LeadMutation) ResetName() {
	m.name = nil
}

// SetIndustry sets the "industry" field.
func (m *LeadMutation) SetIndustry(l lead.Industry) {
	m.industry = &l
}

// Industry returns the value of the "industry" field in the mutation.
func (m *LeadMutation) Industry() (r lead.Industry, exists bool) {
	v := m.industry
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustry returns the old "industry" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldIndustry(ctx context.Context) (v lead.Industry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustry: %w", err)
	}
	return oldValue.Industry, nil
}

// ResetIndustry resets all changes to the "industry" field.
func (m *LeadMutation) ResetIndustry() {
	m.industry = nil
}

// SetCountry sets the "country" field.
func (m *LeadMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *LeadMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *LeadMutation) ResetCountry() {
	m.country = nil
}

// SetCity sets the "city" field.
func (m *LeadMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *LeadMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *LeadMutation) ResetCity() {
	m.city = nil
}

// SetAddress sets the "address" field.
func (m *LeadMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *LeadMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *LeadMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[lead.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *LeadMutation) AddressCleared() bool {
	_, ok := m.clearedFields[lead.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *LeadMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, lead.FieldAddress)
}

// SetPostalCode sets the "postal_code" field.
func (m *LeadMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *LeadMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *LeadMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[lead.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *LeadMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[lead.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *LeadMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, lead.FieldPostalCode)
}

// SetPhone sets the "phone" field.
func (m *LeadMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *LeadMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *LeadMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[lead.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *LeadMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[lead.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *LeadMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, lead.FieldPhone)
}

// SetEmail sets the "email" field.
func (m *LeadMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *LeadMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *LeadMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[lead.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *LeadMutation) EmailCleared() bool {
	_, ok := m.clearedFields[lead.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *LeadMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, lead.FieldEmail)
}

// SetWebsite sets the "website" field.
func (m *LeadMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *LeadMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *LeadMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[lead.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *LeadMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[lead.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *LeadMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, lead.FieldWebsite)
}

// SetSocialMedia sets the "social_media" field.
func (m *LeadMutation) SetSocialMedia(value map[string]string) {
	m.social_media = &value
}

// SocialMedia returns the value of the "social_media" field in the mutation.
func (m *LeadMutation) SocialMedia() (r map[string]string, exists bool) {
	v := m.social_media
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialMedia returns the old "social_media" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldSocialMedia(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialMedia is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialMedia requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialMedia: %w", err)
	}
	return oldValue.SocialMedia, nil
}

// ClearSocialMedia clears the value of the "social_media" field.
func (m *LeadMutation) ClearSocialMedia() {
	m.social_media = nil
	m.clearedFields[lead.FieldSocialMedia] = struct{}{}
}

// SocialMediaCleared returns if the "social_media" field was cleared in this mutation.
func (m *LeadMutation) SocialMediaCleared() bool {
	_, ok := m.clearedFields[lead.FieldSocialMedia]
	return ok
}

// ResetSocialMedia resets all changes to the "social_media" field.
func (m *LeadMutation) ResetSocialMedia() {
	m.social_media = nil
	delete(m.clearedFields, lead.FieldSocialMedia)
}

// SetLatitude sets the "latitude" field.
func (m *LeadMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *LeadMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *LeadMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *LeadMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *LeadMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[lead.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *LeadMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[lead.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *LeadMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, lead.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *LeadMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *LeadMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *LeadMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *LeadMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *LeadMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[lead.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *LeadMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[lead.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *LeadMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, lead.FieldLongitude)
}

// SetVerified sets the "verified" field.
func (m *LeadMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *LeadMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *LeadMutation) ResetVerified() {
	m.verified = nil
}

// SetQualityScore sets the "quality_score" field.
func (m *LeadMutation) SetQualityScore(i int) {
	m.quality_score = &i
	m.addquality_score = nil
}

// QualityScore returns the value of the "quality_score" field in the mutation.
func (m *LeadMutation) QualityScore() (r int, exists bool) {
	v := m.quality_score
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityScore returns the old "quality_score" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldQualityScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityScore: %w", err)
	}
	return oldValue.QualityScore, nil
}

// AddQualityScore adds i to the "quality_score" field.
func (m *LeadMutation) AddQualityScore(i int) {
	if m.addquality_score != nil {
		*m.addquality_score += i
	} else {
		m.addquality_score = &i
	}
}

// AddedQualityScore returns the value that was added to the "quality_score" field in this mutation.
func (m *LeadMutation) AddedQualityScore() (r int, exists bool) {
	v := m.addquality_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetQualityScore resets all changes to the "quality_score" field.
func (m *LeadMutation) ResetQualityScore() {
	m.quality_score = nil
	m.addquality_score = nil
}

// SetStatus sets the "status" field.
func (m *LeadMutation) SetStatus(l lead.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LeadMutation) Status() (r lead.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldStatus(ctx context.Context) (v lead.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LeadMutation) ResetStatus() {
	m.status = nil
}

// SetStatusChangedAt sets the "status_changed_at" field.
func (m *LeadMutation) SetStatusChangedAt(t time.Time) {
	m.status_changed_at = &t
}

// StatusChangedAt returns the value of the "status_changed_at" field in the mutation.
func (m *LeadMutation) StatusChangedAt() (r time.Time, exists bool) {
	v := m.status_changed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusChangedAt returns the old "status_changed_at" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldStatusChangedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusChangedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusChangedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusChangedAt: %w", err)
	}
	return oldValue.StatusChangedAt, nil
}

// ResetStatusChangedAt resets all changes to the "status_changed_at" field.
func (m *LeadMutation) ResetStatusChangedAt() {
	m.status_changed_at = nil
}

// SetCustomFields sets the "custom_fields" field.
func (m *LeadMutation) SetCustomFields(value map[string]interface{}) {
	m.custom_fields = &value
}

// CustomFields returns the value of the "custom_fields" field in the mutation.
func (m *LeadMutation) CustomFields() (r map[string]interface{}, exists bool) {
	v := m.custom_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomFields returns the old "custom_fields" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCustomFields(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomFields: %w", err)
	}
	return oldValue.CustomFields, nil
}

// ClearCustomFields clears the value of the "custom_fields" field.
func (m *LeadMutation) ClearCustomFields() {
	m.custom_fields = nil
	m.clearedFields[lead.FieldCustomFields] = struct{}{}
}

// CustomFieldsCleared returns if the "custom_fields" field was cleared in this mutation.
func (m *LeadMutation) CustomFieldsCleared() bool {
	_, ok := m.clearedFields[lead.FieldCustomFields]
	return ok
}

// ResetCustomFields resets all changes to the "custom_fields" field.
func (m *LeadMutation) ResetCustomFields() {
	m.custom_fields = nil
	delete(m.clearedFields, lead.FieldCustomFields)
}

// SetOsmID sets the "osm_id" field.
func (m *LeadMutation) SetOsmID(s string) {
	m.osm_id = &s
}

// OsmID returns the value of the "osm_id" field in the mutation.
func (m *LeadMutation) OsmID() (r string, exists bool) {
	v := m.osm_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOsmID returns the old "osm_id" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldOsmID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsmID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsmID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsmID: %w", err)
	}
	return oldValue.OsmID, nil
}

// ClearOsmID clears the value of the "osm_id" field.
func (m *LeadMutation) ClearOsmID() {
	m.osm_id = nil
	m.clearedFields[lead.FieldOsmID] = struct{}{}
}

// OsmIDCleared returns if the "osm_id" field was cleared in this mutation.
func (m *LeadMutation) OsmIDCleared() bool {
	_, ok := m.clearedFields[lead.FieldOsmID]
	return ok
}

// ResetOsmID resets all changes to the "osm_id" field.
func (m *LeadMutation) ResetOsmID() {
	m.osm_id = nil
	delete(m.clearedFields, lead.FieldOsmID)
}

// SetMetadata sets the "metadata" field.
func (m *LeadMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *LeadMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *LeadMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[lead.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *LeadMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[lead.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *LeadMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, lead.FieldMetadata)
}

// SetSubNiche sets the "sub_niche" field.
func (m *LeadMutation) SetSubNiche(s string) {
	m.sub_niche = &s
}

// SubNiche returns the value of the "sub_niche" field in the mutation.
func (m *LeadMutation) SubNiche() (r string, exists bool) {
	v := m.sub_niche
	if v == nil {
		return
	}
	return *v, true
}

// OldSubNiche returns the old "sub_niche" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldSubNiche(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubNiche is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubNiche requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubNiche: %w", err)
	}
	return oldValue.SubNiche, nil
}

// ClearSubNiche clears the value of the "sub_niche" field.
func (m *LeadMutation) ClearSubNiche() {
	m.sub_niche = nil
	m.clearedFields[lead.FieldSubNiche] = struct{}{}
}

// SubNicheCleared returns if the "sub_niche" field was cleared in this mutation.
func (m *LeadMutation) SubNicheCleared() bool {
	_, ok := m.clearedFields[lead.FieldSubNiche]
	return ok
}

// ResetSubNiche resets all changes to the "sub_niche" field.
func (m *LeadMutation) ResetSubNiche() {
	m.sub_niche = nil
	delete(m.clearedFields, lead.FieldSubNiche)
}

// SetSpecialties sets the "specialties" field.
func (m *LeadMutation) SetSpecialties(s []string) {
	m.specialties = &s
	m.appendspecialties = nil
}

// Specialties returns the value of the "specialties" field in the mutation.
func (m *LeadMutation) Specialties() (r []string, exists bool) {
	v := m.specialties
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialties returns the old "specialties" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldSpecialties(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecialties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecialties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialties: %w", err)
	}
	return oldValue.Specialties, nil
}

// AppendSpecialties adds s to the "specialties" field.
func (m *LeadMutation) AppendSpecialties(s []string) {
	m.appendspecialties = append(m.appendspecialties, s...)
}

// AppendedSpecialties returns the list of values that were appended to the "specialties" field in this mutation.
func (m *LeadMutation) AppendedSpecialties() ([]string, bool) {
	if len(m.appendspecialties) == 0 {
		return nil, false
	}
	return m.appendspecialties, true
}

// ClearSpecialties clears the value of the "specialties" field.
func (m *LeadMutation) ClearSpecialties() {
	m.specialties = nil
	m.appendspecialties = nil
	m.clearedFields[lead.FieldSpecialties] = struct{}{}
}

// SpecialtiesCleared returns if the "specialties" field was cleared in this mutation.
func (m *LeadMutation) SpecialtiesCleared() bool {
	_, ok := m.clearedFields[lead.FieldSpecialties]
	return ok
}

// ResetSpecialties resets all changes to the "specialties" field.
func (m *LeadMutation) ResetSpecialties() {
	m.specialties = nil
	m.appendspecialties = nil
	delete(m.clearedFields, lead.FieldSpecialties)
}

// SetCuisineType sets the "cuisine_type" field.
func (m *LeadMutation) SetCuisineType(s string) {
	m.cuisine_type = &s
}

// CuisineType returns the value of the "cuisine_type" field in the mutation.
func (m *LeadMutation) CuisineType() (r string, exists bool) {
	v := m.cuisine_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCuisineType returns the old "cuisine_type" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCuisineType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCuisineType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCuisineType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCuisineType: %w", err)
	}
	return oldValue.CuisineType, nil
}

// ClearCuisineType clears the value of the "cuisine_type" field.
func (m *LeadMutation) ClearCuisineType() {
	m.cuisine_type = nil
	m.clearedFields[lead.FieldCuisineType] = struct{}{}
}

// CuisineTypeCleared returns if the "cuisine_type" field was cleared in this mutation.
func (m *LeadMutation) CuisineTypeCleared() bool {
	_, ok := m.clearedFields[lead.FieldCuisineType]
	return ok
}

// ResetCuisineType resets all changes to the "cuisine_type" field.
func (m *LeadMutation) ResetCuisineType() {
	m.cuisine_type = nil
	delete(m.clearedFields, lead.FieldCuisineType)
}

// SetSportType sets the "sport_type" field.
func (m *LeadMutation) SetSportType(s string) {
	m.sport_type = &s
}

// SportType returns the value of the "sport_type" field in the mutation.
func (m *LeadMutation) SportType() (r string, exists bool) {
	v := m.sport_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSportType returns the old "sport_type" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldSportType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSportType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSportType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSportType: %w", err)
	}
	return oldValue.SportType, nil
}

// ClearSportType clears the value of the "sport_type" field.
func (m *LeadMutation) ClearSportType() {
	m.sport_type = nil
	m.clearedFields[lead.FieldSportType] = struct{}{}
}

// SportTypeCleared returns if the "sport_type" field was cleared in this mutation.
func (m *LeadMutation) SportTypeCleared() bool {
	_, ok := m.clearedFields[lead.FieldSportType]
	return ok
}

// ResetSportType resets all changes to the "sport_type" field.
func (m *LeadMutation) ResetSportType() {
	m.sport_type = nil
	delete(m.clearedFields, lead.FieldSportType)
}

// SetTattooStyle sets the "tattoo_style" field.
func (m *LeadMutation) SetTattooStyle(s string) {
	m.tattoo_style = &s
}

// TattooStyle returns the value of the "tattoo_style" field in the mutation.
func (m *LeadMutation) TattooStyle() (r string, exists bool) {
	v := m.tattoo_style
	if v == nil {
		return
	}
	return *v, true
}

// OldTattooStyle returns the old "tattoo_style" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldTattooStyle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTattooStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTattooStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTattooStyle: %w", err)
	}
	return oldValue.TattooStyle, nil
}

// ClearTattooStyle clears the value of the "tattoo_style" field.
func (m *LeadMutation) ClearTattooStyle() {
	m.tattoo_style = nil
	m.clearedFields[lead.FieldTattooStyle] = struct{}{}
}

// TattooStyleCleared returns if the "tattoo_style" field was cleared in this mutation.
func (m *LeadMutation) TattooStyleCleared() bool {
	_, ok := m.clearedFields[lead.FieldTattooStyle]
	return ok
}

// ResetTattooStyle resets all changes to the "tattoo_style" field.
func (m *LeadMutation) ResetTattooStyle() {
	m.tattoo_style = nil
	delete(m.clearedFields, lead.FieldTattooStyle)
}

// SetCreatedAt sets the "created_at" field.
func (m *LeadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LeadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LeadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LeadMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LeadMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LeadMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddNoteIDs adds the "notes" edge to the LeadNote entity by ids.
func (m *LeadMutation) AddNoteIDs(ids ...int) {
	if m.notes == nil {
		m.notes = make(map[int]struct{})
	}
	for i := range ids {
		m.notes[ids[i]] = struct{}{}
	}
}

// ClearNotes clears the "notes" edge to the LeadNote entity.
func (m *LeadMutation) ClearNotes() {
	m.clearednotes = true
}

// NotesCleared reports if the "notes" edge to the LeadNote entity was cleared.
func (m *LeadMutation) NotesCleared() bool {
	return m.clearednotes
}

// RemoveNoteIDs removes the "notes" edge to the LeadNote entity by IDs.
func (m *LeadMutation) RemoveNoteIDs(ids ...int) {
	if m.removednotes == nil {
		m.removednotes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notes, ids[i])
		m.removednotes[ids[i]] = struct{}{}
	}
}

// RemovedNotes returns the removed IDs of the "notes" edge to the LeadNote entity.
func (m *LeadMutation) RemovedNotesIDs() (ids []int) {
	for id := range m.removednotes {
		ids = append(ids, id)
	}
	return
}

// NotesIDs returns the "notes" edge IDs in the mutation.
func (m *LeadMutation) NotesIDs() (ids []int) {
	for id := range m.notes {
		ids = append(ids, id)
	}
	return
}

// ResetNotes resets all changes to the "notes" edge.
func (m *LeadMutation) ResetNotes() {
	m.notes = nil
	m.clearednotes = false
	m.removednotes = nil
}

// AddStatusHistoryIDs adds the "status_history" edge to the LeadStatusHistory entity by ids.
func (m *LeadMutation) AddStatusHistoryIDs(ids ...int) {
	if m.status_history == nil {
		m.status_history = make(map[int]struct{})
	}
	for i := range ids {
		m.status_history[ids[i]] = struct{}{}
	}
}

// ClearStatusHistory clears the "status_history" edge to the LeadStatusHistory entity.
func (m *LeadMutation) ClearStatusHistory() {
	m.clearedstatus_history = true
}

// StatusHistoryCleared reports if the "status_history" edge to the LeadStatusHistory entity was cleared.
func (m *LeadMutation) StatusHistoryCleared() bool {
	return m.clearedstatus_history
}

// RemoveStatusHistoryIDs removes the "status_history" edge to the LeadStatusHistory entity by IDs.
func (m *LeadMutation) RemoveStatusHistoryIDs(ids ...int) {
	if m.removedstatus_history == nil {
		m.removedstatus_history = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.status_history, ids[i])
		m.removedstatus_history[ids[i]] = struct{}{}
	}
}

// RemovedStatusHistory returns the removed IDs of the "status_history" edge to the LeadStatusHistory entity.
func (m *LeadMutation) RemovedStatusHistoryIDs() (ids []int) {
	for id := range m.removedstatus_history {
		ids = append(ids, id)
	}
	return
}

// StatusHistoryIDs returns the "status_history" edge IDs in the mutation.
func (m *LeadMutation) StatusHistoryIDs() (ids []int) {
	for id := range m.status_history {
		ids = append(ids, id)
	}
	return
}

// ResetStatusHistory resets all changes to the "status_history" edge.
func (m *LeadMutation) ResetStatusHistory() {
	m.status_history = nil
	m.clearedstatus_history = false
	m.removedstatus_history = nil
}

// AddAssignmentIDs adds the "assignments" edge to the LeadAssignment entity by ids.
func (m *LeadMutation) AddAssignmentIDs(ids ...int) {
	if m.assignments == nil {
		m.assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignments clears the "assignments" edge to the LeadAssignment entity.
func (m *LeadMutation) ClearAssignments() {
	m.clearedassignments = true
}

// AssignmentsCleared reports if the "assignments" edge to the LeadAssignment entity was cleared.
func (m *LeadMutation) AssignmentsCleared() bool {
	return m.clearedassignments
}

// RemoveAssignmentIDs removes the "assignments" edge to the LeadAssignment entity by IDs.
func (m *LeadMutation) RemoveAssignmentIDs(ids ...int) {
	if m.removedassignments == nil {
		m.removedassignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignments, ids[i])
		m.removedassignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignments returns the removed IDs of the "assignments" edge to the LeadAssignment entity.
func (m *LeadMutation) RemovedAssignmentsIDs() (ids []int) {
	for id := range m.removedassignments {
		ids = append(ids, id)
	}
	return
}

// AssignmentsIDs returns the "assignments" edge IDs in the mutation.
func (m *LeadMutation) AssignmentsIDs() (ids []int) {
	for id := range m.assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignments resets all changes to the "assignments" edge.
func (m *LeadMutation) ResetAssignments() {
	m.assignments = nil
	m.clearedassignments = false
	m.removedassignments = nil
}

// AddEmailSequenceEnrollmentIDs adds the "email_sequence_enrollments" edge to the EmailSequenceEnrollment entity by ids.
func (m *LeadMutation) AddEmailSequenceEnrollmentIDs(ids ...int) {
	if m.email_sequence_enrollments == nil {
		m.email_sequence_enrollments = make(map[int]struct{})
	}
	for i := range ids {
		m.email_sequence_enrollments[ids[i]] = struct{}{}
	}
}

// ClearEmailSequenceEnrollments clears the "email_sequence_enrollments" edge to the EmailSequenceEnrollment entity.
func (m *LeadMutation) ClearEmailSequenceEnrollments() {
	m.clearedemail_sequence_enrollments = true
}

// EmailSequenceEnrollmentsCleared reports if the "email_sequence_enrollments" edge to the EmailSequenceEnrollment entity was cleared.
func (m *LeadMutation) EmailSequenceEnrollmentsCleared() bool {
	return m.clearedemail_sequence_enrollments
}

// RemoveEmailSequenceEnrollmentIDs removes the "email_sequence_enrollments" edge to the EmailSequenceEnrollment entity by IDs.
func (m *LeadMutation) RemoveEmailSequenceEnrollmentIDs(ids ...int) {
	if m.removedemail_sequence_enrollments == nil {
		m.removedemail_sequence_enrollments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.email_sequence_enrollments, ids[i])
		m.removedemail_sequence_enrollments[ids[i]] = struct{}{}
	}
}

// RemovedEmailSequenceEnrollments returns the removed IDs of the "email_sequence_enrollments" edge to the EmailSequenceEnrollment entity.
func (m *LeadMutation) RemovedEmailSequenceEnrollmentsIDs() (ids []int) {
	for id := range m.removedemail_sequence_enrollments {
		ids = append(ids, id)
	}
	return
}

// EmailSequenceEnrollmentsIDs returns the "email_sequence_enrollments" edge IDs in the mutation.
func (m *LeadMutation) EmailSequenceEnrollmentsIDs() (ids []int) {
	for id := range m.email_sequence_enrollments {
		ids = append(ids, id)
	}
	return
}

// ResetEmailSequenceEnrollments resets all changes to the "email_sequence_enrollments" edge.
func (m *LeadMutation) ResetEmailSequenceEnrollments() {
	m.email_sequence_enrollments = nil
	m.clearedemail_sequence_enrollments = false
	m.removedemail_sequence_enrollments = nil
}

// AddEmailSequenceSendIDs adds the "email_sequence_sends" edge to the EmailSequenceSend entity by ids.
func (m *LeadMutation) AddEmailSequenceSendIDs(ids ...int) {
	if m.email_sequence_sends == nil {
		m.email_sequence_sends = make(map[int]struct{})
	}
	for i := range ids {
		m.email_sequence_sends[ids[i]] = struct{}{}
	}
}

// ClearEmailSequenceSends clears the "email_sequence_sends" edge to the EmailSequenceSend entity.
func (m *LeadMutation) ClearEmailSequenceSends() {
	m.clearedemail_sequence_sends = true
}

// EmailSequenceSendsCleared reports if the "email_sequence_sends" edge to the EmailSequenceSend entity was cleared.
func (m *LeadMutation) EmailSequenceSendsCleared() bool {
	return m.clearedemail_sequence_sends
}

// RemoveEmailSequenceSendIDs removes the "email_sequence_sends" edge to the EmailSequenceSend entity by IDs.
func (m *LeadMutation) RemoveEmailSequenceSendIDs(ids ...int) {
	if m.removedemail_sequence_sends == nil {
		m.removedemail_sequence_sends = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.email_sequence_sends, ids[i])
		m.removedemail_sequence_sends[ids[i]] = struct{}{}
	}
}

// RemovedEmailSequenceSends returns the removed IDs of the "email_sequence_sends" edge to the EmailSequenceSend entity.
func (m *LeadMutation) RemovedEmailSequenceSendsIDs() (ids []int) {
	for id := range m.removedemail_sequence_sends {
		ids = append(ids, id)
	}
	return
}

// EmailSequenceSendsIDs returns the "email_sequence_sends" edge IDs in the mutation.
func (m *LeadMutation) EmailSequenceSendsIDs() (ids []int) {
	for id := range m.email_sequence_sends {
		ids = append(ids, id)
	}
	return
}

// ResetEmailSequenceSends resets all changes to the "email_sequence_sends" edge.
func (m *LeadMutation) ResetEmailSequenceSends() {
	m.email_sequence_sends = nil
	m.clearedemail_sequence_sends = false
	m.removedemail_sequence_sends = nil
}

// Where appends a list predicates to the LeadMutation builder.
func (m *LeadMutation) Where(ps ...predicate.Lead) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lead, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lead).
func (m *LeadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeadMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.name != nil {
		fields = append(fields, lead.FieldName)
	}
	if m.industry != nil {
		fields = append(fields, lead.FieldIndustry)
	}
	if m.country != nil {
		fields = append(fields, lead.FieldCountry)
	}
	if m.city != nil {
		fields = append(fields, lead.FieldCity)
	}
	if m.address != nil {
		fields = append(fields, lead.FieldAddress)
	}
	if m.postal_code != nil {
		fields = append(fields, lead.FieldPostalCode)
	}
	if m.phone != nil {
		fields = append(fields, lead.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, lead.FieldEmail)
	}
	if m.website != nil {
		fields = append(fields, lead.FieldWebsite)
	}
	if m.social_media != nil {
		fields = append(fields, lead.FieldSocialMedia)
	}
	if m.latitude != nil {
		fields = append(fields, lead.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, lead.FieldLongitude)
	}
	if m.verified != nil {
		fields = append(fields, lead.FieldVerified)
	}
	if m.quality_score != nil {
		fields = append(fields, lead.FieldQualityScore)
	}
	if m.status != nil {
		fields = append(fields, lead.FieldStatus)
	}
	if m.status_changed_at != nil {
		fields = append(fields, lead.FieldStatusChangedAt)
	}
	if m.custom_fields != nil {
		fields = append(fields, lead.FieldCustomFields)
	}
	if m.osm_id != nil {
		fields = append(fields, lead.FieldOsmID)
	}
	if m.metadata != nil {
		fields = append(fields, lead.FieldMetadata)
	}
	if m.sub_niche != nil {
		fields = append(fields, lead.FieldSubNiche)
	}
	if m.specialties != nil {
		fields = append(fields, lead.FieldSpecialties)
	}
	if m.cuisine_type != nil {
		fields = append(fields, lead.FieldCuisineType)
	}
	if m.sport_type != nil {
		fields = append(fields, lead.FieldSportType)
	}
	if m.tattoo_style != nil {
		fields = append(fields, lead.FieldTattooStyle)
	}
	if m.created_at != nil {
		fields = append(fields, lead.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lead.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lead.FieldName:
		return m.Name()
	case lead.FieldIndustry:
		return m.Industry()
	case lead.FieldCountry:
		return m.Country()
	case lead.FieldCity:
		return m.City()
	case lead.FieldAddress:
		return m.Address()
	case lead.FieldPostalCode:
		return m.PostalCode()
	case lead.FieldPhone:
		return m.Phone()
	case lead.FieldEmail:
		return m.Email()
	case lead.FieldWebsite:
		return m.Website()
	case lead.FieldSocialMedia:
		return m.SocialMedia()
	case lead.FieldLatitude:
		return m.Latitude()
	case lead.FieldLongitude:
		return m.Longitude()
	case lead.FieldVerified:
		return m.Verified()
	case lead.FieldQualityScore:
		return m.QualityScore()
	case lead.FieldStatus:
		return m.Status()
	case lead.FieldStatusChangedAt:
		return m.StatusChangedAt()
	case lead.FieldCustomFields:
		return m.CustomFields()
	case lead.FieldOsmID:
		return m.OsmID()
	case lead.FieldMetadata:
		return m.Metadata()
	case lead.FieldSubNiche:
		return m.SubNiche()
	case lead.FieldSpecialties:
		return m.Specialties()
	case lead.FieldCuisineType:
		return m.CuisineType()
	case lead.FieldSportType:
		return m.SportType()
	case lead.FieldTattooStyle:
		return m.TattooStyle()
	case lead.FieldCreatedAt:
		return m.CreatedAt()
	case lead.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lead.FieldName:
		return m.OldName(ctx)
	case lead.FieldIndustry:
		return m.OldIndustry(ctx)
	case lead.FieldCountry:
		return m.OldCountry(ctx)
	case lead.FieldCity:
		return m.OldCity(ctx)
	case lead.FieldAddress:
		return m.OldAddress(ctx)
	case lead.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case lead.FieldPhone:
		return m.OldPhone(ctx)
	case lead.FieldEmail:
		return m.OldEmail(ctx)
	case lead.FieldWebsite:
		return m.OldWebsite(ctx)
	case lead.FieldSocialMedia:
		return m.OldSocialMedia(ctx)
	case lead.FieldLatitude:
		return m.OldLatitude(ctx)
	case lead.FieldLongitude:
		return m.OldLongitude(ctx)
	case lead.FieldVerified:
		return m.OldVerified(ctx)
	case lead.FieldQualityScore:
		return m.OldQualityScore(ctx)
	case lead.FieldStatus:
		return m.OldStatus(ctx)
	case lead.FieldStatusChangedAt:
		return m.OldStatusChangedAt(ctx)
	case lead.FieldCustomFields:
		return m.OldCustomFields(ctx)
	case lead.FieldOsmID:
		return m.OldOsmID(ctx)
	case lead.FieldMetadata:
		return m.OldMetadata(ctx)
	case lead.FieldSubNiche:
		return m.OldSubNiche(ctx)
	case lead.FieldSpecialties:
		return m.OldSpecialties(ctx)
	case lead.FieldCuisineType:
		return m.OldCuisineType(ctx)
	case lead.FieldSportType:
		return m.OldSportType(ctx)
	case lead.FieldTattooStyle:
		return m.OldTattooStyle(ctx)
	case lead.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lead.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Lead field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lead.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case lead.FieldIndustry:
		v, ok := value.(lead.Industry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustry(v)
		return nil
	case lead.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case lead.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case lead.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case lead.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case lead.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case lead.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case lead.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case lead.FieldSocialMedia:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialMedia(v)
		return nil
	case lead.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case lead.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case lead.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case lead.FieldQualityScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityScore(v)
		return nil
	case lead.FieldStatus:
		v, ok := value.(lead.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case lead.FieldStatusChangedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusChangedAt(v)
		return nil
	case lead.FieldCustomFields:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomFields(v)
		return nil
	case lead.FieldOsmID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsmID(v)
		return nil
	case lead.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case lead.FieldSubNiche:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubNiche(v)
		return nil
	case lead.FieldSpecialties:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialties(v)
		return nil
	case lead.FieldCuisineType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCuisineType(v)
		return nil
	case lead.FieldSportType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSportType(v)
		return nil
	case lead.FieldTattooStyle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTattooStyle(v)
		return nil
	case lead.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lead.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Lead field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeadMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, lead.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, lead.FieldLongitude)
	}
	if m.addquality_score != nil {
		fields = append(fields, lead.FieldQualityScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lead.FieldLatitude:
		return m.AddedLatitude()
	case lead.FieldLongitude:
		return m.AddedLongitude()
	case lead.FieldQualityScore:
		return m.AddedQualityScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lead.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case lead.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case lead.FieldQualityScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQualityScore(v)
		return nil
	}
	return fmt.Errorf("unknown Lead numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lead.FieldAddress) {
		fields = append(fields, lead.FieldAddress)
	}
	if m.FieldCleared(lead.FieldPostalCode) {
		fields = append(fields, lead.FieldPostalCode)
	}
	if m.FieldCleared(lead.FieldPhone) {
		fields = append(fields, lead.FieldPhone)
	}
	if m.FieldCleared(lead.FieldEmail) {
		fields = append(fields, lead.FieldEmail)
	}
	if m.FieldCleared(lead.FieldWebsite) {
		fields = append(fields, lead.FieldWebsite)
	}
	if m.FieldCleared(lead.FieldSocialMedia) {
		fields = append(fields, lead.FieldSocialMedia)
	}
	if m.FieldCleared(lead.FieldLatitude) {
		fields = append(fields, lead.FieldLatitude)
	}
	if m.FieldCleared(lead.FieldLongitude) {
		fields = append(fields, lead.FieldLongitude)
	}
	if m.FieldCleared(lead.FieldCustomFields) {
		fields = append(fields, lead.FieldCustomFields)
	}
	if m.FieldCleared(lead.FieldOsmID) {
		fields = append(fields, lead.FieldOsmID)
	}
	if m.FieldCleared(lead.FieldMetadata) {
		fields = append(fields, lead.FieldMetadata)
	}
	if m.FieldCleared(lead.FieldSubNiche) {
		fields = append(fields, lead.FieldSubNiche)
	}
	if m.FieldCleared(lead.FieldSpecialties) {
		fields = append(fields, lead.FieldSpecialties)
	}
	if m.FieldCleared(lead.FieldCuisineType) {
		fields = append(fields, lead.FieldCuisineType)
	}
	if m.FieldCleared(lead.FieldSportType) {
		fields = append(fields, lead.FieldSportType)
	}
	if m.FieldCleared(lead.FieldTattooStyle) {
		fields = append(fields, lead.FieldTattooStyle)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeadMutation) ClearField(name string) error {
	switch name {
	case lead.FieldAddress:
		m.ClearAddress()
		return nil
	case lead.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case lead.FieldPhone:
		m.ClearPhone()
		return nil
	case lead.FieldEmail:
		m.ClearEmail()
		return nil
	case lead.FieldWebsite:
		m.ClearWebsite()
		return nil
	case lead.FieldSocialMedia:
		m.ClearSocialMedia()
		return nil
	case lead.FieldLatitude:
		m.ClearLatitude()
		return nil
	case lead.FieldLongitude:
		m.ClearLongitude()
		return nil
	case lead.FieldCustomFields:
		m.ClearCustomFields()
		return nil
	case lead.FieldOsmID:
		m.ClearOsmID()
		return nil
	case lead.FieldMetadata:
		m.ClearMetadata()
		return nil
	case lead.FieldSubNiche:
		m.ClearSubNiche()
		return nil
	case lead.FieldSpecialties:
		m.ClearSpecialties()
		return nil
	case lead.FieldCuisineType:
		m.ClearCuisineType()
		return nil
	case lead.FieldSportType:
		m.ClearSportType()
		return nil
	case lead.FieldTattooStyle:
		m.ClearTattooStyle()
		return nil
	}
	return fmt.Errorf("unknown Lead nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeadMutation) ResetField(name string) error {
	switch name {
	case lead.FieldName:
		m.ResetName()
		return nil
	case lead.FieldIndustry:
		m.ResetIndustry()
		return nil
	case lead.FieldCountry:
		m.ResetCountry()
		return nil
	case lead.FieldCity:
		m.ResetCity()
		return nil
	case lead.FieldAddress:
		m.ResetAddress()
		return nil
	case lead.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case lead.FieldPhone:
		m.ResetPhone()
		return nil
	case lead.FieldEmail:
		m.ResetEmail()
		return nil
	case lead.FieldWebsite:
		m.ResetWebsite()
		return nil
	case lead.FieldSocialMedia:
		m.ResetSocialMedia()
		return nil
	case lead.FieldLatitude:
		m.ResetLatitude()
		return nil
	case lead.FieldLongitude:
		m.ResetLongitude()
		return nil
	case lead.FieldVerified:
		m.ResetVerified()
		return nil
	case lead.FieldQualityScore:
		m.ResetQualityScore()
		return nil
	case lead.FieldStatus:
		m.ResetStatus()
		return nil
	case lead.FieldStatusChangedAt:
		m.ResetStatusChangedAt()
		return nil
	case lead.FieldCustomFields:
		m.ResetCustomFields()
		return nil
	case lead.FieldOsmID:
		m.ResetOsmID()
		return nil
	case lead.FieldMetadata:
		m.ResetMetadata()
		return nil
	case lead.FieldSubNiche:
		m.ResetSubNiche()
		return nil
	case lead.FieldSpecialties:
		m.ResetSpecialties()
		return nil
	case lead.FieldCuisineType:
		m.ResetCuisineType()
		return nil
	case lead.FieldSportType:
		m.ResetSportType()
		return nil
	case lead.FieldTattooStyle:
		m.ResetTattooStyle()
		return nil
	case lead.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lead.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Lead field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeadMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.notes != nil {
		edges = append(edges, lead.EdgeNotes)
	}
	if m.status_history != nil {
		edges = append(edges, lead.EdgeStatusHistory)
	}
	if m.assignments != nil {
		edges = append(edges, lead.EdgeAssignments)
	}
	if m.email_sequence_enrollments != nil {
		edges = append(edges, lead.EdgeEmailSequenceEnrollments)
	}
	if m.email_sequence_sends != nil {
		edges = append(edges, lead.EdgeEmailSequenceSends)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lead.EdgeNotes:
		ids := make([]ent.Value, 0, len(m.notes))
		for id := range m.notes {
			ids = append(ids, id)
		}
		return ids
	case lead.EdgeStatusHistory:
		ids := make([]ent.Value, 0, len(m.status_history))
		for id := range m.status_history {
			ids = append(ids, id)
		}
		return ids
	case lead.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.assignments))
		for id := range m.assignments {
			ids = append(ids, id)
		}
		return ids
	case lead.EdgeEmailSequenceEnrollments:
		ids := make([]ent.Value, 0, len(m.email_sequence_enrollments))
		for id := range m.email_sequence_enrollments {
			ids = append(ids, id)
		}
		return ids
	case lead.EdgeEmailSequenceSends:
		ids := make([]ent.Value, 0, len(m.email_sequence_sends))
		for id := range m.email_sequence_sends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removednotes != nil {
		edges = append(edges, lead.EdgeNotes)
	}
	if m.removedstatus_history != nil {
		edges = append(edges, lead.EdgeStatusHistory)
	}
	if m.removedassignments != nil {
		edges = append(edges, lead.EdgeAssignments)
	}
	if m.removedemail_sequence_enrollments != nil {
		edges = append(edges, lead.EdgeEmailSequenceEnrollments)
	}
	if m.removedemail_sequence_sends != nil {
		edges = append(edges, lead.EdgeEmailSequenceSends)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lead.EdgeNotes:
		ids := make([]ent.Value, 0, len(m.removednotes))
		for id := range m.removednotes {
			ids = append(ids, id)
		}
		return ids
	case lead.EdgeStatusHistory:
		ids := make([]ent.Value, 0, len(m.removedstatus_history))
		for id := range m.removedstatus_history {
			ids = append(ids, id)
		}
		return ids
	case lead.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.removedassignments))
		for id := range m.removedassignments {
			ids = append(ids, id)
		}
		return ids
	case lead.EdgeEmailSequenceEnrollments:
		ids := make([]ent.Value, 0, len(m.removedemail_sequence_enrollments))
		for id := range m.removedemail_sequence_enrollments {
			ids = append(ids, id)
		}
		return ids
	case lead.EdgeEmailSequenceSends:
		ids := make([]ent.Value, 0, len(m.removedemail_sequence_sends))
		for id := range m.removedemail_sequence_sends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearednotes {
		edges = append(edges, lead.EdgeNotes)
	}
	if m.clearedstatus_history {
		edges = append(edges, lead.EdgeStatusHistory)
	}
	if m.clearedassignments {
		edges = append(edges, lead.EdgeAssignments)
	}
	if m.clearedemail_sequence_enrollments {
		edges = append(edges, lead.EdgeEmailSequenceEnrollments)
	}
	if m.clearedemail_sequence_sends {
		edges = append(edges, lead.EdgeEmailSequenceSends)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeadMutation) EdgeCleared(name string) bool {
	switch name {
	case lead.EdgeNotes:
		return m.clearednotes
	case lead.EdgeStatusHistory:
		return m.clearedstatus_history
	case lead.EdgeAssignments:
		return m.clearedassignments
	case lead.EdgeEmailSequenceEnrollments:
		return m.clearedemail_sequence_enrollments
	case lead.EdgeEmailSequenceSends:
		return m.clearedemail_sequence_sends
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeadMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Lead unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeadMutation) ResetEdge(name string) error {
	switch name {
	case lead.EdgeNotes:
		m.ResetNotes()
		return nil
	case lead.EdgeStatusHistory:
		m.ResetStatusHistory()
		return nil
	case lead.EdgeAssignments:
		m.ResetAssignments()
		return nil
	case lead.EdgeEmailSequenceEnrollments:
		m.ResetEmailSequenceEnrollments()
		return nil
	case lead.EdgeEmailSequenceSends:
		m.ResetEmailSequenceSends()
		return nil
	}
	return fmt.Errorf("unknown Lead edge %s", name)
}

// LeadAssignmentMutation represents an operation that mutates the LeadAssignment nodes in the graph.
type LeadAssignmentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	assignment_type    *leadassignment.AssignmentType
	assignment_reason  *string
	assigned_at        *time.Time
	is_active          *bool
	created_at         *time.Time
	clearedFields      map[string]struct{}
	lead               *int
	clearedlead        bool
	user               *int
	cleareduser        bool
	assigned_by        *int
	clearedassigned_by bool
	done               bool
	oldValue           func(context.Context) (*LeadAssignment, error)
	predicates         []predicate.LeadAssignment
}

var _ ent.Mutation = (*LeadAssignmentMutation)(nil)

// leadassignmentOption allows management of the mutation configuration using functional options.
type leadassignmentOption func(*LeadAssignmentMutation)

// newLeadAssignmentMutation creates new mutation for the LeadAssignment entity.
func newLeadAssignmentMutation(c config, op Op, opts ...leadassignmentOption) *LeadAssignmentMutation {
	m := &LeadAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeLeadAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeadAssignmentID sets the ID field of the mutation.
func withLeadAssignmentID(id int) leadassignmentOption {
	return func(m *LeadAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *LeadAssignment
		)
		m.oldValue = func(ctx context.Context) (*LeadAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LeadAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLeadAssignment sets the old LeadAssignment of the mutation.
func withLeadAssignment(node *LeadAssignment) leadassignmentOption {
	return func(m *LeadAssignmentMutation) {
		m.oldValue = func(context.Context) (*LeadAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeadAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeadAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeadAssignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeadAssignmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LeadAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLeadID sets the "lead_id" field.
func (m *LeadAssignmentMutation) SetLeadID(i int) {
	m.lead = &i
}

// LeadID returns the value of the "lead_id" field in the mutation.
func (m *LeadAssignmentMutation) LeadID() (r int, exists bool) {
	v := m.lead
	if v == nil {
		return
	}
	return *v, true
}

// OldLeadID returns the old "lead_id" field's value of the LeadAssignment entity.
// If the LeadAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadAssignmentMutation) OldLeadID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeadID: %w", err)
	}
	return oldValue.LeadID, nil
}

// ResetLeadID resets all changes to the "lead_id" field.
func (m *LeadAssignmentMutation) ResetLeadID() {
	m.lead = nil
}

// SetUserID sets the "user_id" field.
func (m *LeadAssignmentMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LeadAssignmentMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LeadAssignment entity.
// If the LeadAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadAssignmentMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LeadAssignmentMutation) ResetUserID() {
	m.user = nil
}

// SetAssignedByUserID sets the "assigned_by_user_id" field.
func (m *LeadAssignmentMutation) SetAssignedByUserID(i int) {
	m.assigned_by = &i
}

// AssignedByUserID returns the value of the "assigned_by_user_id" field in the mutation.
func (m *LeadAssignmentMutation) AssignedByUserID() (r int, exists bool) {
	v := m.assigned_by
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedByUserID returns the old "assigned_by_user_id" field's value of the LeadAssignment entity.
// If the LeadAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadAssignmentMutation) OldAssignedByUserID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedByUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedByUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedByUserID: %w", err)
	}
	return oldValue.AssignedByUserID, nil
}

// ClearAssignedByUserID clears the value of the "assigned_by_user_id" field.
func (m *LeadAssignmentMutation) ClearAssignedByUserID() {
	m.assigned_by = nil
	m.clearedFields[leadassignment.FieldAssignedByUserID] = struct{}{}
}

// AssignedByUserIDCleared returns if the "assigned_by_user_id" field was cleared in this mutation.
func (m *LeadAssignmentMutation) AssignedByUserIDCleared() bool {
	_, ok := m.clearedFields[leadassignment.FieldAssignedByUserID]
	return ok
}

// ResetAssignedByUserID resets all changes to the "assigned_by_user_id" field.
func (m *LeadAssignmentMutation) ResetAssignedByUserID() {
	m.assigned_by = nil
	delete(m.clearedFields, leadassignment.FieldAssignedByUserID)
}

// SetAssignmentType sets the "assignment_type" field.
func (m *LeadAssignmentMutation) SetAssignmentType(lt leadassignment.AssignmentType) {
	m.assignment_type = &lt
}

// AssignmentType returns the value of the "assignment_type" field in the mutation.
func (m *LeadAssignmentMutation) AssignmentType() (r leadassignment.AssignmentType, exists bool) {
	v := m.assignment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignmentType returns the old "assignment_type" field's value of the LeadAssignment entity.
// If the LeadAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadAssignmentMutation) OldAssignmentType(ctx context.Context) (v leadassignment.AssignmentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignmentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignmentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignmentType: %w", err)
	}
	return oldValue.AssignmentType, nil
}

// ResetAssignmentType resets all changes to the "assignment_type" field.
func (m *LeadAssignmentMutation) ResetAssignmentType() {
	m.assignment_type = nil
}

// SetAssignmentReason sets the "assignment_reason" field.
func (m *LeadAssignmentMutation) SetAssignmentReason(s string) {
	m.assignment_reason = &s
}

// AssignmentReason returns the value of the "assignment_reason" field in the mutation.
func (m *LeadAssignmentMutation) AssignmentReason() (r string, exists bool) {
	v := m.assignment_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignmentReason returns the old "assignment_reason" field's value of the LeadAssignment entity.
// If the LeadAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadAssignmentMutation) OldAssignmentReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignmentReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignmentReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignmentReason: %w", err)
	}
	return oldValue.AssignmentReason, nil
}

// ClearAssignmentReason clears the value of the "assignment_reason" field.
func (m *LeadAssignmentMutation) ClearAssignmentReason() {
	m.assignment_reason = nil
	m.clearedFields[leadassignment.FieldAssignmentReason] = struct{}{}
}

// AssignmentReasonCleared returns if the "assignment_reason" field was cleared in this mutation.
func (m *LeadAssignmentMutation) AssignmentReasonCleared() bool {
	_, ok := m.clearedFields[leadassignment.FieldAssignmentReason]
	return ok
}

// ResetAssignmentReason resets all changes to the "assignment_reason" field.
func (m *LeadAssignmentMutation) ResetAssignmentReason() {
	m.assignment_reason = nil
	delete(m.clearedFields, leadassignment.FieldAssignmentReason)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *LeadAssignmentMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *LeadAssignmentMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the LeadAssignment entity.
// If the LeadAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadAssignmentMutation) OldAssignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *LeadAssignmentMutation) ResetAssignedAt() {
	m.assigned_at = nil
}

// SetIsActive sets the "is_active" field.
func (m *LeadAssignmentMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *LeadAssignmentMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the LeadAssignment entity.
// If the LeadAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadAssignmentMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *LeadAssignmentMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LeadAssignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LeadAssignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LeadAssignment entity.
// If the LeadAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadAssignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LeadAssignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearLead clears the "lead" edge to the Lead entity.
func (m *LeadAssignmentMutation) ClearLead() {
	m.clearedlead = true
	m.clearedFields[leadassignment.FieldLeadID] = struct{}{}
}

// LeadCleared reports if the "lead" edge to the Lead entity was cleared.
func (m *LeadAssignmentMutation) LeadCleared() bool {
	return m.clearedlead
}

// LeadIDs returns the "lead" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeadID instead. It exists only for internal usage by the builders.
func (m *LeadAssignmentMutation) LeadIDs() (ids []int) {
	if id := m.lead; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLead resets all changes to the "lead" edge.
func (m *LeadAssignmentMutation) ResetLead() {
	m.lead = nil
	m.clearedlead = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *LeadAssignmentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[leadassignment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LeadAssignmentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LeadAssignmentMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LeadAssignmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAssignedByID sets the "assigned_by" edge to the User entity by id.
func (m *LeadAssignmentMutation) SetAssignedByID(id int) {
	m.assigned_by = &id
}

// ClearAssignedBy clears the "assigned_by" edge to the User entity.
func (m *LeadAssignmentMutation) ClearAssignedBy() {
	m.clearedassigned_by = true
	m.clearedFields[leadassignment.FieldAssignedByUserID] = struct{}{}
}

// AssignedByCleared reports if the "assigned_by" edge to the User entity was cleared.
func (m *LeadAssignmentMutation) AssignedByCleared() bool {
	return m.AssignedByUserIDCleared() || m.clearedassigned_by
}

// AssignedByID returns the "assigned_by" edge ID in the mutation.
func (m *LeadAssignmentMutation) AssignedByID() (id int, exists bool) {
	if m.assigned_by != nil {
		return *m.assigned_by, true
	}
	return
}

// AssignedByIDs returns the "assigned_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignedByID instead. It exists only for internal usage by the builders.
func (m *LeadAssignmentMutation) AssignedByIDs() (ids []int) {
	if id := m.assigned_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignedBy resets all changes to the "assigned_by" edge.
func (m *LeadAssignmentMutation) ResetAssignedBy() {
	m.assigned_by = nil
	m.clearedassigned_by = false
}

// Where appends a list predicates to the LeadAssignmentMutation builder.
func (m *LeadAssignmentMutation) Where(ps ...predicate.LeadAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeadAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeadAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LeadAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeadAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeadAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LeadAssignment).
func (m *LeadAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeadAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.lead != nil {
		fields = append(fields, leadassignment.FieldLeadID)
	}
	if m.user != nil {
		fields = append(fields, leadassignment.FieldUserID)
	}
	if m.assigned_by != nil {
		fields = append(fields, leadassignment.FieldAssignedByUserID)
	}
	if m.assignment_type != nil {
		fields = append(fields, leadassignment.FieldAssignmentType)
	}
	if m.assignment_reason != nil {
		fields = append(fields, leadassignment.FieldAssignmentReason)
	}
	if m.assigned_at != nil {
		fields = append(fields, leadassignment.FieldAssignedAt)
	}
	if m.is_active != nil {
		fields = append(fields, leadassignment.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, leadassignment.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeadAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case leadassignment.FieldLeadID:
		return m.LeadID()
	case leadassignment.FieldUserID:
		return m.UserID()
	case leadassignment.FieldAssignedByUserID:
		return m.AssignedByUserID()
	case leadassignment.FieldAssignmentType:
		return m.AssignmentType()
	case leadassignment.FieldAssignmentReason:
		return m.AssignmentReason()
	case leadassignment.FieldAssignedAt:
		return m.AssignedAt()
	case leadassignment.FieldIsActive:
		return m.IsActive()
	case leadassignment.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeadAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case leadassignment.FieldLeadID:
		return m.OldLeadID(ctx)
	case leadassignment.FieldUserID:
		return m.OldUserID(ctx)
	case leadassignment.FieldAssignedByUserID:
		return m.OldAssignedByUserID(ctx)
	case leadassignment.FieldAssignmentType:
		return m.OldAssignmentType(ctx)
	case leadassignment.FieldAssignmentReason:
		return m.OldAssignmentReason(ctx)
	case leadassignment.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case leadassignment.FieldIsActive:
		return m.OldIsActive(ctx)
	case leadassignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LeadAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case leadassignment.FieldLeadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeadID(v)
		return nil
	case leadassignment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case leadassignment.FieldAssignedByUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedByUserID(v)
		return nil
	case leadassignment.FieldAssignmentType:
		v, ok := value.(leadassignment.AssignmentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignmentType(v)
		return nil
	case leadassignment.FieldAssignmentReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignmentReason(v)
		return nil
	case leadassignment.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case leadassignment.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case leadassignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LeadAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeadAssignmentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeadAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LeadAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeadAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(leadassignment.FieldAssignedByUserID) {
		fields = append(fields, leadassignment.FieldAssignedByUserID)
	}
	if m.FieldCleared(leadassignment.FieldAssignmentReason) {
		fields = append(fields, leadassignment.FieldAssignmentReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeadAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeadAssignmentMutation) ClearField(name string) error {
	switch name {
	case leadassignment.FieldAssignedByUserID:
		m.ClearAssignedByUserID()
		return nil
	case leadassignment.FieldAssignmentReason:
		m.ClearAssignmentReason()
		return nil
	}
	return fmt.Errorf("unknown LeadAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeadAssignmentMutation) ResetField(name string) error {
	switch name {
	case leadassignment.FieldLeadID:
		m.ResetLeadID()
		return nil
	case leadassignment.FieldUserID:
		m.ResetUserID()
		return nil
	case leadassignment.FieldAssignedByUserID:
		m.ResetAssignedByUserID()
		return nil
	case leadassignment.FieldAssignmentType:
		m.ResetAssignmentType()
		return nil
	case leadassignment.FieldAssignmentReason:
		m.ResetAssignmentReason()
		return nil
	case leadassignment.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case leadassignment.FieldIsActive:
		m.ResetIsActive()
		return nil
	case leadassignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown LeadAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeadAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.lead != nil {
		edges = append(edges, leadassignment.EdgeLead)
	}
	if m.user != nil {
		edges = append(edges, leadassignment.EdgeUser)
	}
	if m.assigned_by != nil {
		edges = append(edges, leadassignment.EdgeAssignedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeadAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case leadassignment.EdgeLead:
		if id := m.lead; id != nil {
			return []ent.Value{*id}
		}
	case leadassignment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case leadassignment.EdgeAssignedBy:
		if id := m.assigned_by; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeadAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeadAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeadAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedlead {
		edges = append(edges, leadassignment.EdgeLead)
	}
	if m.cleareduser {
		edges = append(edges, leadassignment.EdgeUser)
	}
	if m.clearedassigned_by {
		edges = append(edges, leadassignment.EdgeAssignedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeadAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case leadassignment.EdgeLead:
		return m.clearedlead
	case leadassignment.EdgeUser:
		return m.cleareduser
	case leadassignment.EdgeAssignedBy:
		return m.clearedassigned_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeadAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case leadassignment.EdgeLead:
		m.ClearLead()
		return nil
	case leadassignment.EdgeUser:
		m.ClearUser()
		return nil
	case leadassignment.EdgeAssignedBy:
		m.ClearAssignedBy()
		return nil
	}
	return fmt.Errorf("unknown LeadAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeadAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case leadassignment.EdgeLead:
		m.ResetLead()
		return nil
	case leadassignment.EdgeUser:
		m.ResetUser()
		return nil
	case leadassignment.EdgeAssignedBy:
		m.ResetAssignedBy()
		return nil
	}
	return fmt.Errorf("unknown LeadAssignment edge %s", name)
}

// LeadNoteMutation represents an operation that mutates the LeadNote nodes in the graph.
type LeadNoteMutation struct {
	config
	op            Op
	typ           string
	id            *int
	content       *string
	is_pinned     *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	lead          *int
	clearedlead   bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*LeadNote, error)
	predicates    []predicate.LeadNote
}

var _ ent.Mutation = (*LeadNoteMutation)(nil)

// leadnoteOption allows management of the mutation configuration using functional options.
type leadnoteOption func(*LeadNoteMutation)

// newLeadNoteMutation creates new mutation for the LeadNote entity.
func newLeadNoteMutation(c config, op Op, opts ...leadnoteOption) *LeadNoteMutation {
	m := &LeadNoteMutation{
		config:        c,
		op:            op,
		typ:           TypeLeadNote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeadNoteID sets the ID field of the mutation.
func withLeadNoteID(id int) leadnoteOption {
	return func(m *LeadNoteMutation) {
		var (
			err   error
			once  sync.Once
			value *LeadNote
		)
		m.oldValue = func(ctx context.Context) (*LeadNote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LeadNote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLeadNote sets the old LeadNote of the mutation.
func withLeadNote(node *LeadNote) leadnoteOption {
	return func(m *LeadNoteMutation) {
		m.oldValue = func(context.Context) (*LeadNote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeadNoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeadNoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeadNoteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeadNoteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LeadNote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLeadID sets the "lead_id" field.
func (m *LeadNoteMutation) SetLeadID(i int) {
	m.lead = &i
}

// LeadID returns the value of the "lead_id" field in the mutation.
func (m *LeadNoteMutation) LeadID() (r int, exists bool) {
	v := m.lead
	if v == nil {
		return
	}
	return *v, true
}

// OldLeadID returns the old "lead_id" field's value of the LeadNote entity.
// If the LeadNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadNoteMutation) OldLeadID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeadID: %w", err)
	}
	return oldValue.LeadID, nil
}

// ResetLeadID resets all changes to the "lead_id" field.
func (m *LeadNoteMutation) ResetLeadID() {
	m.lead = nil
}

// SetUserID sets the "user_id" field.
func (m *LeadNoteMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LeadNoteMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LeadNote entity.
// If the LeadNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadNoteMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LeadNoteMutation) ResetUserID() {
	m.user = nil
}

// SetContent sets the "content" field.
func (m *LeadNoteMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *LeadNoteMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the LeadNote entity.
// If the LeadNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadNoteMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *LeadNoteMutation) ResetContent() {
	m.content = nil
}

// SetIsPinned sets the "is_pinned" field.
func (m *LeadNoteMutation) SetIsPinned(b bool) {
	m.is_pinned = &b
}

// IsPinned returns the value of the "is_pinned" field in the mutation.
func (m *LeadNoteMutation) IsPinned() (r bool, exists bool) {
	v := m.is_pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPinned returns the old "is_pinned" field's value of the LeadNote entity.
// If the LeadNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadNoteMutation) OldIsPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPinned: %w", err)
	}
	return oldValue.IsPinned, nil
}

// ResetIsPinned resets all changes to the "is_pinned" field.
func (m *LeadNoteMutation) ResetIsPinned() {
	m.is_pinned = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LeadNoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LeadNoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LeadNote entity.
// If the LeadNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadNoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LeadNoteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LeadNoteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LeadNoteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LeadNote entity.
// If the LeadNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadNoteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LeadNoteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearLead clears the "lead" edge to the Lead entity.
func (m *LeadNoteMutation) ClearLead() {
	m.clearedlead = true
	m.clearedFields[leadnote.FieldLeadID] = struct{}{}
}

// LeadCleared reports if the "lead" edge to the Lead entity was cleared.
func (m *LeadNoteMutation) LeadCleared() bool {
	return m.clearedlead
}

// LeadIDs returns the "lead" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeadID instead. It exists only for internal usage by the builders.
func (m *LeadNoteMutation) LeadIDs() (ids []int) {
	if id := m.lead; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLead resets all changes to the "lead" edge.
func (m *LeadNoteMutation) ResetLead() {
	m.lead = nil
	m.clearedlead = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *LeadNoteMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[leadnote.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LeadNoteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LeadNoteMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LeadNoteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the LeadNoteMutation builder.
func (m *LeadNoteMutation) Where(ps ...predicate.LeadNote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeadNoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeadNoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LeadNote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeadNoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeadNoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LeadNote).
func (m *LeadNoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeadNoteMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.lead != nil {
		fields = append(fields, leadnote.FieldLeadID)
	}
	if m.user != nil {
		fields = append(fields, leadnote.FieldUserID)
	}
	if m.content != nil {
		fields = append(fields, leadnote.FieldContent)
	}
	if m.is_pinned != nil {
		fields = append(fields, leadnote.FieldIsPinned)
	}
	if m.created_at != nil {
		fields = append(fields, leadnote.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, leadnote.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeadNoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case leadnote.FieldLeadID:
		return m.LeadID()
	case leadnote.FieldUserID:
		return m.UserID()
	case leadnote.FieldContent:
		return m.Content()
	case leadnote.FieldIsPinned:
		return m.IsPinned()
	case leadnote.FieldCreatedAt:
		return m.CreatedAt()
	case leadnote.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeadNoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case leadnote.FieldLeadID:
		return m.OldLeadID(ctx)
	case leadnote.FieldUserID:
		return m.OldUserID(ctx)
	case leadnote.FieldContent:
		return m.OldContent(ctx)
	case leadnote.FieldIsPinned:
		return m.OldIsPinned(ctx)
	case leadnote.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case leadnote.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LeadNote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadNoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case leadnote.FieldLeadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeadID(v)
		return nil
	case leadnote.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case leadnote.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case leadnote.FieldIsPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPinned(v)
		return nil
	case leadnote.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case leadnote.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LeadNote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeadNoteMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeadNoteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadNoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LeadNote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeadNoteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeadNoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeadNoteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LeadNote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeadNoteMutation) ResetField(name string) error {
	switch name {
	case leadnote.FieldLeadID:
		m.ResetLeadID()
		return nil
	case leadnote.FieldUserID:
		m.ResetUserID()
		return nil
	case leadnote.FieldContent:
		m.ResetContent()
		return nil
	case leadnote.FieldIsPinned:
		m.ResetIsPinned()
		return nil
	case leadnote.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case leadnote.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown LeadNote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeadNoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.lead != nil {
		edges = append(edges, leadnote.EdgeLead)
	}
	if m.user != nil {
		edges = append(edges, leadnote.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeadNoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case leadnote.EdgeLead:
		if id := m.lead; id != nil {
			return []ent.Value{*id}
		}
	case leadnote.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeadNoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeadNoteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeadNoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlead {
		edges = append(edges, leadnote.EdgeLead)
	}
	if m.cleareduser {
		edges = append(edges, leadnote.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeadNoteMutation) EdgeCleared(name string) bool {
	switch name {
	case leadnote.EdgeLead:
		return m.clearedlead
	case leadnote.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeadNoteMutation) ClearEdge(name string) error {
	switch name {
	case leadnote.EdgeLead:
		m.ClearLead()
		return nil
	case leadnote.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown LeadNote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeadNoteMutation) ResetEdge(name string) error {
	switch name {
	case leadnote.EdgeLead:
		m.ResetLead()
		return nil
	case leadnote.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown LeadNote edge %s", name)
}

// LeadStatusHistoryMutation represents an operation that mutates the LeadStatusHistory nodes in the graph.
type LeadStatusHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	old_status    *leadstatushistory.OldStatus
	new_status    *leadstatushistory.NewStatus
	reason        *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	lead          *int
	clearedlead   bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*LeadStatusHistory, error)
	predicates    []predicate.LeadStatusHistory
}

var _ ent.Mutation = (*LeadStatusHistoryMutation)(nil)

// leadstatushistoryOption allows management of the mutation configuration using functional options.
type leadstatushistoryOption func(*LeadStatusHistoryMutation)

// newLeadStatusHistoryMutation creates new mutation for the LeadStatusHistory entity.
func newLeadStatusHistoryMutation(c config, op Op, opts ...leadstatushistoryOption) *LeadStatusHistoryMutation {
	m := &LeadStatusHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeLeadStatusHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeadStatusHistoryID sets the ID field of the mutation.
func withLeadStatusHistoryID(id int) leadstatushistoryOption {
	return func(m *LeadStatusHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *LeadStatusHistory
		)
		m.oldValue = func(ctx context.Context) (*LeadStatusHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LeadStatusHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLeadStatusHistory sets the old LeadStatusHistory of the mutation.
func withLeadStatusHistory(node *LeadStatusHistory) leadstatushistoryOption {
	return func(m *LeadStatusHistoryMutation) {
		m.oldValue = func(context.Context) (*LeadStatusHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeadStatusHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeadStatusHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeadStatusHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeadStatusHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LeadStatusHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLeadID sets the "lead_id" field.
func (m *LeadStatusHistoryMutation) SetLeadID(i int) {
	m.lead = &i
}

// LeadID returns the value of the "lead_id" field in the mutation.
func (m *LeadStatusHistoryMutation) LeadID() (r int, exists bool) {
	v := m.lead
	if v == nil {
		return
	}
	return *v, true
}

// OldLeadID returns the old "lead_id" field's value of the LeadStatusHistory entity.
// If the LeadStatusHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadStatusHistoryMutation) OldLeadID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeadID: %w", err)
	}
	return oldValue.LeadID, nil
}

// ResetLeadID resets all changes to the "lead_id" field.
func (m *LeadStatusHistoryMutation) ResetLeadID() {
	m.lead = nil
}

// SetUserID sets the "user_id" field.
func (m *LeadStatusHistoryMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LeadStatusHistoryMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LeadStatusHistory entity.
// If the LeadStatusHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadStatusHistoryMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LeadStatusHistoryMutation) ResetUserID() {
	m.user = nil
}

// SetOldStatus sets the "old_status" field.
func (m *LeadStatusHistoryMutation) SetOldStatus(ls leadstatushistory.OldStatus) {
	m.old_status = &ls
}

// OldStatus returns the value of the "old_status" field in the mutation.
func (m *LeadStatusHistoryMutation) OldStatus() (r leadstatushistory.OldStatus, exists bool) {
	v := m.old_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOldStatus returns the old "old_status" field's value of the LeadStatusHistory entity.
// If the LeadStatusHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadStatusHistoryMutation) OldOldStatus(ctx context.Context) (v *leadstatushistory.OldStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldStatus: %w", err)
	}
	return oldValue.OldStatus, nil
}

// ClearOldStatus clears the value of the "old_status" field.
func (m *LeadStatusHistoryMutation) ClearOldStatus() {
	m.old_status = nil
	m.clearedFields[leadstatushistory.FieldOldStatus] = struct{}{}
}

// OldStatusCleared returns if the "old_status" field was cleared in this mutation.
func (m *LeadStatusHistoryMutation) OldStatusCleared() bool {
	_, ok := m.clearedFields[leadstatushistory.FieldOldStatus]
	return ok
}

// ResetOldStatus resets all changes to the "old_status" field.
func (m *LeadStatusHistoryMutation) ResetOldStatus() {
	m.old_status = nil
	delete(m.clearedFields, leadstatushistory.FieldOldStatus)
}

// SetNewStatus sets the "new_status" field.
func (m *LeadStatusHistoryMutation) SetNewStatus(ls leadstatushistory.NewStatus) {
	m.new_status = &ls
}

// NewStatus returns the value of the "new_status" field in the mutation.
func (m *LeadStatusHistoryMutation) NewStatus() (r leadstatushistory.NewStatus, exists bool) {
	v := m.new_status
	if v == nil {
		return
	}
	return *v, true
}

// OldNewStatus returns the old "new_status" field's value of the LeadStatusHistory entity.
// If the LeadStatusHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadStatusHistoryMutation) OldNewStatus(ctx context.Context) (v leadstatushistory.NewStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewStatus: %w", err)
	}
	return oldValue.NewStatus, nil
}

// ResetNewStatus resets all changes to the "new_status" field.
func (m *LeadStatusHistoryMutation) ResetNewStatus() {
	m.new_status = nil
}

// SetReason sets the "reason" field.
func (m *LeadStatusHistoryMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *LeadStatusHistoryMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the LeadStatusHistory entity.
// If the LeadStatusHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadStatusHistoryMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *LeadStatusHistoryMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[leadstatushistory.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *LeadStatusHistoryMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[leadstatushistory.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *LeadStatusHistoryMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, leadstatushistory.FieldReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *LeadStatusHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LeadStatusHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LeadStatusHistory entity.
// If the LeadStatusHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadStatusHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LeadStatusHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearLead clears the "lead" edge to the Lead entity.
func (m *LeadStatusHistoryMutation) ClearLead() {
	m.clearedlead = true
	m.clearedFields[leadstatushistory.FieldLeadID] = struct{}{}
}

// LeadCleared reports if the "lead" edge to the Lead entity was cleared.
func (m *LeadStatusHistoryMutation) LeadCleared() bool {
	return m.clearedlead
}

// LeadIDs returns the "lead" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeadID instead. It exists only for internal usage by the builders.
func (m *LeadStatusHistoryMutation) LeadIDs() (ids []int) {
	if id := m.lead; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLead resets all changes to the "lead" edge.
func (m *LeadStatusHistoryMutation) ResetLead() {
	m.lead = nil
	m.clearedlead = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *LeadStatusHistoryMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[leadstatushistory.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LeadStatusHistoryMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LeadStatusHistoryMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LeadStatusHistoryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the LeadStatusHistoryMutation builder.
func (m *LeadStatusHistoryMutation) Where(ps ...predicate.LeadStatusHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeadStatusHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeadStatusHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LeadStatusHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeadStatusHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeadStatusHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LeadStatusHistory).
func (m *LeadStatusHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeadStatusHistoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.lead != nil {
		fields = append(fields, leadstatushistory.FieldLeadID)
	}
	if m.user != nil {
		fields = append(fields, leadstatushistory.FieldUserID)
	}
	if m.old_status != nil {
		fields = append(fields, leadstatushistory.FieldOldStatus)
	}
	if m.new_status != nil {
		fields = append(fields, leadstatushistory.FieldNewStatus)
	}
	if m.reason != nil {
		fields = append(fields, leadstatushistory.FieldReason)
	}
	if m.created_at != nil {
		fields = append(fields, leadstatushistory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeadStatusHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case leadstatushistory.FieldLeadID:
		return m.LeadID()
	case leadstatushistory.FieldUserID:
		return m.UserID()
	case leadstatushistory.FieldOldStatus:
		return m.OldStatus()
	case leadstatushistory.FieldNewStatus:
		return m.NewStatus()
	case leadstatushistory.FieldReason:
		return m.Reason()
	case leadstatushistory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeadStatusHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case leadstatushistory.FieldLeadID:
		return m.OldLeadID(ctx)
	case leadstatushistory.FieldUserID:
		return m.OldUserID(ctx)
	case leadstatushistory.FieldOldStatus:
		return m.OldOldStatus(ctx)
	case leadstatushistory.FieldNewStatus:
		return m.OldNewStatus(ctx)
	case leadstatushistory.FieldReason:
		return m.OldReason(ctx)
	case leadstatushistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LeadStatusHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadStatusHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case leadstatushistory.FieldLeadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeadID(v)
		return nil
	case leadstatushistory.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case leadstatushistory.FieldOldStatus:
		v, ok := value.(leadstatushistory.OldStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldStatus(v)
		return nil
	case leadstatushistory.FieldNewStatus:
		v, ok := value.(leadstatushistory.NewStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewStatus(v)
		return nil
	case leadstatushistory.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case leadstatushistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LeadStatusHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeadStatusHistoryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeadStatusHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadStatusHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LeadStatusHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeadStatusHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(leadstatushistory.FieldOldStatus) {
		fields = append(fields, leadstatushistory.FieldOldStatus)
	}
	if m.FieldCleared(leadstatushistory.FieldReason) {
		fields = append(fields, leadstatushistory.FieldReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeadStatusHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeadStatusHistoryMutation) ClearField(name string) error {
	switch name {
	case leadstatushistory.FieldOldStatus:
		m.ClearOldStatus()
		return nil
	case leadstatushistory.FieldReason:
		m.ClearReason()
		return nil
	}
	return fmt.Errorf("unknown LeadStatusHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeadStatusHistoryMutation) ResetField(name string) error {
	switch name {
	case leadstatushistory.FieldLeadID:
		m.ResetLeadID()
		return nil
	case leadstatushistory.FieldUserID:
		m.ResetUserID()
		return nil
	case leadstatushistory.FieldOldStatus:
		m.ResetOldStatus()
		return nil
	case leadstatushistory.FieldNewStatus:
		m.ResetNewStatus()
		return nil
	case leadstatushistory.FieldReason:
		m.ResetReason()
		return nil
	case leadstatushistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown LeadStatusHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeadStatusHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.lead != nil {
		edges = append(edges, leadstatushistory.EdgeLead)
	}
	if m.user != nil {
		edges = append(edges, leadstatushistory.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeadStatusHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case leadstatushistory.EdgeLead:
		if id := m.lead; id != nil {
			return []ent.Value{*id}
		}
	case leadstatushistory.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeadStatusHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeadStatusHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeadStatusHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlead {
		edges = append(edges, leadstatushistory.EdgeLead)
	}
	if m.cleareduser {
		edges = append(edges, leadstatushistory.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeadStatusHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case leadstatushistory.EdgeLead:
		return m.clearedlead
	case leadstatushistory.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeadStatusHistoryMutation) ClearEdge(name string) error {
	switch name {
	case leadstatushistory.EdgeLead:
		m.ClearLead()
		return nil
	case leadstatushistory.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown LeadStatusHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeadStatusHistoryMutation) ResetEdge(name string) error {
	switch name {
	case leadstatushistory.EdgeLead:
		m.ResetLead()
		return nil
	case leadstatushistory.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown LeadStatusHistory edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	slug               *string
	subscription_tier  *organization.SubscriptionTier
	usage_limit        *int
	addusage_limit     *int
	usage_count        *int
	addusage_count     *int
	last_reset_at      *time.Time
	stripe_customer_id *string
	billing_email      *string
	active             *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	owner              *int
	clearedowner       bool
	members            map[int]struct{}
	removedmembers     map[int]struct{}
	clearedmembers     bool
	exports            map[int]struct{}
	removedexports     map[int]struct{}
	clearedexports     bool
	done               bool
	oldValue           func(context.Context) (*Organization, error)
	predicates         []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *OrganizationMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *OrganizationMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *OrganizationMutation) ResetSlug() {
	m.slug = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *OrganizationMutation) SetOwnerID(i int) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *OrganizationMutation) OwnerID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *OrganizationMutation) ResetOwnerID() {
	m.owner = nil
}

// SetSubscriptionTier sets the "subscription_tier" field.
func (m *OrganizationMutation) SetSubscriptionTier(ot organization.SubscriptionTier) {
	m.subscription_tier = &ot
}

// SubscriptionTier returns the value of the "subscription_tier" field in the mutation.
func (m *OrganizationMutation) SubscriptionTier() (r organization.SubscriptionTier, exists bool) {
	v := m.subscription_tier
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionTier returns the old "subscription_tier" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSubscriptionTier(ctx context.Context) (v organization.SubscriptionTier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionTier: %w", err)
	}
	return oldValue.SubscriptionTier, nil
}

// ResetSubscriptionTier resets all changes to the "subscription_tier" field.
func (m *OrganizationMutation) ResetSubscriptionTier() {
	m.subscription_tier = nil
}

// SetUsageLimit sets the "usage_limit" field.
func (m *OrganizationMutation) SetUsageLimit(i int) {
	m.usage_limit = &i
	m.addusage_limit = nil
}

// UsageLimit returns the value of the "usage_limit" field in the mutation.
func (m *OrganizationMutation) UsageLimit() (r int, exists bool) {
	v := m.usage_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageLimit returns the old "usage_limit" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUsageLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageLimit: %w", err)
	}
	return oldValue.UsageLimit, nil
}

// AddUsageLimit adds i to the "usage_limit" field.
func (m *OrganizationMutation) AddUsageLimit(i int) {
	if m.addusage_limit != nil {
		*m.addusage_limit += i
	} else {
		m.addusage_limit = &i
	}
}

// AddedUsageLimit returns the value that was added to the "usage_limit" field in this mutation.
func (m *OrganizationMutation) AddedUsageLimit() (r int, exists bool) {
	v := m.addusage_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageLimit resets all changes to the "usage_limit" field.
func (m *OrganizationMutation) ResetUsageLimit() {
	m.usage_limit = nil
	m.addusage_limit = nil
}

// SetUsageCount sets the "usage_count" field.
func (m *OrganizationMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *OrganizationMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *OrganizationMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *OrganizationMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *OrganizationMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetLastResetAt sets the "last_reset_at" field.
func (m *OrganizationMutation) SetLastResetAt(t time.Time) {
	m.last_reset_at = &t
}

// LastResetAt returns the value of the "last_reset_at" field in the mutation.
func (m *OrganizationMutation) LastResetAt() (r time.Time, exists bool) {
	v := m.last_reset_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastResetAt returns the old "last_reset_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLastResetAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastResetAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastResetAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastResetAt: %w", err)
	}
	return oldValue.LastResetAt, nil
}

// ResetLastResetAt resets all changes to the "last_reset_at" field.
func (m *OrganizationMutation) ResetLastResetAt() {
	m.last_reset_at = nil
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *OrganizationMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *OrganizationMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldStripeCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (m *OrganizationMutation) ClearStripeCustomerID() {
	m.stripe_customer_id = nil
	m.clearedFields[organization.FieldStripeCustomerID] = struct{}{}
}

// StripeCustomerIDCleared returns if the "stripe_customer_id" field was cleared in this mutation.
func (m *OrganizationMutation) StripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldStripeCustomerID]
	return ok
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *OrganizationMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
	delete(m.clearedFields, organization.FieldStripeCustomerID)
}

// SetBillingEmail sets the "billing_email" field.
func (m *OrganizationMutation) SetBillingEmail(s string) {
	m.billing_email = &s
}

// BillingEmail returns the value of the "billing_email" field in the mutation.
func (m *OrganizationMutation) BillingEmail() (r string, exists bool) {
	v := m.billing_email
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingEmail returns the old "billing_email" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldBillingEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingEmail: %w", err)
	}
	return oldValue.BillingEmail, nil
}

// ClearBillingEmail clears the value of the "billing_email" field.
func (m *OrganizationMutation) ClearBillingEmail() {
	m.billing_email = nil
	m.clearedFields[organization.FieldBillingEmail] = struct{}{}
}

// BillingEmailCleared returns if the "billing_email" field was cleared in this mutation.
func (m *OrganizationMutation) BillingEmailCleared() bool {
	_, ok := m.clearedFields[organization.FieldBillingEmail]
	return ok
}

// ResetBillingEmail resets all changes to the "billing_email" field.
func (m *OrganizationMutation) ResetBillingEmail() {
	m.billing_email = nil
	delete(m.clearedFields, organization.FieldBillingEmail)
}

// SetActive sets the "active" field.
func (m *OrganizationMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *OrganizationMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *OrganizationMutation) ResetActive() {
	m.active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *OrganizationMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[organization.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *OrganizationMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *OrganizationMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddMemberIDs adds the "members" edge to the OrganizationMember entity by ids.
func (m *OrganizationMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the OrganizationMember entity.
func (m *OrganizationMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the OrganizationMember entity was cleared.
func (m *OrganizationMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the OrganizationMember entity by IDs.
func (m *OrganizationMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the OrganizationMember entity.
func (m *OrganizationMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *OrganizationMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *OrganizationMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddExportIDs adds the "exports" edge to the Export entity by ids.
func (m *OrganizationMutation) AddExportIDs(ids ...int) {
	if m.exports == nil {
		m.exports = make(map[int]struct{})
	}
	for i := range ids {
		m.exports[ids[i]] = struct{}{}
	}
}

// ClearExports clears the "exports" edge to the Export entity.
func (m *OrganizationMutation) ClearExports() {
	m.clearedexports = true
}

// ExportsCleared reports if the "exports" edge to the Export entity was cleared.
func (m *OrganizationMutation) ExportsCleared() bool {
	return m.clearedexports
}

// RemoveExportIDs removes the "exports" edge to the Export entity by IDs.
func (m *OrganizationMutation) RemoveExportIDs(ids ...int) {
	if m.removedexports == nil {
		m.removedexports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.exports, ids[i])
		m.removedexports[ids[i]] = struct{}{}
	}
}

// RemovedExports returns the removed IDs of the "exports" edge to the Export entity.
func (m *OrganizationMutation) RemovedExportsIDs() (ids []int) {
	for id := range m.removedexports {
		ids = append(ids, id)
	}
	return
}

// ExportsIDs returns the "exports" edge IDs in the mutation.
func (m *OrganizationMutation) ExportsIDs() (ids []int) {
	for id := range m.exports {
		ids = append(ids, id)
	}
	return
}

// ResetExports resets all changes to the "exports" edge.
func (m *OrganizationMutation) ResetExports() {
	m.exports = nil
	m.clearedexports = false
	m.removedexports = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, organization.FieldSlug)
	}
	if m.owner != nil {
		fields = append(fields, organization.FieldOwnerID)
	}
	if m.subscription_tier != nil {
		fields = append(fields, organization.FieldSubscriptionTier)
	}
	if m.usage_limit != nil {
		fields = append(fields, organization.FieldUsageLimit)
	}
	if m.usage_count != nil {
		fields = append(fields, organization.FieldUsageCount)
	}
	if m.last_reset_at != nil {
		fields = append(fields, organization.FieldLastResetAt)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, organization.FieldStripeCustomerID)
	}
	if m.billing_email != nil {
		fields = append(fields, organization.FieldBillingEmail)
	}
	if m.active != nil {
		fields = append(fields, organization.FieldActive)
	}
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldName:
		return m.Name()
	case organization.FieldSlug:
		return m.Slug()
	case organization.FieldOwnerID:
		return m.OwnerID()
	case organization.FieldSubscriptionTier:
		return m.SubscriptionTier()
	case organization.FieldUsageLimit:
		return m.UsageLimit()
	case organization.FieldUsageCount:
		return m.UsageCount()
	case organization.FieldLastResetAt:
		return m.LastResetAt()
	case organization.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case organization.FieldBillingEmail:
		return m.BillingEmail()
	case organization.FieldActive:
		return m.Active()
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldSlug:
		return m.OldSlug(ctx)
	case organization.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case organization.FieldSubscriptionTier:
		return m.OldSubscriptionTier(ctx)
	case organization.FieldUsageLimit:
		return m.OldUsageLimit(ctx)
	case organization.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case organization.FieldLastResetAt:
		return m.OldLastResetAt(ctx)
	case organization.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case organization.FieldBillingEmail:
		return m.OldBillingEmail(ctx)
	case organization.FieldActive:
		return m.OldActive(ctx)
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case organization.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case organization.FieldSubscriptionTier:
		v, ok := value.(organization.SubscriptionTier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionTier(v)
		return nil
	case organization.FieldUsageLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageLimit(v)
		return nil
	case organization.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case organization.FieldLastResetAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastResetAt(v)
		return nil
	case organization.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case organization.FieldBillingEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingEmail(v)
		return nil
	case organization.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	var fields []string
	if m.addusage_limit != nil {
		fields = append(fields, organization.FieldUsageLimit)
	}
	if m.addusage_count != nil {
		fields = append(fields, organization.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldUsageLimit:
		return m.AddedUsageLimit()
	case organization.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organization.FieldUsageLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageLimit(v)
		return nil
	case organization.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldStripeCustomerID) {
		fields = append(fields, organization.FieldStripeCustomerID)
	}
	if m.FieldCleared(organization.FieldBillingEmail) {
		fields = append(fields, organization.FieldBillingEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldStripeCustomerID:
		m.ClearStripeCustomerID()
		return nil
	case organization.FieldBillingEmail:
		m.ClearBillingEmail()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldSlug:
		m.ResetSlug()
		return nil
	case organization.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case organization.FieldSubscriptionTier:
		m.ResetSubscriptionTier()
		return nil
	case organization.FieldUsageLimit:
		m.ResetUsageLimit()
		return nil
	case organization.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case organization.FieldLastResetAt:
		m.ResetLastResetAt()
		return nil
	case organization.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case organization.FieldBillingEmail:
		m.ResetBillingEmail()
		return nil
	case organization.FieldActive:
		m.ResetActive()
		return nil
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, organization.EdgeOwner)
	}
	if m.members != nil {
		edges = append(edges, organization.EdgeMembers)
	}
	if m.exports != nil {
		edges = append(edges, organization.EdgeExports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeExports:
		ids := make([]ent.Value, 0, len(m.exports))
		for id := range m.exports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmembers != nil {
		edges = append(edges, organization.EdgeMembers)
	}
	if m.removedexports != nil {
		edges = append(edges, organization.EdgeExports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeExports:
		ids := make([]ent.Value, 0, len(m.removedexports))
		for id := range m.removedexports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, organization.EdgeOwner)
	}
	if m.clearedmembers {
		edges = append(edges, organization.EdgeMembers)
	}
	if m.clearedexports {
		edges = append(edges, organization.EdgeExports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeOwner:
		return m.clearedowner
	case organization.EdgeMembers:
		return m.clearedmembers
	case organization.EdgeExports:
		return m.clearedexports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeOwner:
		m.ResetOwner()
		return nil
	case organization.EdgeMembers:
		m.ResetMembers()
		return nil
	case organization.EdgeExports:
		m.ResetExports()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationMemberMutation represents an operation that mutates the OrganizationMember nodes in the graph.
type OrganizationMemberMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	role                *organizationmember.Role
	invited_by_email    *string
	status              *organizationmember.Status
	invited_at          *time.Time
	joined_at           *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	user                *int
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*OrganizationMember, error)
	predicates          []predicate.OrganizationMember
}

var _ ent.Mutation = (*OrganizationMemberMutation)(nil)

// organizationmemberOption allows management of the mutation configuration using functional options.
type organizationmemberOption func(*OrganizationMemberMutation)

// newOrganizationMemberMutation creates new mutation for the OrganizationMember entity.
func newOrganizationMemberMutation(c config, op Op, opts ...organizationmemberOption) *OrganizationMemberMutation {
	m := &OrganizationMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationMemberID sets the ID field of the mutation.
func withOrganizationMemberID(id int) organizationmemberOption {
	return func(m *OrganizationMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationMember
		)
		m.oldValue = func(ctx context.Context) (*OrganizationMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationMember sets the old OrganizationMember of the mutation.
func withOrganizationMember(node *OrganizationMember) organizationmemberOption {
	return func(m *OrganizationMemberMutation) {
		m.oldValue = func(context.Context) (*OrganizationMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationMemberMutation) SetOrganizationID(i int) {
	m.organization = &i
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationMemberMutation) OrganizationID() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldOrganizationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationMemberMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetUserID sets the "user_id" field.
func (m *OrganizationMemberMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrganizationMemberMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrganizationMemberMutation) ResetUserID() {
	m.user = nil
}

// SetRole sets the "role" field.
func (m *OrganizationMemberMutation) SetRole(o organizationmember.Role) {
	m.role = &o
}

// Role returns the value of the "role" field in the mutation.
func (m *OrganizationMemberMutation) Role() (r organizationmember.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldRole(ctx context.Context) (v organizationmember.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *OrganizationMemberMutation) ResetRole() {
	m.role = nil
}

// SetInvitedByEmail sets the "invited_by_email" field.
func (m *OrganizationMemberMutation) SetInvitedByEmail(s string) {
	m.invited_by_email = &s
}

// InvitedByEmail returns the value of the "invited_by_email" field in the mutation.
func (m *OrganizationMemberMutation) InvitedByEmail() (r string, exists bool) {
	v := m.invited_by_email
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitedByEmail returns the old "invited_by_email" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldInvitedByEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitedByEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitedByEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitedByEmail: %w", err)
	}
	return oldValue.InvitedByEmail, nil
}

// ClearInvitedByEmail clears the value of the "invited_by_email" field.
func (m *OrganizationMemberMutation) ClearInvitedByEmail() {
	m.invited_by_email = nil
	m.clearedFields[organizationmember.FieldInvitedByEmail] = struct{}{}
}

// InvitedByEmailCleared returns if the "invited_by_email" field was cleared in this mutation.
func (m *OrganizationMemberMutation) InvitedByEmailCleared() bool {
	_, ok := m.clearedFields[organizationmember.FieldInvitedByEmail]
	return ok
}

// ResetInvitedByEmail resets all changes to the "invited_by_email" field.
func (m *OrganizationMemberMutation) ResetInvitedByEmail() {
	m.invited_by_email = nil
	delete(m.clearedFields, organizationmember.FieldInvitedByEmail)
}

// SetStatus sets the "status" field.
func (m *OrganizationMemberMutation) SetStatus(o organizationmember.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrganizationMemberMutation) Status() (r organizationmember.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldStatus(ctx context.Context) (v organizationmember.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrganizationMemberMutation) ResetStatus() {
	m.status = nil
}

// SetInvitedAt sets the "invited_at" field.
func (m *OrganizationMemberMutation) SetInvitedAt(t time.Time) {
	m.invited_at = &t
}

// InvitedAt returns the value of the "invited_at" field in the mutation.
func (m *OrganizationMemberMutation) InvitedAt() (r time.Time, exists bool) {
	v := m.invited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitedAt returns the old "invited_at" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldInvitedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitedAt: %w", err)
	}
	return oldValue.InvitedAt, nil
}

// ClearInvitedAt clears the value of the "invited_at" field.
func (m *OrganizationMemberMutation) ClearInvitedAt() {
	m.invited_at = nil
	m.clearedFields[organizationmember.FieldInvitedAt] = struct{}{}
}

// InvitedAtCleared returns if the "invited_at" field was cleared in this mutation.
func (m *OrganizationMemberMutation) InvitedAtCleared() bool {
	_, ok := m.clearedFields[organizationmember.FieldInvitedAt]
	return ok
}

// ResetInvitedAt resets all changes to the "invited_at" field.
func (m *OrganizationMemberMutation) ResetInvitedAt() {
	m.invited_at = nil
	delete(m.clearedFields, organizationmember.FieldInvitedAt)
}

// SetJoinedAt sets the "joined_at" field.
func (m *OrganizationMemberMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *OrganizationMemberMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *OrganizationMemberMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationMemberMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[organizationmember.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationMemberMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationMemberMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationMemberMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrganizationMemberMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[organizationmember.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrganizationMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrganizationMemberMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrganizationMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OrganizationMemberMutation builder.
func (m *OrganizationMemberMutation) Where(ps ...predicate.OrganizationMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationMember).
func (m *OrganizationMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMemberMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.organization != nil {
		fields = append(fields, organizationmember.FieldOrganizationID)
	}
	if m.user != nil {
		fields = append(fields, organizationmember.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, organizationmember.FieldRole)
	}
	if m.invited_by_email != nil {
		fields = append(fields, organizationmember.FieldInvitedByEmail)
	}
	if m.status != nil {
		fields = append(fields, organizationmember.FieldStatus)
	}
	if m.invited_at != nil {
		fields = append(fields, organizationmember.FieldInvitedAt)
	}
	if m.joined_at != nil {
		fields = append(fields, organizationmember.FieldJoinedAt)
	}
	if m.created_at != nil {
		fields = append(fields, organizationmember.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationmember.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationmember.FieldOrganizationID:
		return m.OrganizationID()
	case organizationmember.FieldUserID:
		return m.UserID()
	case organizationmember.FieldRole:
		return m.Role()
	case organizationmember.FieldInvitedByEmail:
		return m.InvitedByEmail()
	case organizationmember.FieldStatus:
		return m.Status()
	case organizationmember.FieldInvitedAt:
		return m.InvitedAt()
	case organizationmember.FieldJoinedAt:
		return m.JoinedAt()
	case organizationmember.FieldCreatedAt:
		return m.CreatedAt()
	case organizationmember.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationmember.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case organizationmember.FieldUserID:
		return m.OldUserID(ctx)
	case organizationmember.FieldRole:
		return m.OldRole(ctx)
	case organizationmember.FieldInvitedByEmail:
		return m.OldInvitedByEmail(ctx)
	case organizationmember.FieldStatus:
		return m.OldStatus(ctx)
	case organizationmember.FieldInvitedAt:
		return m.OldInvitedAt(ctx)
	case organizationmember.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case organizationmember.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationmember.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationmember.FieldOrganizationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case organizationmember.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case organizationmember.FieldRole:
		v, ok := value.(organizationmember.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case organizationmember.FieldInvitedByEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitedByEmail(v)
		return nil
	case organizationmember.FieldStatus:
		v, ok := value.(organizationmember.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case organizationmember.FieldInvitedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitedAt(v)
		return nil
	case organizationmember.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case organizationmember.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationmember.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMemberMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationmember.FieldInvitedByEmail) {
		fields = append(fields, organizationmember.FieldInvitedByEmail)
	}
	if m.FieldCleared(organizationmember.FieldInvitedAt) {
		fields = append(fields, organizationmember.FieldInvitedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMemberMutation) ClearField(name string) error {
	switch name {
	case organizationmember.FieldInvitedByEmail:
		m.ClearInvitedByEmail()
		return nil
	case organizationmember.FieldInvitedAt:
		m.ClearInvitedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMemberMutation) ResetField(name string) error {
	switch name {
	case organizationmember.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case organizationmember.FieldUserID:
		m.ResetUserID()
		return nil
	case organizationmember.FieldRole:
		m.ResetRole()
		return nil
	case organizationmember.FieldInvitedByEmail:
		m.ResetInvitedByEmail()
		return nil
	case organizationmember.FieldStatus:
		m.ResetStatus()
		return nil
	case organizationmember.FieldInvitedAt:
		m.ResetInvitedAt()
		return nil
	case organizationmember.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case organizationmember.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationmember.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, organizationmember.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, organizationmember.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationmember.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case organizationmember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, organizationmember.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, organizationmember.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationmember.EdgeOrganization:
		return m.clearedorganization
	case organizationmember.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMemberMutation) ClearEdge(name string) error {
	switch name {
	case organizationmember.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case organizationmember.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMemberMutation) ResetEdge(name string) error {
	switch name {
	case organizationmember.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case organizationmember.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember edge %s", name)
}

// SavedSearchMutation represents an operation that mutates the SavedSearch nodes in the graph.
type SavedSearchMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	filters       *map[string]interface{}
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*SavedSearch, error)
	predicates    []predicate.SavedSearch
}

var _ ent.Mutation = (*SavedSearchMutation)(nil)

// savedsearchOption allows management of the mutation configuration using functional options.
type savedsearchOption func(*SavedSearchMutation)

// newSavedSearchMutation creates new mutation for the SavedSearch entity.
func newSavedSearchMutation(c config, op Op, opts ...savedsearchOption) *SavedSearchMutation {
	m := &SavedSearchMutation{
		config:        c,
		op:            op,
		typ:           TypeSavedSearch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSavedSearchID sets the ID field of the mutation.
func withSavedSearchID(id int) savedsearchOption {
	return func(m *SavedSearchMutation) {
		var (
			err   error
			once  sync.Once
			value *SavedSearch
		)
		m.oldValue = func(ctx context.Context) (*SavedSearch, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SavedSearch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSavedSearch sets the old SavedSearch of the mutation.
func withSavedSearch(node *SavedSearch) savedsearchOption {
	return func(m *SavedSearchMutation) {
		m.oldValue = func(context.Context) (*SavedSearch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SavedSearchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SavedSearchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SavedSearchMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SavedSearchMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SavedSearch.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SavedSearchMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SavedSearchMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SavedSearch entity.
// If the SavedSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SavedSearchMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SavedSearchMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *SavedSearchMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SavedSearchMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SavedSearch entity.
// If the SavedSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SavedSearchMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SavedSearchMutation) ResetName() {
	m.name = nil
}

// SetFilters sets the "filters" field.
func (m *SavedSearchMutation) SetFilters(value map[string]interface{}) {
	m.filters = &value
}

// Filters returns the value of the "filters" field in the mutation.
func (m *SavedSearchMutation) Filters() (r map[string]interface{}, exists bool) {
	v := m.filters
	if v == nil {
		return
	}
	return *v, true
}

// OldFilters returns the old "filters" field's value of the SavedSearch entity.
// If the SavedSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SavedSearchMutation) OldFilters(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilters: %w", err)
	}
	return oldValue.Filters, nil
}

// ResetFilters resets all changes to the "filters" field.
func (m *SavedSearchMutation) ResetFilters() {
	m.filters = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SavedSearchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SavedSearchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SavedSearch entity.
// If the SavedSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SavedSearchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SavedSearchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SavedSearchMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SavedSearchMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SavedSearch entity.
// If the SavedSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SavedSearchMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SavedSearchMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SavedSearchMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[savedsearch.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SavedSearchMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SavedSearchMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SavedSearchMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SavedSearchMutation builder.
func (m *SavedSearchMutation) Where(ps ...predicate.SavedSearch) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SavedSearchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SavedSearchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SavedSearch, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SavedSearchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SavedSearchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SavedSearch).
func (m *SavedSearchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SavedSearchMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, savedsearch.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, savedsearch.FieldName)
	}
	if m.filters != nil {
		fields = append(fields, savedsearch.FieldFilters)
	}
	if m.created_at != nil {
		fields = append(fields, savedsearch.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, savedsearch.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SavedSearchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case savedsearch.FieldUserID:
		return m.UserID()
	case savedsearch.FieldName:
		return m.Name()
	case savedsearch.FieldFilters:
		return m.Filters()
	case savedsearch.FieldCreatedAt:
		return m.CreatedAt()
	case savedsearch.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SavedSearchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case savedsearch.FieldUserID:
		return m.OldUserID(ctx)
	case savedsearch.FieldName:
		return m.OldName(ctx)
	case savedsearch.FieldFilters:
		return m.OldFilters(ctx)
	case savedsearch.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case savedsearch.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SavedSearch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SavedSearchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case savedsearch.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case savedsearch.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case savedsearch.FieldFilters:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilters(v)
		return nil
	case savedsearch.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case savedsearch.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SavedSearch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SavedSearchMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SavedSearchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SavedSearchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SavedSearch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SavedSearchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SavedSearchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SavedSearchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SavedSearch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SavedSearchMutation) ResetField(name string) error {
	switch name {
	case savedsearch.FieldUserID:
		m.ResetUserID()
		return nil
	case savedsearch.FieldName:
		m.ResetName()
		return nil
	case savedsearch.FieldFilters:
		m.ResetFilters()
		return nil
	case savedsearch.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case savedsearch.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SavedSearch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SavedSearchMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, savedsearch.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SavedSearchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case savedsearch.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SavedSearchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SavedSearchMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SavedSearchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, savedsearch.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SavedSearchMutation) EdgeCleared(name string) bool {
	switch name {
	case savedsearch.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SavedSearchMutation) ClearEdge(name string) error {
	switch name {
	case savedsearch.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown SavedSearch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SavedSearchMutation) ResetEdge(name string) error {
	switch name {
	case savedsearch.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown SavedSearch edge %s", name)
}

// SubscriptionMutation represents an operation that mutates the Subscription nodes in the graph.
type SubscriptionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	tier                   *subscription.Tier
	status                 *subscription.Status
	stripe_subscription_id *string
	stripe_price_id        *string
	current_period_start   *time.Time
	current_period_end     *time.Time
	cancel_at_period_end   *bool
	canceled_at            *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	user                   *int
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*Subscription, error)
	predicates             []predicate.Subscription
}

var _ ent.Mutation = (*SubscriptionMutation)(nil)

// subscriptionOption allows management of the mutation configuration using functional options.
type subscriptionOption func(*SubscriptionMutation)

// newSubscriptionMutation creates new mutation for the Subscription entity.
func newSubscriptionMutation(c config, op Op, opts ...subscriptionOption) *SubscriptionMutation {
	m := &SubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionID sets the ID field of the mutation.
func withSubscriptionID(id int) subscriptionOption {
	return func(m *SubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscription
		)
		m.oldValue = func(ctx context.Context) (*Subscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscription sets the old Subscription of the mutation.
func withSubscription(node *Subscription) subscriptionOption {
	return func(m *SubscriptionMutation) {
		m.oldValue = func(context.Context) (*Subscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SubscriptionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SubscriptionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SubscriptionMutation) ResetUserID() {
	m.user = nil
}

// SetTier sets the "tier" field.
func (m *SubscriptionMutation) SetTier(s subscription.Tier) {
	m.tier = &s
}

// Tier returns the value of the "tier" field in the mutation.
func (m *SubscriptionMutation) Tier() (r subscription.Tier, exists bool) {
	v := m.tier
	if v == nil {
		return
	}
	return *v, true
}

// OldTier returns the old "tier" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldTier(ctx context.Context) (v subscription.Tier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTier: %w", err)
	}
	return oldValue.Tier, nil
}

// ResetTier resets all changes to the "tier" field.
func (m *SubscriptionMutation) ResetTier() {
	m.tier = nil
}

// SetStatus sets the "status" field.
func (m *SubscriptionMutation) SetStatus(s subscription.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SubscriptionMutation) Status() (r subscription.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldStatus(ctx context.Context) (v subscription.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SubscriptionMutation) ResetStatus() {
	m.status = nil
}

// SetStripeSubscriptionID sets the "stripe_subscription_id" field.
func (m *SubscriptionMutation) SetStripeSubscriptionID(s string) {
	m.stripe_subscription_id = &s
}

// StripeSubscriptionID returns the value of the "stripe_subscription_id" field in the mutation.
func (m *SubscriptionMutation) StripeSubscriptionID() (r string, exists bool) {
	v := m.stripe_subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeSubscriptionID returns the old "stripe_subscription_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldStripeSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeSubscriptionID: %w", err)
	}
	return oldValue.StripeSubscriptionID, nil
}

// ClearStripeSubscriptionID clears the value of the "stripe_subscription_id" field.
func (m *SubscriptionMutation) ClearStripeSubscriptionID() {
	m.stripe_subscription_id = nil
	m.clearedFields[subscription.FieldStripeSubscriptionID] = struct{}{}
}

// StripeSubscriptionIDCleared returns if the "stripe_subscription_id" field was cleared in this mutation.
func (m *SubscriptionMutation) StripeSubscriptionIDCleared() bool {
	_, ok := m.clearedFields[subscription.FieldStripeSubscriptionID]
	return ok
}

// ResetStripeSubscriptionID resets all changes to the "stripe_subscription_id" field.
func (m *SubscriptionMutation) ResetStripeSubscriptionID() {
	m.stripe_subscription_id = nil
	delete(m.clearedFields, subscription.FieldStripeSubscriptionID)
}

// SetStripePriceID sets the "stripe_price_id" field.
func (m *SubscriptionMutation) SetStripePriceID(s string) {
	m.stripe_price_id = &s
}

// StripePriceID returns the value of the "stripe_price_id" field in the mutation.
func (m *SubscriptionMutation) StripePriceID() (r string, exists bool) {
	v := m.stripe_price_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripePriceID returns the old "stripe_price_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldStripePriceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripePriceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripePriceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripePriceID: %w", err)
	}
	return oldValue.StripePriceID, nil
}

// ClearStripePriceID clears the value of the "stripe_price_id" field.
func (m *SubscriptionMutation) ClearStripePriceID() {
	m.stripe_price_id = nil
	m.clearedFields[subscription.FieldStripePriceID] = struct{}{}
}

// StripePriceIDCleared returns if the "stripe_price_id" field was cleared in this mutation.
func (m *SubscriptionMutation) StripePriceIDCleared() bool {
	_, ok := m.clearedFields[subscription.FieldStripePriceID]
	return ok
}

// ResetStripePriceID resets all changes to the "stripe_price_id" field.
func (m *SubscriptionMutation) ResetStripePriceID() {
	m.stripe_price_id = nil
	delete(m.clearedFields, subscription.FieldStripePriceID)
}

// SetCurrentPeriodStart sets the "current_period_start" field.
func (m *SubscriptionMutation) SetCurrentPeriodStart(t time.Time) {
	m.current_period_start = &t
}

// CurrentPeriodStart returns the value of the "current_period_start" field in the mutation.
func (m *SubscriptionMutation) CurrentPeriodStart() (r time.Time, exists bool) {
	v := m.current_period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPeriodStart returns the old "current_period_start" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCurrentPeriodStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPeriodStart: %w", err)
	}
	return oldValue.CurrentPeriodStart, nil
}

// ClearCurrentPeriodStart clears the value of the "current_period_start" field.
func (m *SubscriptionMutation) ClearCurrentPeriodStart() {
	m.current_period_start = nil
	m.clearedFields[subscription.FieldCurrentPeriodStart] = struct{}{}
}

// CurrentPeriodStartCleared returns if the "current_period_start" field was cleared in this mutation.
func (m *SubscriptionMutation) CurrentPeriodStartCleared() bool {
	_, ok := m.clearedFields[subscription.FieldCurrentPeriodStart]
	return ok
}

// ResetCurrentPeriodStart resets all changes to the "current_period_start" field.
func (m *SubscriptionMutation) ResetCurrentPeriodStart() {
	m.current_period_start = nil
	delete(m.clearedFields, subscription.FieldCurrentPeriodStart)
}

// SetCurrentPeriodEnd sets the "current_period_end" field.
func (m *SubscriptionMutation) SetCurrentPeriodEnd(t time.Time) {
	m.current_period_end = &t
}

// CurrentPeriodEnd returns the value of the "current_period_end" field in the mutation.
func (m *SubscriptionMutation) CurrentPeriodEnd() (r time.Time, exists bool) {
	v := m.current_period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPeriodEnd returns the old "current_period_end" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCurrentPeriodEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPeriodEnd: %w", err)
	}
	return oldValue.CurrentPeriodEnd, nil
}

// ClearCurrentPeriodEnd clears the value of the "current_period_end" field.
func (m *SubscriptionMutation) ClearCurrentPeriodEnd() {
	m.current_period_end = nil
	m.clearedFields[subscription.FieldCurrentPeriodEnd] = struct{}{}
}

// CurrentPeriodEndCleared returns if the "current_period_end" field was cleared in this mutation.
func (m *SubscriptionMutation) CurrentPeriodEndCleared() bool {
	_, ok := m.clearedFields[subscription.FieldCurrentPeriodEnd]
	return ok
}

// ResetCurrentPeriodEnd resets all changes to the "current_period_end" field.
func (m *SubscriptionMutation) ResetCurrentPeriodEnd() {
	m.current_period_end = nil
	delete(m.clearedFields, subscription.FieldCurrentPeriodEnd)
}

// SetCancelAtPeriodEnd sets the "cancel_at_period_end" field.
func (m *SubscriptionMutation) SetCancelAtPeriodEnd(b bool) {
	m.cancel_at_period_end = &b
}

// CancelAtPeriodEnd returns the value of the "cancel_at_period_end" field in the mutation.
func (m *SubscriptionMutation) CancelAtPeriodEnd() (r bool, exists bool) {
	v := m.cancel_at_period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelAtPeriodEnd returns the old "cancel_at_period_end" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCancelAtPeriodEnd(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelAtPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelAtPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelAtPeriodEnd: %w", err)
	}
	return oldValue.CancelAtPeriodEnd, nil
}

// ResetCancelAtPeriodEnd resets all changes to the "cancel_at_period_end" field.
func (m *SubscriptionMutation) ResetCancelAtPeriodEnd() {
	m.cancel_at_period_end = nil
}

// SetCanceledAt sets the "canceled_at" field.
func (m *SubscriptionMutation) SetCanceledAt(t time.Time) {
	m.canceled_at = &t
}

// CanceledAt returns the value of the "canceled_at" field in the mutation.
func (m *SubscriptionMutation) CanceledAt() (r time.Time, exists bool) {
	v := m.canceled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCanceledAt returns the old "canceled_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCanceledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanceledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanceledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanceledAt: %w", err)
	}
	return oldValue.CanceledAt, nil
}

// ClearCanceledAt clears the value of the "canceled_at" field.
func (m *SubscriptionMutation) ClearCanceledAt() {
	m.canceled_at = nil
	m.clearedFields[subscription.FieldCanceledAt] = struct{}{}
}

// CanceledAtCleared returns if the "canceled_at" field was cleared in this mutation.
func (m *SubscriptionMutation) CanceledAtCleared() bool {
	_, ok := m.clearedFields[subscription.FieldCanceledAt]
	return ok
}

// ResetCanceledAt resets all changes to the "canceled_at" field.
func (m *SubscriptionMutation) ResetCanceledAt() {
	m.canceled_at = nil
	delete(m.clearedFields, subscription.FieldCanceledAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[subscription.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SubscriptionMutation builder.
func (m *SubscriptionMutation) Where(ps ...predicate.Subscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscription).
func (m *SubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, subscription.FieldUserID)
	}
	if m.tier != nil {
		fields = append(fields, subscription.FieldTier)
	}
	if m.status != nil {
		fields = append(fields, subscription.FieldStatus)
	}
	if m.stripe_subscription_id != nil {
		fields = append(fields, subscription.FieldStripeSubscriptionID)
	}
	if m.stripe_price_id != nil {
		fields = append(fields, subscription.FieldStripePriceID)
	}
	if m.current_period_start != nil {
		fields = append(fields, subscription.FieldCurrentPeriodStart)
	}
	if m.current_period_end != nil {
		fields = append(fields, subscription.FieldCurrentPeriodEnd)
	}
	if m.cancel_at_period_end != nil {
		fields = append(fields, subscription.FieldCancelAtPeriodEnd)
	}
	if m.canceled_at != nil {
		fields = append(fields, subscription.FieldCanceledAt)
	}
	if m.created_at != nil {
		fields = append(fields, subscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscription.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldUserID:
		return m.UserID()
	case subscription.FieldTier:
		return m.Tier()
	case subscription.FieldStatus:
		return m.Status()
	case subscription.FieldStripeSubscriptionID:
		return m.StripeSubscriptionID()
	case subscription.FieldStripePriceID:
		return m.StripePriceID()
	case subscription.FieldCurrentPeriodStart:
		return m.CurrentPeriodStart()
	case subscription.FieldCurrentPeriodEnd:
		return m.CurrentPeriodEnd()
	case subscription.FieldCancelAtPeriodEnd:
		return m.CancelAtPeriodEnd()
	case subscription.FieldCanceledAt:
		return m.CanceledAt()
	case subscription.FieldCreatedAt:
		return m.CreatedAt()
	case subscription.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscription.FieldUserID:
		return m.OldUserID(ctx)
	case subscription.FieldTier:
		return m.OldTier(ctx)
	case subscription.FieldStatus:
		return m.OldStatus(ctx)
	case subscription.FieldStripeSubscriptionID:
		return m.OldStripeSubscriptionID(ctx)
	case subscription.FieldStripePriceID:
		return m.OldStripePriceID(ctx)
	case subscription.FieldCurrentPeriodStart:
		return m.OldCurrentPeriodStart(ctx)
	case subscription.FieldCurrentPeriodEnd:
		return m.OldCurrentPeriodEnd(ctx)
	case subscription.FieldCancelAtPeriodEnd:
		return m.OldCancelAtPeriodEnd(ctx)
	case subscription.FieldCanceledAt:
		return m.OldCanceledAt(ctx)
	case subscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Subscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case subscription.FieldTier:
		v, ok := value.(subscription.Tier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTier(v)
		return nil
	case subscription.FieldStatus:
		v, ok := value.(subscription.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case subscription.FieldStripeSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeSubscriptionID(v)
		return nil
	case subscription.FieldStripePriceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripePriceID(v)
		return nil
	case subscription.FieldCurrentPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPeriodStart(v)
		return nil
	case subscription.FieldCurrentPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPeriodEnd(v)
		return nil
	case subscription.FieldCancelAtPeriodEnd:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelAtPeriodEnd(v)
		return nil
	case subscription.FieldCanceledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanceledAt(v)
		return nil
	case subscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscription.FieldStripeSubscriptionID) {
		fields = append(fields, subscription.FieldStripeSubscriptionID)
	}
	if m.FieldCleared(subscription.FieldStripePriceID) {
		fields = append(fields, subscription.FieldStripePriceID)
	}
	if m.FieldCleared(subscription.FieldCurrentPeriodStart) {
		fields = append(fields, subscription.FieldCurrentPeriodStart)
	}
	if m.FieldCleared(subscription.FieldCurrentPeriodEnd) {
		fields = append(fields, subscription.FieldCurrentPeriodEnd)
	}
	if m.FieldCleared(subscription.FieldCanceledAt) {
		fields = append(fields, subscription.FieldCanceledAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionMutation) ClearField(name string) error {
	switch name {
	case subscription.FieldStripeSubscriptionID:
		m.ClearStripeSubscriptionID()
		return nil
	case subscription.FieldStripePriceID:
		m.ClearStripePriceID()
		return nil
	case subscription.FieldCurrentPeriodStart:
		m.ClearCurrentPeriodStart()
		return nil
	case subscription.FieldCurrentPeriodEnd:
		m.ClearCurrentPeriodEnd()
		return nil
	case subscription.FieldCanceledAt:
		m.ClearCanceledAt()
		return nil
	}
	return fmt.Errorf("unknown Subscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionMutation) ResetField(name string) error {
	switch name {
	case subscription.FieldUserID:
		m.ResetUserID()
		return nil
	case subscription.FieldTier:
		m.ResetTier()
		return nil
	case subscription.FieldStatus:
		m.ResetStatus()
		return nil
	case subscription.FieldStripeSubscriptionID:
		m.ResetStripeSubscriptionID()
		return nil
	case subscription.FieldStripePriceID:
		m.ResetStripePriceID()
		return nil
	case subscription.FieldCurrentPeriodStart:
		m.ResetCurrentPeriodStart()
		return nil
	case subscription.FieldCurrentPeriodEnd:
		m.ResetCurrentPeriodEnd()
		return nil
	case subscription.FieldCancelAtPeriodEnd:
		m.ResetCancelAtPeriodEnd()
		return nil
	case subscription.FieldCanceledAt:
		m.ResetCanceledAt()
		return nil
	case subscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, subscription.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, subscription.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case subscription.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Subscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Subscription edge %s", name)
}

// UsageLogMutation represents an operation that mutates the UsageLog nodes in the graph.
type UsageLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	action        *usagelog.Action
	count         *int
	addcount      *int
	metadata      *map[string]interface{}
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UsageLog, error)
	predicates    []predicate.UsageLog
}

var _ ent.Mutation = (*UsageLogMutation)(nil)

// usagelogOption allows management of the mutation configuration using functional options.
type usagelogOption func(*UsageLogMutation)

// newUsageLogMutation creates new mutation for the UsageLog entity.
func newUsageLogMutation(c config, op Op, opts ...usagelogOption) *UsageLogMutation {
	m := &UsageLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageLogID sets the ID field of the mutation.
func withUsageLogID(id int) usagelogOption {
	return func(m *UsageLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageLog
		)
		m.oldValue = func(ctx context.Context) (*UsageLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageLog sets the old UsageLog of the mutation.
func withUsageLog(node *UsageLog) usagelogOption {
	return func(m *UsageLogMutation) {
		m.oldValue = func(context.Context) (*UsageLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UsageLogMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UsageLogMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UsageLogMutation) ResetUserID() {
	m.user = nil
}

// SetAction sets the "action" field.
func (m *UsageLogMutation) SetAction(u usagelog.Action) {
	m.action = &u
}

// Action returns the value of the "action" field in the mutation.
func (m *UsageLogMutation) Action() (r usagelog.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldAction(ctx context.Context) (v usagelog.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *UsageLogMutation) ResetAction() {
	m.action = nil
}

// SetCount sets the "count" field.
func (m *UsageLogMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *UsageLogMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *UsageLogMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *UsageLogMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *UsageLogMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetMetadata sets the "metadata" field.
func (m *UsageLogMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *UsageLogMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *UsageLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[usagelog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *UsageLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *UsageLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, usagelog.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UsageLogMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usagelog.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UsageLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UsageLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UsageLogMutation builder.
func (m *UsageLogMutation) Where(ps ...predicate.UsageLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageLog).
func (m *UsageLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageLogMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, usagelog.FieldUserID)
	}
	if m.action != nil {
		fields = append(fields, usagelog.FieldAction)
	}
	if m.count != nil {
		fields = append(fields, usagelog.FieldCount)
	}
	if m.metadata != nil {
		fields = append(fields, usagelog.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, usagelog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldUserID:
		return m.UserID()
	case usagelog.FieldAction:
		return m.Action()
	case usagelog.FieldCount:
		return m.Count()
	case usagelog.FieldMetadata:
		return m.Metadata()
	case usagelog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagelog.FieldUserID:
		return m.OldUserID(ctx)
	case usagelog.FieldAction:
		return m.OldAction(ctx)
	case usagelog.FieldCount:
		return m.OldCount(ctx)
	case usagelog.FieldMetadata:
		return m.OldMetadata(ctx)
	case usagelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UsageLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usagelog.FieldAction:
		v, ok := value.(usagelog.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case usagelog.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case usagelog.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case usagelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageLogMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, usagelog.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagelog.FieldMetadata) {
		fields = append(fields, usagelog.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageLogMutation) ClearField(name string) error {
	switch name {
	case usagelog.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown UsageLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageLogMutation) ResetField(name string) error {
	switch name {
	case usagelog.FieldUserID:
		m.ResetUserID()
		return nil
	case usagelog.FieldAction:
		m.ResetAction()
		return nil
	case usagelog.FieldCount:
		m.ResetCount()
		return nil
	case usagelog.FieldMetadata:
		m.ResetMetadata()
		return nil
	case usagelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usagelog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagelog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usagelog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageLogMutation) EdgeCleared(name string) bool {
	switch name {
	case usagelog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageLogMutation) ClearEdge(name string) error {
	switch name {
	case usagelog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UsageLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageLogMutation) ResetEdge(name string) error {
	switch name {
	case usagelog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UsageLog edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	email                                  *string
	password_hash                          *string
	name                                   *string
	subscription_tier                      *user.SubscriptionTier
	role                                   *user.Role
	usage_count                            *int
	addusage_count                         *int
	usage_limit                            *int
	addusage_limit                         *int
	last_reset_at                          *time.Time
	last_login_at                          *time.Time
	email_verified                         *bool
	email_verification_token               *string
	email_verification_token_expires_at    *time.Time
	email_verified_at                      *time.Time
	accepted_terms_at                      *time.Time
	onboarding_completed                   *bool
	totp_enabled                           *bool
	totp_secret                            *string
	oauth_provider                         *string
	oauth_id                               *string
	stripe_customer_id                     *string
	created_at                             *time.Time
	updated_at                             *time.Time
	deleted_at                             *time.Time
	onboarding_step                        *int
	addonboarding_step                     *int
	clearedFields                          map[string]struct{}
	subscriptions                          map[int]struct{}
	removedsubscriptions                   map[int]struct{}
	clearedsubscriptions                   bool
	exports                                map[int]struct{}
	removedexports                         map[int]struct{}
	clearedexports                         bool
	api_keys                               map[int]struct{}
	removedapi_keys                        map[int]struct{}
	clearedapi_keys                        bool
	audit_logs                             map[int]struct{}
	removedaudit_logs                      map[int]struct{}
	clearedaudit_logs                      bool
	usage_logs                             map[int]struct{}
	removedusage_logs                      map[int]struct{}
	clearedusage_logs                      bool
	owned_organizations                    map[int]struct{}
	removedowned_organizations             map[int]struct{}
	clearedowned_organizations             bool
	organization_memberships               map[int]struct{}
	removedorganization_memberships        map[int]struct{}
	clearedorganization_memberships        bool
	saved_searches                         map[int]struct{}
	removedsaved_searches                  map[int]struct{}
	clearedsaved_searches                  bool
	webhooks                               map[int]struct{}
	removedwebhooks                        map[int]struct{}
	clearedwebhooks                        bool
	lead_notes                             map[int]struct{}
	removedlead_notes                      map[int]struct{}
	clearedlead_notes                      bool
	lead_status_changes                    map[int]struct{}
	removedlead_status_changes             map[int]struct{}
	clearedlead_status_changes             bool
	assigned_leads                         map[int]struct{}
	removedassigned_leads                  map[int]struct{}
	clearedassigned_leads                  bool
	lead_assignments_made                  map[int]struct{}
	removedlead_assignments_made           map[int]struct{}
	clearedlead_assignments_made           bool
	email_sequences_created                map[int]struct{}
	removedemail_sequences_created         map[int]struct{}
	clearedemail_sequences_created         bool
	email_sequence_enrollments_made        map[int]struct{}
	removedemail_sequence_enrollments_made map[int]struct{}
	clearedemail_sequence_enrollments_made bool
	done                                   bool
	oldValue                               func(context.Context) (*User, error)
	predicates                             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetSubscriptionTier sets the "subscription_tier" field.
func (m *UserMutation) SetSubscriptionTier(ut user.SubscriptionTier) {
	m.subscription_tier = &ut
}

// SubscriptionTier returns the value of the "subscription_tier" field in the mutation.
func (m *UserMutation) SubscriptionTier() (r user.SubscriptionTier, exists bool) {
	v := m.subscription_tier
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionTier returns the old "subscription_tier" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSubscriptionTier(ctx context.Context) (v user.SubscriptionTier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionTier: %w", err)
	}
	return oldValue.SubscriptionTier, nil
}

// ResetSubscriptionTier resets all changes to the "subscription_tier" field.
func (m *UserMutation) ResetSubscriptionTier() {
	m.subscription_tier = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetUsageCount sets the "usage_count" field.
func (m *UserMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *UserMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *UserMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *UserMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *UserMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetUsageLimit sets the "usage_limit" field.
func (m *UserMutation) SetUsageLimit(i int) {
	m.usage_limit = &i
	m.addusage_limit = nil
}

// UsageLimit returns the value of the "usage_limit" field in the mutation.
func (m *UserMutation) UsageLimit() (r int, exists bool) {
	v := m.usage_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageLimit returns the old "usage_limit" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsageLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageLimit: %w", err)
	}
	return oldValue.UsageLimit, nil
}

// AddUsageLimit adds i to the "usage_limit" field.
func (m *UserMutation) AddUsageLimit(i int) {
	if m.addusage_limit != nil {
		*m.addusage_limit += i
	} else {
		m.addusage_limit = &i
	}
}

// AddedUsageLimit returns the value that was added to the "usage_limit" field in this mutation.
func (m *UserMutation) AddedUsageLimit() (r int, exists bool) {
	v := m.addusage_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageLimit resets all changes to the "usage_limit" field.
func (m *UserMutation) ResetUsageLimit() {
	m.usage_limit = nil
	m.addusage_limit = nil
}

// SetLastResetAt sets the "last_reset_at" field.
func (m *UserMutation) SetLastResetAt(t time.Time) {
	m.last_reset_at = &t
}

// LastResetAt returns the value of the "last_reset_at" field in the mutation.
func (m *UserMutation) LastResetAt() (r time.Time, exists bool) {
	v := m.last_reset_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastResetAt returns the old "last_reset_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastResetAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastResetAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastResetAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastResetAt: %w", err)
	}
	return oldValue.LastResetAt, nil
}

// ResetLastResetAt resets all changes to the "last_reset_at" field.
func (m *UserMutation) ResetLastResetAt() {
	m.last_reset_at = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetEmailVerificationToken sets the "email_verification_token" field.
func (m *UserMutation) SetEmailVerificationToken(s string) {
	m.email_verification_token = &s
}

// EmailVerificationToken returns the value of the "email_verification_token" field in the mutation.
func (m *UserMutation) EmailVerificationToken() (r string, exists bool) {
	v := m.email_verification_token
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerificationToken returns the old "email_verification_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerificationToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerificationToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerificationToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerificationToken: %w", err)
	}
	return oldValue.EmailVerificationToken, nil
}

// ClearEmailVerificationToken clears the value of the "email_verification_token" field.
func (m *UserMutation) ClearEmailVerificationToken() {
	m.email_verification_token = nil
	m.clearedFields[user.FieldEmailVerificationToken] = struct{}{}
}

// EmailVerificationTokenCleared returns if the "email_verification_token" field was cleared in this mutation.
func (m *UserMutation) EmailVerificationTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailVerificationToken]
	return ok
}

// ResetEmailVerificationToken resets all changes to the "email_verification_token" field.
func (m *UserMutation) ResetEmailVerificationToken() {
	m.email_verification_token = nil
	delete(m.clearedFields, user.FieldEmailVerificationToken)
}

// SetEmailVerificationTokenExpiresAt sets the "email_verification_token_expires_at" field.
func (m *UserMutation) SetEmailVerificationTokenExpiresAt(t time.Time) {
	m.email_verification_token_expires_at = &t
}

// EmailVerificationTokenExpiresAt returns the value of the "email_verification_token_expires_at" field in the mutation.
func (m *UserMutation) EmailVerificationTokenExpiresAt() (r time.Time, exists bool) {
	v := m.email_verification_token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerificationTokenExpiresAt returns the old "email_verification_token_expires_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerificationTokenExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerificationTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerificationTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerificationTokenExpiresAt: %w", err)
	}
	return oldValue.EmailVerificationTokenExpiresAt, nil
}

// ClearEmailVerificationTokenExpiresAt clears the value of the "email_verification_token_expires_at" field.
func (m *UserMutation) ClearEmailVerificationTokenExpiresAt() {
	m.email_verification_token_expires_at = nil
	m.clearedFields[user.FieldEmailVerificationTokenExpiresAt] = struct{}{}
}

// EmailVerificationTokenExpiresAtCleared returns if the "email_verification_token_expires_at" field was cleared in this mutation.
func (m *UserMutation) EmailVerificationTokenExpiresAtCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailVerificationTokenExpiresAt]
	return ok
}

// ResetEmailVerificationTokenExpiresAt resets all changes to the "email_verification_token_expires_at" field.
func (m *UserMutation) ResetEmailVerificationTokenExpiresAt() {
	m.email_verification_token_expires_at = nil
	delete(m.clearedFields, user.FieldEmailVerificationTokenExpiresAt)
}

// SetEmailVerifiedAt sets the "email_verified_at" field.
func (m *UserMutation) SetEmailVerifiedAt(t time.Time) {
	m.email_verified_at = &t
}

// EmailVerifiedAt returns the value of the "email_verified_at" field in the mutation.
func (m *UserMutation) EmailVerifiedAt() (r time.Time, exists bool) {
	v := m.email_verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerifiedAt returns the old "email_verified_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerifiedAt: %w", err)
	}
	return oldValue.EmailVerifiedAt, nil
}

// ClearEmailVerifiedAt clears the value of the "email_verified_at" field.
func (m *UserMutation) ClearEmailVerifiedAt() {
	m.email_verified_at = nil
	m.clearedFields[user.FieldEmailVerifiedAt] = struct{}{}
}

// EmailVerifiedAtCleared returns if the "email_verified_at" field was cleared in this mutation.
func (m *UserMutation) EmailVerifiedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailVerifiedAt]
	return ok
}

// ResetEmailVerifiedAt resets all changes to the "email_verified_at" field.
func (m *UserMutation) ResetEmailVerifiedAt() {
	m.email_verified_at = nil
	delete(m.clearedFields, user.FieldEmailVerifiedAt)
}

// SetAcceptedTermsAt sets the "accepted_terms_at" field.
func (m *UserMutation) SetAcceptedTermsAt(t time.Time) {
	m.accepted_terms_at = &t
}

// AcceptedTermsAt returns the value of the "accepted_terms_at" field in the mutation.
func (m *UserMutation) AcceptedTermsAt() (r time.Time, exists bool) {
	v := m.accepted_terms_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedTermsAt returns the old "accepted_terms_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAcceptedTermsAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedTermsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedTermsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedTermsAt: %w", err)
	}
	return oldValue.AcceptedTermsAt, nil
}

// ClearAcceptedTermsAt clears the value of the "accepted_terms_at" field.
func (m *UserMutation) ClearAcceptedTermsAt() {
	m.accepted_terms_at = nil
	m.clearedFields[user.FieldAcceptedTermsAt] = struct{}{}
}

// AcceptedTermsAtCleared returns if the "accepted_terms_at" field was cleared in this mutation.
func (m *UserMutation) AcceptedTermsAtCleared() bool {
	_, ok := m.clearedFields[user.FieldAcceptedTermsAt]
	return ok
}

// ResetAcceptedTermsAt resets all changes to the "accepted_terms_at" field.
func (m *UserMutation) ResetAcceptedTermsAt() {
	m.accepted_terms_at = nil
	delete(m.clearedFields, user.FieldAcceptedTermsAt)
}

// SetOnboardingCompleted sets the "onboarding_completed" field.
func (m *UserMutation) SetOnboardingCompleted(b bool) {
	m.onboarding_completed = &b
}

// OnboardingCompleted returns the value of the "onboarding_completed" field in the mutation.
func (m *UserMutation) OnboardingCompleted() (r bool, exists bool) {
	v := m.onboarding_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardingCompleted returns the old "onboarding_completed" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOnboardingCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardingCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardingCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardingCompleted: %w", err)
	}
	return oldValue.OnboardingCompleted, nil
}

// ResetOnboardingCompleted resets all changes to the "onboarding_completed" field.
func (m *UserMutation) ResetOnboardingCompleted() {
	m.onboarding_completed = nil
}

// SetTotpEnabled sets the "totp_enabled" field.
func (m *UserMutation) SetTotpEnabled(b bool) {
	m.totp_enabled = &b
}

// TotpEnabled returns the value of the "totp_enabled" field in the mutation.
func (m *UserMutation) TotpEnabled() (r bool, exists bool) {
	v := m.totp_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpEnabled returns the old "totp_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpEnabled: %w", err)
	}
	return oldValue.TotpEnabled, nil
}

// ResetTotpEnabled resets all changes to the "totp_enabled" field.
func (m *UserMutation) ResetTotpEnabled() {
	m.totp_enabled = nil
}

// SetTotpSecret sets the "totp_secret" field.
func (m *UserMutation) SetTotpSecret(s string) {
	m.totp_secret = &s
}

// TotpSecret returns the value of the "totp_secret" field in the mutation.
func (m *UserMutation) TotpSecret() (r string, exists bool) {
	v := m.totp_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpSecret returns the old "totp_secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpSecret(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpSecret: %w", err)
	}
	return oldValue.TotpSecret, nil
}

// ClearTotpSecret clears the value of the "totp_secret" field.
func (m *UserMutation) ClearTotpSecret() {
	m.totp_secret = nil
	m.clearedFields[user.FieldTotpSecret] = struct{}{}
}

// TotpSecretCleared returns if the "totp_secret" field was cleared in this mutation.
func (m *UserMutation) TotpSecretCleared() bool {
	_, ok := m.clearedFields[user.FieldTotpSecret]
	return ok
}

// ResetTotpSecret resets all changes to the "totp_secret" field.
func (m *UserMutation) ResetTotpSecret() {
	m.totp_secret = nil
	delete(m.clearedFields, user.FieldTotpSecret)
}

// SetOauthProvider sets the "oauth_provider" field.
func (m *UserMutation) SetOauthProvider(s string) {
	m.oauth_provider = &s
}

// OauthProvider returns the value of the "oauth_provider" field in the mutation.
func (m *UserMutation) OauthProvider() (r string, exists bool) {
	v := m.oauth_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldOauthProvider returns the old "oauth_provider" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOauthProvider(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOauthProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOauthProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauthProvider: %w", err)
	}
	return oldValue.OauthProvider, nil
}

// ClearOauthProvider clears the value of the "oauth_provider" field.
func (m *UserMutation) ClearOauthProvider() {
	m.oauth_provider = nil
	m.clearedFields[user.FieldOauthProvider] = struct{}{}
}

// OauthProviderCleared returns if the "oauth_provider" field was cleared in this mutation.
func (m *UserMutation) OauthProviderCleared() bool {
	_, ok := m.clearedFields[user.FieldOauthProvider]
	return ok
}

// ResetOauthProvider resets all changes to the "oauth_provider" field.
func (m *UserMutation) ResetOauthProvider() {
	m.oauth_provider = nil
	delete(m.clearedFields, user.FieldOauthProvider)
}

// SetOauthID sets the "oauth_id" field.
func (m *UserMutation) SetOauthID(s string) {
	m.oauth_id = &s
}

// OauthID returns the value of the "oauth_id" field in the mutation.
func (m *UserMutation) OauthID() (r string, exists bool) {
	v := m.oauth_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOauthID returns the old "oauth_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOauthID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOauthID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOauthID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauthID: %w", err)
	}
	return oldValue.OauthID, nil
}

// ClearOauthID clears the value of the "oauth_id" field.
func (m *UserMutation) ClearOauthID() {
	m.oauth_id = nil
	m.clearedFields[user.FieldOauthID] = struct{}{}
}

// OauthIDCleared returns if the "oauth_id" field was cleared in this mutation.
func (m *UserMutation) OauthIDCleared() bool {
	_, ok := m.clearedFields[user.FieldOauthID]
	return ok
}

// ResetOauthID resets all changes to the "oauth_id" field.
func (m *UserMutation) ResetOauthID() {
	m.oauth_id = nil
	delete(m.clearedFields, user.FieldOauthID)
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *UserMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *UserMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStripeCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (m *UserMutation) ClearStripeCustomerID() {
	m.stripe_customer_id = nil
	m.clearedFields[user.FieldStripeCustomerID] = struct{}{}
}

// StripeCustomerIDCleared returns if the "stripe_customer_id" field was cleared in this mutation.
func (m *UserMutation) StripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[user.FieldStripeCustomerID]
	return ok
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *UserMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
	delete(m.clearedFields, user.FieldStripeCustomerID)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetOnboardingStep sets the "onboarding_step" field.
func (m *UserMutation) SetOnboardingStep(i int) {
	m.onboarding_step = &i
	m.addonboarding_step = nil
}

// OnboardingStep returns the value of the "onboarding_step" field in the mutation.
func (m *UserMutation) OnboardingStep() (r int, exists bool) {
	v := m.onboarding_step
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardingStep returns the old "onboarding_step" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOnboardingStep(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardingStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardingStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardingStep: %w", err)
	}
	return oldValue.OnboardingStep, nil
}

// AddOnboardingStep adds i to the "onboarding_step" field.
func (m *UserMutation) AddOnboardingStep(i int) {
	if m.addonboarding_step != nil {
		*m.addonboarding_step += i
	} else {
		m.addonboarding_step = &i
	}
}

// AddedOnboardingStep returns the value that was added to the "onboarding_step" field in this mutation.
func (m *UserMutation) AddedOnboardingStep() (r int, exists bool) {
	v := m.addonboarding_step
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnboardingStep resets all changes to the "onboarding_step" field.
func (m *UserMutation) ResetOnboardingStep() {
	m.onboarding_step = nil
	m.addonboarding_step = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *UserMutation) AddSubscriptionIDs(ids ...int) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *UserMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *UserMutation) RemoveSubscriptionIDs(ids ...int) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) RemovedSubscriptionsIDs() (ids []int) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *UserMutation) SubscriptionsIDs() (ids []int) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *UserMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddExportIDs adds the "exports" edge to the Export entity by ids.
func (m *UserMutation) AddExportIDs(ids ...int) {
	if m.exports == nil {
		m.exports = make(map[int]struct{})
	}
	for i := range ids {
		m.exports[ids[i]] = struct{}{}
	}
}

// ClearExports clears the "exports" edge to the Export entity.
func (m *UserMutation) ClearExports() {
	m.clearedexports = true
}

// ExportsCleared reports if the "exports" edge to the Export entity was cleared.
func (m *UserMutation) ExportsCleared() bool {
	return m.clearedexports
}

// RemoveExportIDs removes the "exports" edge to the Export entity by IDs.
func (m *UserMutation) RemoveExportIDs(ids ...int) {
	if m.removedexports == nil {
		m.removedexports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.exports, ids[i])
		m.removedexports[ids[i]] = struct{}{}
	}
}

// RemovedExports returns the removed IDs of the "exports" edge to the Export entity.
func (m *UserMutation) RemovedExportsIDs() (ids []int) {
	for id := range m.removedexports {
		ids = append(ids, id)
	}
	return
}

// ExportsIDs returns the "exports" edge IDs in the mutation.
func (m *UserMutation) ExportsIDs() (ids []int) {
	for id := range m.exports {
		ids = append(ids, id)
	}
	return
}

// ResetExports resets all changes to the "exports" edge.
func (m *UserMutation) ResetExports() {
	m.exports = nil
	m.clearedexports = false
	m.removedexports = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...int) {
	if m.api_keys == nil {
		m.api_keys = make(map[int]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...int) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []int) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []int) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddAuditLogIDs adds the "audit_logs" edge to the AuditLog entity by ids.
func (m *UserMutation) AddAuditLogIDs(ids ...int) {
	if m.audit_logs == nil {
		m.audit_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.audit_logs[ids[i]] = struct{}{}
	}
}

// ClearAuditLogs clears the "audit_logs" edge to the AuditLog entity.
func (m *UserMutation) ClearAuditLogs() {
	m.clearedaudit_logs = true
}

// AuditLogsCleared reports if the "audit_logs" edge to the AuditLog entity was cleared.
func (m *UserMutation) AuditLogsCleared() bool {
	return m.clearedaudit_logs
}

// RemoveAuditLogIDs removes the "audit_logs" edge to the AuditLog entity by IDs.
func (m *UserMutation) RemoveAuditLogIDs(ids ...int) {
	if m.removedaudit_logs == nil {
		m.removedaudit_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.audit_logs, ids[i])
		m.removedaudit_logs[ids[i]] = struct{}{}
	}
}

// RemovedAuditLogs returns the removed IDs of the "audit_logs" edge to the AuditLog entity.
func (m *UserMutation) RemovedAuditLogsIDs() (ids []int) {
	for id := range m.removedaudit_logs {
		ids = append(ids, id)
	}
	return
}

// AuditLogsIDs returns the "audit_logs" edge IDs in the mutation.
func (m *UserMutation) AuditLogsIDs() (ids []int) {
	for id := range m.audit_logs {
		ids = append(ids, id)
	}
	return
}

// ResetAuditLogs resets all changes to the "audit_logs" edge.
func (m *UserMutation) ResetAuditLogs() {
	m.audit_logs = nil
	m.clearedaudit_logs = false
	m.removedaudit_logs = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *UserMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *UserMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *UserMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *UserMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *UserMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *UserMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *UserMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// AddOwnedOrganizationIDs adds the "owned_organizations" edge to the Organization entity by ids.
func (m *UserMutation) AddOwnedOrganizationIDs(ids ...int) {
	if m.owned_organizations == nil {
		m.owned_organizations = make(map[int]struct{})
	}
	for i := range ids {
		m.owned_organizations[ids[i]] = struct{}{}
	}
}

// ClearOwnedOrganizations clears the "owned_organizations" edge to the Organization entity.
func (m *UserMutation) ClearOwnedOrganizations() {
	m.clearedowned_organizations = true
}

// OwnedOrganizationsCleared reports if the "owned_organizations" edge to the Organization entity was cleared.
func (m *UserMutation) OwnedOrganizationsCleared() bool {
	return m.clearedowned_organizations
}

// RemoveOwnedOrganizationIDs removes the "owned_organizations" edge to the Organization entity by IDs.
func (m *UserMutation) RemoveOwnedOrganizationIDs(ids ...int) {
	if m.removedowned_organizations == nil {
		m.removedowned_organizations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owned_organizations, ids[i])
		m.removedowned_organizations[ids[i]] = struct{}{}
	}
}

// RemovedOwnedOrganizations returns the removed IDs of the "owned_organizations" edge to the Organization entity.
func (m *UserMutation) RemovedOwnedOrganizationsIDs() (ids []int) {
	for id := range m.removedowned_organizations {
		ids = append(ids, id)
	}
	return
}

// OwnedOrganizationsIDs returns the "owned_organizations" edge IDs in the mutation.
func (m *UserMutation) OwnedOrganizationsIDs() (ids []int) {
	for id := range m.owned_organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedOrganizations resets all changes to the "owned_organizations" edge.
func (m *UserMutation) ResetOwnedOrganizations() {
	m.owned_organizations = nil
	m.clearedowned_organizations = false
	m.removedowned_organizations = nil
}

// AddOrganizationMembershipIDs adds the "organization_memberships" edge to the OrganizationMember entity by ids.
func (m *UserMutation) AddOrganizationMembershipIDs(ids ...int) {
	if m.organization_memberships == nil {
		m.organization_memberships = make(map[int]struct{})
	}
	for i := range ids {
		m.organization_memberships[ids[i]] = struct{}{}
	}
}

// ClearOrganizationMemberships clears the "organization_memberships" edge to the OrganizationMember entity.
func (m *UserMutation) ClearOrganizationMemberships() {
	m.clearedorganization_memberships = true
}

// OrganizationMembershipsCleared reports if the "organization_memberships" edge to the OrganizationMember entity was cleared.
func (m *UserMutation) OrganizationMembershipsCleared() bool {
	return m.clearedorganization_memberships
}

// RemoveOrganizationMembershipIDs removes the "organization_memberships" edge to the OrganizationMember entity by IDs.
func (m *UserMutation) RemoveOrganizationMembershipIDs(ids ...int) {
	if m.removedorganization_memberships == nil {
		m.removedorganization_memberships = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organization_memberships, ids[i])
		m.removedorganization_memberships[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationMemberships returns the removed IDs of the "organization_memberships" edge to the OrganizationMember entity.
func (m *UserMutation) RemovedOrganizationMembershipsIDs() (ids []int) {
	for id := range m.removedorganization_memberships {
		ids = append(ids, id)
	}
	return
}

// OrganizationMembershipsIDs returns the "organization_memberships" edge IDs in the mutation.
func (m *UserMutation) OrganizationMembershipsIDs() (ids []int) {
	for id := range m.organization_memberships {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationMemberships resets all changes to the "organization_memberships" edge.
func (m *UserMutation) ResetOrganizationMemberships() {
	m.organization_memberships = nil
	m.clearedorganization_memberships = false
	m.removedorganization_memberships = nil
}

// AddSavedSearchIDs adds the "saved_searches" edge to the SavedSearch entity by ids.
func (m *UserMutation) AddSavedSearchIDs(ids ...int) {
	if m.saved_searches == nil {
		m.saved_searches = make(map[int]struct{})
	}
	for i := range ids {
		m.saved_searches[ids[i]] = struct{}{}
	}
}

// ClearSavedSearches clears the "saved_searches" edge to the SavedSearch entity.
func (m *UserMutation) ClearSavedSearches() {
	m.clearedsaved_searches = true
}

// SavedSearchesCleared reports if the "saved_searches" edge to the SavedSearch entity was cleared.
func (m *UserMutation) SavedSearchesCleared() bool {
	return m.clearedsaved_searches
}

// RemoveSavedSearchIDs removes the "saved_searches" edge to the SavedSearch entity by IDs.
func (m *UserMutation) RemoveSavedSearchIDs(ids ...int) {
	if m.removedsaved_searches == nil {
		m.removedsaved_searches = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.saved_searches, ids[i])
		m.removedsaved_searches[ids[i]] = struct{}{}
	}
}

// RemovedSavedSearches returns the removed IDs of the "saved_searches" edge to the SavedSearch entity.
func (m *UserMutation) RemovedSavedSearchesIDs() (ids []int) {
	for id := range m.removedsaved_searches {
		ids = append(ids, id)
	}
	return
}

// SavedSearchesIDs returns the "saved_searches" edge IDs in the mutation.
func (m *UserMutation) SavedSearchesIDs() (ids []int) {
	for id := range m.saved_searches {
		ids = append(ids, id)
	}
	return
}

// ResetSavedSearches resets all changes to the "saved_searches" edge.
func (m *UserMutation) ResetSavedSearches() {
	m.saved_searches = nil
	m.clearedsaved_searches = false
	m.removedsaved_searches = nil
}

// AddWebhookIDs adds the "webhooks" edge to the Webhook entity by ids.
func (m *UserMutation) AddWebhookIDs(ids ...int) {
	if m.webhooks == nil {
		m.webhooks = make(map[int]struct{})
	}
	for i := range ids {
		m.webhooks[ids[i]] = struct{}{}
	}
}

// ClearWebhooks clears the "webhooks" edge to the Webhook entity.
func (m *UserMutation) ClearWebhooks() {
	m.clearedwebhooks = true
}

// WebhooksCleared reports if the "webhooks" edge to the Webhook entity was cleared.
func (m *UserMutation) WebhooksCleared() bool {
	return m.clearedwebhooks
}

// RemoveWebhookIDs removes the "webhooks" edge to the Webhook entity by IDs.
func (m *UserMutation) RemoveWebhookIDs(ids ...int) {
	if m.removedwebhooks == nil {
		m.removedwebhooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.webhooks, ids[i])
		m.removedwebhooks[ids[i]] = struct{}{}
	}
}

// RemovedWebhooks returns the removed IDs of the "webhooks" edge to the Webhook entity.
func (m *UserMutation) RemovedWebhooksIDs() (ids []int) {
	for id := range m.removedwebhooks {
		ids = append(ids, id)
	}
	return
}

// WebhooksIDs returns the "webhooks" edge IDs in the mutation.
func (m *UserMutation) WebhooksIDs() (ids []int) {
	for id := range m.webhooks {
		ids = append(ids, id)
	}
	return
}

// ResetWebhooks resets all changes to the "webhooks" edge.
func (m *UserMutation) ResetWebhooks() {
	m.webhooks = nil
	m.clearedwebhooks = false
	m.removedwebhooks = nil
}

// AddLeadNoteIDs adds the "lead_notes" edge to the LeadNote entity by ids.
func (m *UserMutation) AddLeadNoteIDs(ids ...int) {
	if m.lead_notes == nil {
		m.lead_notes = make(map[int]struct{})
	}
	for i := range ids {
		m.lead_notes[ids[i]] = struct{}{}
	}
}

// ClearLeadNotes clears the "lead_notes" edge to the LeadNote entity.
func (m *UserMutation) ClearLeadNotes() {
	m.clearedlead_notes = true
}

// LeadNotesCleared reports if the "lead_notes" edge to the LeadNote entity was cleared.
func (m *UserMutation) LeadNotesCleared() bool {
	return m.clearedlead_notes
}

// RemoveLeadNoteIDs removes the "lead_notes" edge to the LeadNote entity by IDs.
func (m *UserMutation) RemoveLeadNoteIDs(ids ...int) {
	if m.removedlead_notes == nil {
		m.removedlead_notes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lead_notes, ids[i])
		m.removedlead_notes[ids[i]] = struct{}{}
	}
}

// RemovedLeadNotes returns the removed IDs of the "lead_notes" edge to the LeadNote entity.
func (m *UserMutation) RemovedLeadNotesIDs() (ids []int) {
	for id := range m.removedlead_notes {
		ids = append(ids, id)
	}
	return
}

// LeadNotesIDs returns the "lead_notes" edge IDs in the mutation.
func (m *UserMutation) LeadNotesIDs() (ids []int) {
	for id := range m.lead_notes {
		ids = append(ids, id)
	}
	return
}

// ResetLeadNotes resets all changes to the "lead_notes" edge.
func (m *UserMutation) ResetLeadNotes() {
	m.lead_notes = nil
	m.clearedlead_notes = false
	m.removedlead_notes = nil
}

// AddLeadStatusChangeIDs adds the "lead_status_changes" edge to the LeadStatusHistory entity by ids.
func (m *UserMutation) AddLeadStatusChangeIDs(ids ...int) {
	if m.lead_status_changes == nil {
		m.lead_status_changes = make(map[int]struct{})
	}
	for i := range ids {
		m.lead_status_changes[ids[i]] = struct{}{}
	}
}

// ClearLeadStatusChanges clears the "lead_status_changes" edge to the LeadStatusHistory entity.
func (m *UserMutation) ClearLeadStatusChanges() {
	m.clearedlead_status_changes = true
}

// LeadStatusChangesCleared reports if the "lead_status_changes" edge to the LeadStatusHistory entity was cleared.
func (m *UserMutation) LeadStatusChangesCleared() bool {
	return m.clearedlead_status_changes
}

// RemoveLeadStatusChangeIDs removes the "lead_status_changes" edge to the LeadStatusHistory entity by IDs.
func (m *UserMutation) RemoveLeadStatusChangeIDs(ids ...int) {
	if m.removedlead_status_changes == nil {
		m.removedlead_status_changes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lead_status_changes, ids[i])
		m.removedlead_status_changes[ids[i]] = struct{}{}
	}
}

// RemovedLeadStatusChanges returns the removed IDs of the "lead_status_changes" edge to the LeadStatusHistory entity.
func (m *UserMutation) RemovedLeadStatusChangesIDs() (ids []int) {
	for id := range m.removedlead_status_changes {
		ids = append(ids, id)
	}
	return
}

// LeadStatusChangesIDs returns the "lead_status_changes" edge IDs in the mutation.
func (m *UserMutation) LeadStatusChangesIDs() (ids []int) {
	for id := range m.lead_status_changes {
		ids = append(ids, id)
	}
	return
}

// ResetLeadStatusChanges resets all changes to the "lead_status_changes" edge.
func (m *UserMutation) ResetLeadStatusChanges() {
	m.lead_status_changes = nil
	m.clearedlead_status_changes = false
	m.removedlead_status_changes = nil
}

// AddAssignedLeadIDs adds the "assigned_leads" edge to the LeadAssignment entity by ids.
func (m *UserMutation) AddAssignedLeadIDs(ids ...int) {
	if m.assigned_leads == nil {
		m.assigned_leads = make(map[int]struct{})
	}
	for i := range ids {
		m.assigned_leads[ids[i]] = struct{}{}
	}
}

// ClearAssignedLeads clears the "assigned_leads" edge to the LeadAssignment entity.
func (m *UserMutation) ClearAssignedLeads() {
	m.clearedassigned_leads = true
}

// AssignedLeadsCleared reports if the "assigned_leads" edge to the LeadAssignment entity was cleared.
func (m *UserMutation) AssignedLeadsCleared() bool {
	return m.clearedassigned_leads
}

// RemoveAssignedLeadIDs removes the "assigned_leads" edge to the LeadAssignment entity by IDs.
func (m *UserMutation) RemoveAssignedLeadIDs(ids ...int) {
	if m.removedassigned_leads == nil {
		m.removedassigned_leads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assigned_leads, ids[i])
		m.removedassigned_leads[ids[i]] = struct{}{}
	}
}

// RemovedAssignedLeads returns the removed IDs of the "assigned_leads" edge to the LeadAssignment entity.
func (m *UserMutation) RemovedAssignedLeadsIDs() (ids []int) {
	for id := range m.removedassigned_leads {
		ids = append(ids, id)
	}
	return
}

// AssignedLeadsIDs returns the "assigned_leads" edge IDs in the mutation.
func (m *UserMutation) AssignedLeadsIDs() (ids []int) {
	for id := range m.assigned_leads {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedLeads resets all changes to the "assigned_leads" edge.
func (m *UserMutation) ResetAssignedLeads() {
	m.assigned_leads = nil
	m.clearedassigned_leads = false
	m.removedassigned_leads = nil
}

// AddLeadAssignmentsMadeIDs adds the "lead_assignments_made" edge to the LeadAssignment entity by ids.
func (m *UserMutation) AddLeadAssignmentsMadeIDs(ids ...int) {
	if m.lead_assignments_made == nil {
		m.lead_assignments_made = make(map[int]struct{})
	}
	for i := range ids {
		m.lead_assignments_made[ids[i]] = struct{}{}
	}
}

// ClearLeadAssignmentsMade clears the "lead_assignments_made" edge to the LeadAssignment entity.
func (m *UserMutation) ClearLeadAssignmentsMade() {
	m.clearedlead_assignments_made = true
}

// LeadAssignmentsMadeCleared reports if the "lead_assignments_made" edge to the LeadAssignment entity was cleared.
func (m *UserMutation) LeadAssignmentsMadeCleared() bool {
	return m.clearedlead_assignments_made
}

// RemoveLeadAssignmentsMadeIDs removes the "lead_assignments_made" edge to the LeadAssignment entity by IDs.
func (m *UserMutation) RemoveLeadAssignmentsMadeIDs(ids ...int) {
	if m.removedlead_assignments_made == nil {
		m.removedlead_assignments_made = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lead_assignments_made, ids[i])
		m.removedlead_assignments_made[ids[i]] = struct{}{}
	}
}

// RemovedLeadAssignmentsMade returns the removed IDs of the "lead_assignments_made" edge to the LeadAssignment entity.
func (m *UserMutation) RemovedLeadAssignmentsMadeIDs() (ids []int) {
	for id := range m.removedlead_assignments_made {
		ids = append(ids, id)
	}
	return
}

// LeadAssignmentsMadeIDs returns the "lead_assignments_made" edge IDs in the mutation.
func (m *UserMutation) LeadAssignmentsMadeIDs() (ids []int) {
	for id := range m.lead_assignments_made {
		ids = append(ids, id)
	}
	return
}

// ResetLeadAssignmentsMade resets all changes to the "lead_assignments_made" edge.
func (m *UserMutation) ResetLeadAssignmentsMade() {
	m.lead_assignments_made = nil
	m.clearedlead_assignments_made = false
	m.removedlead_assignments_made = nil
}

// AddEmailSequencesCreatedIDs adds the "email_sequences_created" edge to the EmailSequence entity by ids.
func (m *UserMutation) AddEmailSequencesCreatedIDs(ids ...int) {
	if m.email_sequences_created == nil {
		m.email_sequences_created = make(map[int]struct{})
	}
	for i := range ids {
		m.email_sequences_created[ids[i]] = struct{}{}
	}
}

// ClearEmailSequencesCreated clears the "email_sequences_created" edge to the EmailSequence entity.
func (m *UserMutation) ClearEmailSequencesCreated() {
	m.clearedemail_sequences_created = true
}

// EmailSequencesCreatedCleared reports if the "email_sequences_created" edge to the EmailSequence entity was cleared.
func (m *UserMutation) EmailSequencesCreatedCleared() bool {
	return m.clearedemail_sequences_created
}

// RemoveEmailSequencesCreatedIDs removes the "email_sequences_created" edge to the EmailSequence entity by IDs.
func (m *UserMutation) RemoveEmailSequencesCreatedIDs(ids ...int) {
	if m.removedemail_sequences_created == nil {
		m.removedemail_sequences_created = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.email_sequences_created, ids[i])
		m.removedemail_sequences_created[ids[i]] = struct{}{}
	}
}

// RemovedEmailSequencesCreated returns the removed IDs of the "email_sequences_created" edge to the EmailSequence entity.
func (m *UserMutation) RemovedEmailSequencesCreatedIDs() (ids []int) {
	for id := range m.removedemail_sequences_created {
		ids = append(ids, id)
	}
	return
}

// EmailSequencesCreatedIDs returns the "email_sequences_created" edge IDs in the mutation.
func (m *UserMutation) EmailSequencesCreatedIDs() (ids []int) {
	for id := range m.email_sequences_created {
		ids = append(ids, id)
	}
	return
}

// ResetEmailSequencesCreated resets all changes to the "email_sequences_created" edge.
func (m *UserMutation) ResetEmailSequencesCreated() {
	m.email_sequences_created = nil
	m.clearedemail_sequences_created = false
	m.removedemail_sequences_created = nil
}

// AddEmailSequenceEnrollmentsMadeIDs adds the "email_sequence_enrollments_made" edge to the EmailSequenceEnrollment entity by ids.
func (m *UserMutation) AddEmailSequenceEnrollmentsMadeIDs(ids ...int) {
	if m.email_sequence_enrollments_made == nil {
		m.email_sequence_enrollments_made = make(map[int]struct{})
	}
	for i := range ids {
		m.email_sequence_enrollments_made[ids[i]] = struct{}{}
	}
}

// ClearEmailSequenceEnrollmentsMade clears the "email_sequence_enrollments_made" edge to the EmailSequenceEnrollment entity.
func (m *UserMutation) ClearEmailSequenceEnrollmentsMade() {
	m.clearedemail_sequence_enrollments_made = true
}

// EmailSequenceEnrollmentsMadeCleared reports if the "email_sequence_enrollments_made" edge to the EmailSequenceEnrollment entity was cleared.
func (m *UserMutation) EmailSequenceEnrollmentsMadeCleared() bool {
	return m.clearedemail_sequence_enrollments_made
}

// RemoveEmailSequenceEnrollmentsMadeIDs removes the "email_sequence_enrollments_made" edge to the EmailSequenceEnrollment entity by IDs.
func (m *UserMutation) RemoveEmailSequenceEnrollmentsMadeIDs(ids ...int) {
	if m.removedemail_sequence_enrollments_made == nil {
		m.removedemail_sequence_enrollments_made = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.email_sequence_enrollments_made, ids[i])
		m.removedemail_sequence_enrollments_made[ids[i]] = struct{}{}
	}
}

// RemovedEmailSequenceEnrollmentsMade returns the removed IDs of the "email_sequence_enrollments_made" edge to the EmailSequenceEnrollment entity.
func (m *UserMutation) RemovedEmailSequenceEnrollmentsMadeIDs() (ids []int) {
	for id := range m.removedemail_sequence_enrollments_made {
		ids = append(ids, id)
	}
	return
}

// EmailSequenceEnrollmentsMadeIDs returns the "email_sequence_enrollments_made" edge IDs in the mutation.
func (m *UserMutation) EmailSequenceEnrollmentsMadeIDs() (ids []int) {
	for id := range m.email_sequence_enrollments_made {
		ids = append(ids, id)
	}
	return
}

// ResetEmailSequenceEnrollmentsMade resets all changes to the "email_sequence_enrollments_made" edge.
func (m *UserMutation) ResetEmailSequenceEnrollmentsMade() {
	m.email_sequence_enrollments_made = nil
	m.clearedemail_sequence_enrollments_made = false
	m.removedemail_sequence_enrollments_made = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.subscription_tier != nil {
		fields = append(fields, user.FieldSubscriptionTier)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.usage_count != nil {
		fields = append(fields, user.FieldUsageCount)
	}
	if m.usage_limit != nil {
		fields = append(fields, user.FieldUsageLimit)
	}
	if m.last_reset_at != nil {
		fields = append(fields, user.FieldLastResetAt)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.email_verification_token != nil {
		fields = append(fields, user.FieldEmailVerificationToken)
	}
	if m.email_verification_token_expires_at != nil {
		fields = append(fields, user.FieldEmailVerificationTokenExpiresAt)
	}
	if m.email_verified_at != nil {
		fields = append(fields, user.FieldEmailVerifiedAt)
	}
	if m.accepted_terms_at != nil {
		fields = append(fields, user.FieldAcceptedTermsAt)
	}
	if m.onboarding_completed != nil {
		fields = append(fields, user.FieldOnboardingCompleted)
	}
	if m.totp_enabled != nil {
		fields = append(fields, user.FieldTotpEnabled)
	}
	if m.totp_secret != nil {
		fields = append(fields, user.FieldTotpSecret)
	}
	if m.oauth_provider != nil {
		fields = append(fields, user.FieldOauthProvider)
	}
	if m.oauth_id != nil {
		fields = append(fields, user.FieldOauthID)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, user.FieldStripeCustomerID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.onboarding_step != nil {
		fields = append(fields, user.FieldOnboardingStep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldName:
		return m.Name()
	case user.FieldSubscriptionTier:
		return m.SubscriptionTier()
	case user.FieldRole:
		return m.Role()
	case user.FieldUsageCount:
		return m.UsageCount()
	case user.FieldUsageLimit:
		return m.UsageLimit()
	case user.FieldLastResetAt:
		return m.LastResetAt()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldEmailVerificationToken:
		return m.EmailVerificationToken()
	case user.FieldEmailVerificationTokenExpiresAt:
		return m.EmailVerificationTokenExpiresAt()
	case user.FieldEmailVerifiedAt:
		return m.EmailVerifiedAt()
	case user.FieldAcceptedTermsAt:
		return m.AcceptedTermsAt()
	case user.FieldOnboardingCompleted:
		return m.OnboardingCompleted()
	case user.FieldTotpEnabled:
		return m.TotpEnabled()
	case user.FieldTotpSecret:
		return m.TotpSecret()
	case user.FieldOauthProvider:
		return m.OauthProvider()
	case user.FieldOauthID:
		return m.OauthID()
	case user.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldOnboardingStep:
		return m.OnboardingStep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldSubscriptionTier:
		return m.OldSubscriptionTier(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case user.FieldUsageLimit:
		return m.OldUsageLimit(ctx)
	case user.FieldLastResetAt:
		return m.OldLastResetAt(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldEmailVerificationToken:
		return m.OldEmailVerificationToken(ctx)
	case user.FieldEmailVerificationTokenExpiresAt:
		return m.OldEmailVerificationTokenExpiresAt(ctx)
	case user.FieldEmailVerifiedAt:
		return m.OldEmailVerifiedAt(ctx)
	case user.FieldAcceptedTermsAt:
		return m.OldAcceptedTermsAt(ctx)
	case user.FieldOnboardingCompleted:
		return m.OldOnboardingCompleted(ctx)
	case user.FieldTotpEnabled:
		return m.OldTotpEnabled(ctx)
	case user.FieldTotpSecret:
		return m.OldTotpSecret(ctx)
	case user.FieldOauthProvider:
		return m.OldOauthProvider(ctx)
	case user.FieldOauthID:
		return m.OldOauthID(ctx)
	case user.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldOnboardingStep:
		return m.OldOnboardingStep(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldSubscriptionTier:
		v, ok := value.(user.SubscriptionTier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionTier(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case user.FieldUsageLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageLimit(v)
		return nil
	case user.FieldLastResetAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastResetAt(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldEmailVerificationToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerificationToken(v)
		return nil
	case user.FieldEmailVerificationTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerificationTokenExpiresAt(v)
		return nil
	case user.FieldEmailVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerifiedAt(v)
		return nil
	case user.FieldAcceptedTermsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedTermsAt(v)
		return nil
	case user.FieldOnboardingCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardingCompleted(v)
		return nil
	case user.FieldTotpEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpEnabled(v)
		return nil
	case user.FieldTotpSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpSecret(v)
		return nil
	case user.FieldOauthProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauthProvider(v)
		return nil
	case user.FieldOauthID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauthID(v)
		return nil
	case user.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldOnboardingStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardingStep(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, user.FieldUsageCount)
	}
	if m.addusage_limit != nil {
		fields = append(fields, user.FieldUsageLimit)
	}
	if m.addonboarding_step != nil {
		fields = append(fields, user.FieldOnboardingStep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsageCount:
		return m.AddedUsageCount()
	case user.FieldUsageLimit:
		return m.AddedUsageLimit()
	case user.FieldOnboardingStep:
		return m.AddedOnboardingStep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	case user.FieldUsageLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageLimit(v)
		return nil
	case user.FieldOnboardingStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnboardingStep(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.FieldCleared(user.FieldEmailVerificationToken) {
		fields = append(fields, user.FieldEmailVerificationToken)
	}
	if m.FieldCleared(user.FieldEmailVerificationTokenExpiresAt) {
		fields = append(fields, user.FieldEmailVerificationTokenExpiresAt)
	}
	if m.FieldCleared(user.FieldEmailVerifiedAt) {
		fields = append(fields, user.FieldEmailVerifiedAt)
	}
	if m.FieldCleared(user.FieldAcceptedTermsAt) {
		fields = append(fields, user.FieldAcceptedTermsAt)
	}
	if m.FieldCleared(user.FieldTotpSecret) {
		fields = append(fields, user.FieldTotpSecret)
	}
	if m.FieldCleared(user.FieldOauthProvider) {
		fields = append(fields, user.FieldOauthProvider)
	}
	if m.FieldCleared(user.FieldOauthID) {
		fields = append(fields, user.FieldOauthID)
	}
	if m.FieldCleared(user.FieldStripeCustomerID) {
		fields = append(fields, user.FieldStripeCustomerID)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case user.FieldEmailVerificationToken:
		m.ClearEmailVerificationToken()
		return nil
	case user.FieldEmailVerificationTokenExpiresAt:
		m.ClearEmailVerificationTokenExpiresAt()
		return nil
	case user.FieldEmailVerifiedAt:
		m.ClearEmailVerifiedAt()
		return nil
	case user.FieldAcceptedTermsAt:
		m.ClearAcceptedTermsAt()
		return nil
	case user.FieldTotpSecret:
		m.ClearTotpSecret()
		return nil
	case user.FieldOauthProvider:
		m.ClearOauthProvider()
		return nil
	case user.FieldOauthID:
		m.ClearOauthID()
		return nil
	case user.FieldStripeCustomerID:
		m.ClearStripeCustomerID()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldSubscriptionTier:
		m.ResetSubscriptionTier()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case user.FieldUsageLimit:
		m.ResetUsageLimit()
		return nil
	case user.FieldLastResetAt:
		m.ResetLastResetAt()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldEmailVerificationToken:
		m.ResetEmailVerificationToken()
		return nil
	case user.FieldEmailVerificationTokenExpiresAt:
		m.ResetEmailVerificationTokenExpiresAt()
		return nil
	case user.FieldEmailVerifiedAt:
		m.ResetEmailVerifiedAt()
		return nil
	case user.FieldAcceptedTermsAt:
		m.ResetAcceptedTermsAt()
		return nil
	case user.FieldOnboardingCompleted:
		m.ResetOnboardingCompleted()
		return nil
	case user.FieldTotpEnabled:
		m.ResetTotpEnabled()
		return nil
	case user.FieldTotpSecret:
		m.ResetTotpSecret()
		return nil
	case user.FieldOauthProvider:
		m.ResetOauthProvider()
		return nil
	case user.FieldOauthID:
		m.ResetOauthID()
		return nil
	case user.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldOnboardingStep:
		m.ResetOnboardingStep()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.subscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.exports != nil {
		edges = append(edges, user.EdgeExports)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.audit_logs != nil {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.usage_logs != nil {
		edges = append(edges, user.EdgeUsageLogs)
	}
	if m.owned_organizations != nil {
		edges = append(edges, user.EdgeOwnedOrganizations)
	}
	if m.organization_memberships != nil {
		edges = append(edges, user.EdgeOrganizationMemberships)
	}
	if m.saved_searches != nil {
		edges = append(edges, user.EdgeSavedSearches)
	}
	if m.webhooks != nil {
		edges = append(edges, user.EdgeWebhooks)
	}
	if m.lead_notes != nil {
		edges = append(edges, user.EdgeLeadNotes)
	}
	if m.lead_status_changes != nil {
		edges = append(edges, user.EdgeLeadStatusChanges)
	}
	if m.assigned_leads != nil {
		edges = append(edges, user.EdgeAssignedLeads)
	}
	if m.lead_assignments_made != nil {
		edges = append(edges, user.EdgeLeadAssignmentsMade)
	}
	if m.email_sequences_created != nil {
		edges = append(edges, user.EdgeEmailSequencesCreated)
	}
	if m.email_sequence_enrollments_made != nil {
		edges = append(edges, user.EdgeEmailSequenceEnrollmentsMade)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeExports:
		ids := make([]ent.Value, 0, len(m.exports))
		for id := range m.exports {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.audit_logs))
		for id := range m.audit_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedOrganizations:
		ids := make([]ent.Value, 0, len(m.owned_organizations))
		for id := range m.owned_organizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizationMemberships:
		ids := make([]ent.Value, 0, len(m.organization_memberships))
		for id := range m.organization_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSavedSearches:
		ids := make([]ent.Value, 0, len(m.saved_searches))
		for id := range m.saved_searches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWebhooks:
		ids := make([]ent.Value, 0, len(m.webhooks))
		for id := range m.webhooks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeadNotes:
		ids := make([]ent.Value, 0, len(m.lead_notes))
		for id := range m.lead_notes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeadStatusChanges:
		ids := make([]ent.Value, 0, len(m.lead_status_changes))
		for id := range m.lead_status_changes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedLeads:
		ids := make([]ent.Value, 0, len(m.assigned_leads))
		for id := range m.assigned_leads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeadAssignmentsMade:
		ids := make([]ent.Value, 0, len(m.lead_assignments_made))
		for id := range m.lead_assignments_made {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEmailSequencesCreated:
		ids := make([]ent.Value, 0, len(m.email_sequences_created))
		for id := range m.email_sequences_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEmailSequenceEnrollmentsMade:
		ids := make([]ent.Value, 0, len(m.email_sequence_enrollments_made))
		for id := range m.email_sequence_enrollments_made {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedsubscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.removedexports != nil {
		edges = append(edges, user.EdgeExports)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removedaudit_logs != nil {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, user.EdgeUsageLogs)
	}
	if m.removedowned_organizations != nil {
		edges = append(edges, user.EdgeOwnedOrganizations)
	}
	if m.removedorganization_memberships != nil {
		edges = append(edges, user.EdgeOrganizationMemberships)
	}
	if m.removedsaved_searches != nil {
		edges = append(edges, user.EdgeSavedSearches)
	}
	if m.removedwebhooks != nil {
		edges = append(edges, user.EdgeWebhooks)
	}
	if m.removedlead_notes != nil {
		edges = append(edges, user.EdgeLeadNotes)
	}
	if m.removedlead_status_changes != nil {
		edges = append(edges, user.EdgeLeadStatusChanges)
	}
	if m.removedassigned_leads != nil {
		edges = append(edges, user.EdgeAssignedLeads)
	}
	if m.removedlead_assignments_made != nil {
		edges = append(edges, user.EdgeLeadAssignmentsMade)
	}
	if m.removedemail_sequences_created != nil {
		edges = append(edges, user.EdgeEmailSequencesCreated)
	}
	if m.removedemail_sequence_enrollments_made != nil {
		edges = append(edges, user.EdgeEmailSequenceEnrollmentsMade)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeExports:
		ids := make([]ent.Value, 0, len(m.removedexports))
		for id := range m.removedexports {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.removedaudit_logs))
		for id := range m.removedaudit_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedOrganizations:
		ids := make([]ent.Value, 0, len(m.removedowned_organizations))
		for id := range m.removedowned_organizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizationMemberships:
		ids := make([]ent.Value, 0, len(m.removedorganization_memberships))
		for id := range m.removedorganization_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSavedSearches:
		ids := make([]ent.Value, 0, len(m.removedsaved_searches))
		for id := range m.removedsaved_searches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWebhooks:
		ids := make([]ent.Value, 0, len(m.removedwebhooks))
		for id := range m.removedwebhooks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeadNotes:
		ids := make([]ent.Value, 0, len(m.removedlead_notes))
		for id := range m.removedlead_notes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeadStatusChanges:
		ids := make([]ent.Value, 0, len(m.removedlead_status_changes))
		for id := range m.removedlead_status_changes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedLeads:
		ids := make([]ent.Value, 0, len(m.removedassigned_leads))
		for id := range m.removedassigned_leads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeadAssignmentsMade:
		ids := make([]ent.Value, 0, len(m.removedlead_assignments_made))
		for id := range m.removedlead_assignments_made {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEmailSequencesCreated:
		ids := make([]ent.Value, 0, len(m.removedemail_sequences_created))
		for id := range m.removedemail_sequences_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEmailSequenceEnrollmentsMade:
		ids := make([]ent.Value, 0, len(m.removedemail_sequence_enrollments_made))
		for id := range m.removedemail_sequence_enrollments_made {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedsubscriptions {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.clearedexports {
		edges = append(edges, user.EdgeExports)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.clearedaudit_logs {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.clearedusage_logs {
		edges = append(edges, user.EdgeUsageLogs)
	}
	if m.clearedowned_organizations {
		edges = append(edges, user.EdgeOwnedOrganizations)
	}
	if m.clearedorganization_memberships {
		edges = append(edges, user.EdgeOrganizationMemberships)
	}
	if m.clearedsaved_searches {
		edges = append(edges, user.EdgeSavedSearches)
	}
	if m.clearedwebhooks {
		edges = append(edges, user.EdgeWebhooks)
	}
	if m.clearedlead_notes {
		edges = append(edges, user.EdgeLeadNotes)
	}
	if m.clearedlead_status_changes {
		edges = append(edges, user.EdgeLeadStatusChanges)
	}
	if m.clearedassigned_leads {
		edges = append(edges, user.EdgeAssignedLeads)
	}
	if m.clearedlead_assignments_made {
		edges = append(edges, user.EdgeLeadAssignmentsMade)
	}
	if m.clearedemail_sequences_created {
		edges = append(edges, user.EdgeEmailSequencesCreated)
	}
	if m.clearedemail_sequence_enrollments_made {
		edges = append(edges, user.EdgeEmailSequenceEnrollmentsMade)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSubscriptions:
		return m.clearedsubscriptions
	case user.EdgeExports:
		return m.clearedexports
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeAuditLogs:
		return m.clearedaudit_logs
	case user.EdgeUsageLogs:
		return m.clearedusage_logs
	case user.EdgeOwnedOrganizations:
		return m.clearedowned_organizations
	case user.EdgeOrganizationMemberships:
		return m.clearedorganization_memberships
	case user.EdgeSavedSearches:
		return m.clearedsaved_searches
	case user.EdgeWebhooks:
		return m.clearedwebhooks
	case user.EdgeLeadNotes:
		return m.clearedlead_notes
	case user.EdgeLeadStatusChanges:
		return m.clearedlead_status_changes
	case user.EdgeAssignedLeads:
		return m.clearedassigned_leads
	case user.EdgeLeadAssignmentsMade:
		return m.clearedlead_assignments_made
	case user.EdgeEmailSequencesCreated:
		return m.clearedemail_sequences_created
	case user.EdgeEmailSequenceEnrollmentsMade:
		return m.clearedemail_sequence_enrollments_made
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case user.EdgeExports:
		m.ResetExports()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeAuditLogs:
		m.ResetAuditLogs()
		return nil
	case user.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	case user.EdgeOwnedOrganizations:
		m.ResetOwnedOrganizations()
		return nil
	case user.EdgeOrganizationMemberships:
		m.ResetOrganizationMemberships()
		return nil
	case user.EdgeSavedSearches:
		m.ResetSavedSearches()
		return nil
	case user.EdgeWebhooks:
		m.ResetWebhooks()
		return nil
	case user.EdgeLeadNotes:
		m.ResetLeadNotes()
		return nil
	case user.EdgeLeadStatusChanges:
		m.ResetLeadStatusChanges()
		return nil
	case user.EdgeAssignedLeads:
		m.ResetAssignedLeads()
		return nil
	case user.EdgeLeadAssignmentsMade:
		m.ResetLeadAssignmentsMade()
		return nil
	case user.EdgeEmailSequencesCreated:
		m.ResetEmailSequencesCreated()
		return nil
	case user.EdgeEmailSequenceEnrollmentsMade:
		m.ResetEmailSequenceEnrollmentsMade()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WebhookMutation represents an operation that mutates the Webhook nodes in the graph.
type WebhookMutation struct {
	config
	op                Op
	typ               string
	id                *int
	url               *string
	events            *[]string
	appendevents      []string
	secret            *string
	active            *bool
	description       *string
	retry_count       *int
	addretry_count    *int
	last_triggered_at *time.Time
	success_count     *int
	addsuccess_count  *int
	failure_count     *int
	addfailure_count  *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	user              *int
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*Webhook, error)
	predicates        []predicate.Webhook
}

var _ ent.Mutation = (*WebhookMutation)(nil)

// webhookOption allows management of the mutation configuration using functional options.
type webhookOption func(*WebhookMutation)

// newWebhookMutation creates new mutation for the Webhook entity.
func newWebhookMutation(c config, op Op, opts ...webhookOption) *WebhookMutation {
	m := &WebhookMutation{
		config:        c,
		op:            op,
		typ:           TypeWebhook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebhookID sets the ID field of the mutation.
func withWebhookID(id int) webhookOption {
	return func(m *WebhookMutation) {
		var (
			err   error
			once  sync.Once
			value *Webhook
		)
		m.oldValue = func(ctx context.Context) (*Webhook, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Webhook.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebhook sets the old Webhook of the mutation.
func withWebhook(node *Webhook) webhookOption {
	return func(m *WebhookMutation) {
		m.oldValue = func(context.Context) (*Webhook, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebhookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebhookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebhookMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebhookMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Webhook.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *WebhookMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *WebhookMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *WebhookMutation) ResetURL() {
	m.url = nil
}

// SetEvents sets the "events" field.
func (m *WebhookMutation) SetEvents(s []string) {
	m.events = &s
	m.appendevents = nil
}

// Events returns the value of the "events" field in the mutation.
func (m *WebhookMutation) Events() (r []string, exists bool) {
	v := m.events
	if v == nil {
		return
	}
	return *v, true
}

// OldEvents returns the old "events" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldEvents(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvents: %w", err)
	}
	return oldValue.Events, nil
}

// AppendEvents adds s to the "events" field.
func (m *WebhookMutation) AppendEvents(s []string) {
	m.appendevents = append(m.appendevents, s...)
}

// AppendedEvents returns the list of values that were appended to the "events" field in this mutation.
func (m *WebhookMutation) AppendedEvents() ([]string, bool) {
	if len(m.appendevents) == 0 {
		return nil, false
	}
	return m.appendevents, true
}

// ResetEvents resets all changes to the "events" field.
func (m *WebhookMutation) ResetEvents() {
	m.events = nil
	m.appendevents = nil
}

// SetSecret sets the "secret" field.
func (m *WebhookMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *WebhookMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *WebhookMutation) ResetSecret() {
	m.secret = nil
}

// SetActive sets the "active" field.
func (m *WebhookMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *WebhookMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *WebhookMutation) ResetActive() {
	m.active = nil
}

// SetDescription sets the "description" field.
func (m *WebhookMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WebhookMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WebhookMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[webhook.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WebhookMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[webhook.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WebhookMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, webhook.FieldDescription)
}

// SetRetryCount sets the "retry_count" field.
func (m *WebhookMutation) SetRetryCount(i int) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *WebhookMutation) RetryCount() (r int, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *WebhookMutation) AddRetryCount(i int) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *WebhookMutation) AddedRetryCount() (r int, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *WebhookMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetLastTriggeredAt sets the "last_triggered_at" field.
func (m *WebhookMutation) SetLastTriggeredAt(t time.Time) {
	m.last_triggered_at = &t
}

// LastTriggeredAt returns the value of the "last_triggered_at" field in the mutation.
func (m *WebhookMutation) LastTriggeredAt() (r time.Time, exists bool) {
	v := m.last_triggered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastTriggeredAt returns the old "last_triggered_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldLastTriggeredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastTriggeredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastTriggeredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastTriggeredAt: %w", err)
	}
	return oldValue.LastTriggeredAt, nil
}

// ClearLastTriggeredAt clears the value of the "last_triggered_at" field.
func (m *WebhookMutation) ClearLastTriggeredAt() {
	m.last_triggered_at = nil
	m.clearedFields[webhook.FieldLastTriggeredAt] = struct{}{}
}

// LastTriggeredAtCleared returns if the "last_triggered_at" field was cleared in this mutation.
func (m *WebhookMutation) LastTriggeredAtCleared() bool {
	_, ok := m.clearedFields[webhook.FieldLastTriggeredAt]
	return ok
}

// ResetLastTriggeredAt resets all changes to the "last_triggered_at" field.
func (m *WebhookMutation) ResetLastTriggeredAt() {
	m.last_triggered_at = nil
	delete(m.clearedFields, webhook.FieldLastTriggeredAt)
}

// SetSuccessCount sets the "success_count" field.
func (m *WebhookMutation) SetSuccessCount(i int) {
	m.success_count = &i
	m.addsuccess_count = nil
}

// SuccessCount returns the value of the "success_count" field in the mutation.
func (m *WebhookMutation) SuccessCount() (r int, exists bool) {
	v := m.success_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessCount returns the old "success_count" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSuccessCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessCount: %w", err)
	}
	return oldValue.SuccessCount, nil
}

// AddSuccessCount adds i to the "success_count" field.
func (m *WebhookMutation) AddSuccessCount(i int) {
	if m.addsuccess_count != nil {
		*m.addsuccess_count += i
	} else {
		m.addsuccess_count = &i
	}
}

// AddedSuccessCount returns the value that was added to the "success_count" field in this mutation.
func (m *WebhookMutation) AddedSuccessCount() (r int, exists bool) {
	v := m.addsuccess_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessCount resets all changes to the "success_count" field.
func (m *WebhookMutation) ResetSuccessCount() {
	m.success_count = nil
	m.addsuccess_count = nil
}

// SetFailureCount sets the "failure_count" field.
func (m *WebhookMutation) SetFailureCount(i int) {
	m.failure_count = &i
	m.addfailure_count = nil
}

// FailureCount returns the value of the "failure_count" field in the mutation.
func (m *WebhookMutation) FailureCount() (r int, exists bool) {
	v := m.failure_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureCount returns the old "failure_count" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldFailureCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureCount: %w", err)
	}
	return oldValue.FailureCount, nil
}

// AddFailureCount adds i to the "failure_count" field.
func (m *WebhookMutation) AddFailureCount(i int) {
	if m.addfailure_count != nil {
		*m.addfailure_count += i
	} else {
		m.addfailure_count = &i
	}
}

// AddedFailureCount returns the value that was added to the "failure_count" field in this mutation.
func (m *WebhookMutation) AddedFailureCount() (r int, exists bool) {
	v := m.addfailure_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailureCount resets all changes to the "failure_count" field.
func (m *WebhookMutation) ResetFailureCount() {
	m.failure_count = nil
	m.addfailure_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WebhookMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebhookMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebhookMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebhookMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebhookMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebhookMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *WebhookMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *WebhookMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WebhookMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *WebhookMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WebhookMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WebhookMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WebhookMutation builder.
func (m *WebhookMutation) Where(ps ...predicate.Webhook) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebhookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebhookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Webhook, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebhookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebhookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Webhook).
func (m *WebhookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebhookMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.url != nil {
		fields = append(fields, webhook.FieldURL)
	}
	if m.events != nil {
		fields = append(fields, webhook.FieldEvents)
	}
	if m.secret != nil {
		fields = append(fields, webhook.FieldSecret)
	}
	if m.active != nil {
		fields = append(fields, webhook.FieldActive)
	}
	if m.description != nil {
		fields = append(fields, webhook.FieldDescription)
	}
	if m.retry_count != nil {
		fields = append(fields, webhook.FieldRetryCount)
	}
	if m.last_triggered_at != nil {
		fields = append(fields, webhook.FieldLastTriggeredAt)
	}
	if m.success_count != nil {
		fields = append(fields, webhook.FieldSuccessCount)
	}
	if m.failure_count != nil {
		fields = append(fields, webhook.FieldFailureCount)
	}
	if m.created_at != nil {
		fields = append(fields, webhook.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, webhook.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebhookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldURL:
		return m.URL()
	case webhook.FieldEvents:
		return m.Events()
	case webhook.FieldSecret:
		return m.Secret()
	case webhook.FieldActive:
		return m.Active()
	case webhook.FieldDescription:
		return m.Description()
	case webhook.FieldRetryCount:
		return m.RetryCount()
	case webhook.FieldLastTriggeredAt:
		return m.LastTriggeredAt()
	case webhook.FieldSuccessCount:
		return m.SuccessCount()
	case webhook.FieldFailureCount:
		return m.FailureCount()
	case webhook.FieldCreatedAt:
		return m.CreatedAt()
	case webhook.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebhookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webhook.FieldURL:
		return m.OldURL(ctx)
	case webhook.FieldEvents:
		return m.OldEvents(ctx)
	case webhook.FieldSecret:
		return m.OldSecret(ctx)
	case webhook.FieldActive:
		return m.OldActive(ctx)
	case webhook.FieldDescription:
		return m.OldDescription(ctx)
	case webhook.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case webhook.FieldLastTriggeredAt:
		return m.OldLastTriggeredAt(ctx)
	case webhook.FieldSuccessCount:
		return m.OldSuccessCount(ctx)
	case webhook.FieldFailureCount:
		return m.OldFailureCount(ctx)
	case webhook.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webhook.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Webhook field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case webhook.FieldEvents:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvents(v)
		return nil
	case webhook.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case webhook.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case webhook.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case webhook.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case webhook.FieldLastTriggeredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastTriggeredAt(v)
		return nil
	case webhook.FieldSuccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessCount(v)
		return nil
	case webhook.FieldFailureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureCount(v)
		return nil
	case webhook.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webhook.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebhookMutation) AddedFields() []string {
	var fields []string
	if m.addretry_count != nil {
		fields = append(fields, webhook.FieldRetryCount)
	}
	if m.addsuccess_count != nil {
		fields = append(fields, webhook.FieldSuccessCount)
	}
	if m.addfailure_count != nil {
		fields = append(fields, webhook.FieldFailureCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebhookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldRetryCount:
		return m.AddedRetryCount()
	case webhook.FieldSuccessCount:
		return m.AddedSuccessCount()
	case webhook.FieldFailureCount:
		return m.AddedFailureCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	case webhook.FieldSuccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessCount(v)
		return nil
	case webhook.FieldFailureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailureCount(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebhookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webhook.FieldDescription) {
		fields = append(fields, webhook.FieldDescription)
	}
	if m.FieldCleared(webhook.FieldLastTriggeredAt) {
		fields = append(fields, webhook.FieldLastTriggeredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebhookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebhookMutation) ClearField(name string) error {
	switch name {
	case webhook.FieldDescription:
		m.ClearDescription()
		return nil
	case webhook.FieldLastTriggeredAt:
		m.ClearLastTriggeredAt()
		return nil
	}
	return fmt.Errorf("unknown Webhook nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebhookMutation) ResetField(name string) error {
	switch name {
	case webhook.FieldURL:
		m.ResetURL()
		return nil
	case webhook.FieldEvents:
		m.ResetEvents()
		return nil
	case webhook.FieldSecret:
		m.ResetSecret()
		return nil
	case webhook.FieldActive:
		m.ResetActive()
		return nil
	case webhook.FieldDescription:
		m.ResetDescription()
		return nil
	case webhook.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case webhook.FieldLastTriggeredAt:
		m.ResetLastTriggeredAt()
		return nil
	case webhook.FieldSuccessCount:
		m.ResetSuccessCount()
		return nil
	case webhook.FieldFailureCount:
		m.ResetFailureCount()
		return nil
	case webhook.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webhook.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebhookMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, webhook.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebhookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webhook.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebhookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebhookMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebhookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, webhook.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebhookMutation) EdgeCleared(name string) bool {
	switch name {
	case webhook.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebhookMutation) ClearEdge(name string) error {
	switch name {
	case webhook.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Webhook unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebhookMutation) ResetEdge(name string) error {
	switch name {
	case webhook.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Webhook edge %s", name)
}
