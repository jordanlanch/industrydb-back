// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/jordanlanch/industrydb/ent/apikey"
	"github.com/jordanlanch/industrydb/ent/auditlog"
	"github.com/jordanlanch/industrydb/ent/export"
	"github.com/jordanlanch/industrydb/ent/industry"
	"github.com/jordanlanch/industrydb/ent/lead"
	"github.com/jordanlanch/industrydb/ent/organization"
	"github.com/jordanlanch/industrydb/ent/organizationmember"
	"github.com/jordanlanch/industrydb/ent/predicate"
	"github.com/jordanlanch/industrydb/ent/savedsearch"
	"github.com/jordanlanch/industrydb/ent/subscription"
	"github.com/jordanlanch/industrydb/ent/usagelog"
	"github.com/jordanlanch/industrydb/ent/user"
	"github.com/jordanlanch/industrydb/ent/webhook"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey             = "APIKey"
	TypeAuditLog           = "AuditLog"
	TypeExport             = "Export"
	TypeIndustry           = "Industry"
	TypeLead               = "Lead"
	TypeOrganization       = "Organization"
	TypeOrganizationMember = "OrganizationMember"
	TypeSavedSearch        = "SavedSearch"
	TypeSubscription       = "Subscription"
	TypeUsageLog           = "UsageLog"
	TypeUser               = "User"
	TypeWebhook            = "Webhook"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op             Op
	typ            string
	id             *int
	key_hash       *string
	name           *string
	prefix         *string
	last_used_at   *time.Time
	usage_count    *int
	addusage_count *int
	revoked        *bool
	revoked_at     *time.Time
	expires_at     *time.Time
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*APIKey, error)
	predicates     []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id int) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *APIKeyMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *APIKeyMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *APIKeyMutation) ResetUserID() {
	m.user = nil
}

// SetKeyHash sets the "key_hash" field.
func (m *APIKeyMutation) SetKeyHash(s string) {
	m.key_hash = &s
}

// KeyHash returns the value of the "key_hash" field in the mutation.
func (m *APIKeyMutation) KeyHash() (r string, exists bool) {
	v := m.key_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyHash returns the old "key_hash" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKeyHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyHash: %w", err)
	}
	return oldValue.KeyHash, nil
}

// ResetKeyHash resets all changes to the "key_hash" field.
func (m *APIKeyMutation) ResetKeyHash() {
	m.key_hash = nil
}

// SetName sets the "name" field.
func (m *APIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIKeyMutation) ResetName() {
	m.name = nil
}

// SetPrefix sets the "prefix" field.
func (m *APIKeyMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the value of the "prefix" field in the mutation.
func (m *APIKeyMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old "prefix" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix resets all changes to the "prefix" field.
func (m *APIKeyMutation) ResetPrefix() {
	m.prefix = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *APIKeyMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *APIKeyMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *APIKeyMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[apikey.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *APIKeyMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *APIKeyMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, apikey.FieldLastUsedAt)
}

// SetUsageCount sets the "usage_count" field.
func (m *APIKeyMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *APIKeyMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *APIKeyMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *APIKeyMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *APIKeyMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetRevoked sets the "revoked" field.
func (m *APIKeyMutation) SetRevoked(b bool) {
	m.revoked = &b
}

// Revoked returns the value of the "revoked" field in the mutation.
func (m *APIKeyMutation) Revoked() (r bool, exists bool) {
	v := m.revoked
	if v == nil {
		return
	}
	return *v, true
}

// OldRevoked returns the old "revoked" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldRevoked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevoked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevoked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevoked: %w", err)
	}
	return oldValue.Revoked, nil
}

// ResetRevoked resets all changes to the "revoked" field.
func (m *APIKeyMutation) ResetRevoked() {
	m.revoked = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *APIKeyMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *APIKeyMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *APIKeyMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[apikey.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *APIKeyMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *APIKeyMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, apikey.FieldRevokedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *APIKeyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *APIKeyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *APIKeyMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apikey.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *APIKeyMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *APIKeyMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apikey.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *APIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *APIKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APIKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APIKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.key_hash != nil {
		fields = append(fields, apikey.FieldKeyHash)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.prefix != nil {
		fields = append(fields, apikey.FieldPrefix)
	}
	if m.last_used_at != nil {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.usage_count != nil {
		fields = append(fields, apikey.FieldUsageCount)
	}
	if m.revoked != nil {
		fields = append(fields, apikey.FieldRevoked)
	}
	if m.revoked_at != nil {
		fields = append(fields, apikey.FieldRevokedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldKeyHash:
		return m.KeyHash()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldPrefix:
		return m.Prefix()
	case apikey.FieldLastUsedAt:
		return m.LastUsedAt()
	case apikey.FieldUsageCount:
		return m.UsageCount()
	case apikey.FieldRevoked:
		return m.Revoked()
	case apikey.FieldRevokedAt:
		return m.RevokedAt()
	case apikey.FieldExpiresAt:
		return m.ExpiresAt()
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldKeyHash:
		return m.OldKeyHash(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldPrefix:
		return m.OldPrefix(ctx)
	case apikey.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case apikey.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case apikey.FieldRevoked:
		return m.OldRevoked(ctx)
	case apikey.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case apikey.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldKeyHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyHash(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	case apikey.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case apikey.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case apikey.FieldRevoked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevoked(v)
		return nil
	case apikey.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case apikey.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, apikey.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldLastUsedAt) {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.FieldCleared(apikey.FieldRevokedAt) {
		fields = append(fields, apikey.FieldRevokedAt)
	}
	if m.FieldCleared(apikey.FieldExpiresAt) {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case apikey.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case apikey.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldKeyHash:
		m.ResetKeyHash()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldPrefix:
		m.ResetPrefix()
		return nil
	case apikey.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case apikey.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case apikey.FieldRevoked:
		m.ResetRevoked()
		return nil
	case apikey.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case apikey.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	action        *auditlog.Action
	resource_type *string
	resource_id   *string
	ip_address    *string
	user_agent    *string
	metadata      *map[string]interface{}
	severity      *auditlog.Severity
	description   *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*AuditLog, error)
	predicates    []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id int) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AuditLogMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuditLogMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AuditLogMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[auditlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AuditLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuditLogMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, auditlog.FieldUserID)
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(a auditlog.Action) {
	m.action = &a
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r auditlog.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v auditlog.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetResourceType sets the "resource_type" field.
func (m *AuditLogMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *AuditLogMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ClearResourceType clears the value of the "resource_type" field.
func (m *AuditLogMutation) ClearResourceType() {
	m.resource_type = nil
	m.clearedFields[auditlog.FieldResourceType] = struct{}{}
}

// ResourceTypeCleared returns if the "resource_type" field was cleared in this mutation.
func (m *AuditLogMutation) ResourceTypeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResourceType]
	return ok
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *AuditLogMutation) ResetResourceType() {
	m.resource_type = nil
	delete(m.clearedFields, auditlog.FieldResourceType)
}

// SetResourceID sets the "resource_id" field.
func (m *AuditLogMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *AuditLogMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *AuditLogMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[auditlog.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *AuditLogMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *AuditLogMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, auditlog.FieldResourceID)
}

// SetIPAddress sets the "ip_address" field.
func (m *AuditLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *AuditLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *AuditLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[auditlog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *AuditLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *AuditLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, auditlog.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *AuditLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *AuditLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *AuditLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[auditlog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *AuditLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *AuditLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, auditlog.FieldUserAgent)
}

// SetMetadata sets the "metadata" field.
func (m *AuditLogMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuditLogMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuditLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[auditlog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuditLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuditLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, auditlog.FieldMetadata)
}

// SetSeverity sets the "severity" field.
func (m *AuditLogMutation) SetSeverity(a auditlog.Severity) {
	m.severity = &a
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AuditLogMutation) Severity() (r auditlog.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSeverity(ctx context.Context) (v auditlog.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AuditLogMutation) ResetSeverity() {
	m.severity = nil
}

// SetDescription sets the "description" field.
func (m *AuditLogMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AuditLogMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AuditLogMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[auditlog.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AuditLogMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AuditLogMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, auditlog.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *AuditLogMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[auditlog.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AuditLogMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuditLogMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AuditLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.user != nil {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m.resource_type != nil {
		fields = append(fields, auditlog.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.ip_address != nil {
		fields = append(fields, auditlog.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, auditlog.FieldUserAgent)
	}
	if m.metadata != nil {
		fields = append(fields, auditlog.FieldMetadata)
	}
	if m.severity != nil {
		fields = append(fields, auditlog.FieldSeverity)
	}
	if m.description != nil {
		fields = append(fields, auditlog.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldUserID:
		return m.UserID()
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldResourceType:
		return m.ResourceType()
	case auditlog.FieldResourceID:
		return m.ResourceID()
	case auditlog.FieldIPAddress:
		return m.IPAddress()
	case auditlog.FieldUserAgent:
		return m.UserAgent()
	case auditlog.FieldMetadata:
		return m.Metadata()
	case auditlog.FieldSeverity:
		return m.Severity()
	case auditlog.FieldDescription:
		return m.Description()
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldUserID:
		return m.OldUserID(ctx)
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldResourceType:
		return m.OldResourceType(ctx)
	case auditlog.FieldResourceID:
		return m.OldResourceID(ctx)
	case auditlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case auditlog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case auditlog.FieldMetadata:
		return m.OldMetadata(ctx)
	case auditlog.FieldSeverity:
		return m.OldSeverity(ctx)
	case auditlog.FieldDescription:
		return m.OldDescription(ctx)
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case auditlog.FieldAction:
		v, ok := value.(auditlog.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case auditlog.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case auditlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case auditlog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case auditlog.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case auditlog.FieldSeverity:
		v, ok := value.(auditlog.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case auditlog.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldUserID) {
		fields = append(fields, auditlog.FieldUserID)
	}
	if m.FieldCleared(auditlog.FieldResourceType) {
		fields = append(fields, auditlog.FieldResourceType)
	}
	if m.FieldCleared(auditlog.FieldResourceID) {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.FieldCleared(auditlog.FieldIPAddress) {
		fields = append(fields, auditlog.FieldIPAddress)
	}
	if m.FieldCleared(auditlog.FieldUserAgent) {
		fields = append(fields, auditlog.FieldUserAgent)
	}
	if m.FieldCleared(auditlog.FieldMetadata) {
		fields = append(fields, auditlog.FieldMetadata)
	}
	if m.FieldCleared(auditlog.FieldDescription) {
		fields = append(fields, auditlog.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldUserID:
		m.ClearUserID()
		return nil
	case auditlog.FieldResourceType:
		m.ClearResourceType()
		return nil
	case auditlog.FieldResourceID:
		m.ClearResourceID()
		return nil
	case auditlog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case auditlog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case auditlog.FieldMetadata:
		m.ClearMetadata()
		return nil
	case auditlog.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldUserID:
		m.ResetUserID()
		return nil
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldResourceType:
		m.ResetResourceType()
		return nil
	case auditlog.FieldResourceID:
		m.ResetResourceID()
		return nil
	case auditlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case auditlog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case auditlog.FieldMetadata:
		m.ResetMetadata()
		return nil
	case auditlog.FieldSeverity:
		m.ResetSeverity()
		return nil
	case auditlog.FieldDescription:
		m.ResetDescription()
		return nil
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, auditlog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auditlog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, auditlog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	switch name {
	case auditlog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	switch name {
	case auditlog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	switch name {
	case auditlog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// ExportMutation represents an operation that mutates the Export nodes in the graph.
type ExportMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	format              *export.Format
	filters_applied     *map[string]interface{}
	lead_count          *int
	addlead_count       *int
	file_url            *string
	file_path           *string
	status              *export.Status
	error_message       *string
	expires_at          *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	user                *int
	cleareduser         bool
	organization        *int
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*Export, error)
	predicates          []predicate.Export
}

var _ ent.Mutation = (*ExportMutation)(nil)

// exportOption allows management of the mutation configuration using functional options.
type exportOption func(*ExportMutation)

// newExportMutation creates new mutation for the Export entity.
func newExportMutation(c config, op Op, opts ...exportOption) *ExportMutation {
	m := &ExportMutation{
		config:        c,
		op:            op,
		typ:           TypeExport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExportID sets the ID field of the mutation.
func withExportID(id int) exportOption {
	return func(m *ExportMutation) {
		var (
			err   error
			once  sync.Once
			value *Export
		)
		m.oldValue = func(ctx context.Context) (*Export, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Export.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExport sets the old Export of the mutation.
func withExport(node *Export) exportOption {
	return func(m *ExportMutation) {
		m.oldValue = func(context.Context) (*Export, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Export.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ExportMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ExportMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ExportMutation) ResetUserID() {
	m.user = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ExportMutation) SetOrganizationID(i int) {
	m.organization = &i
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ExportMutation) OrganizationID() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldOrganizationID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *ExportMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[export.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *ExportMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[export.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ExportMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, export.FieldOrganizationID)
}

// SetFormat sets the "format" field.
func (m *ExportMutation) SetFormat(e export.Format) {
	m.format = &e
}

// Format returns the value of the "format" field in the mutation.
func (m *ExportMutation) Format() (r export.Format, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldFormat(ctx context.Context) (v export.Format, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *ExportMutation) ResetFormat() {
	m.format = nil
}

// SetFiltersApplied sets the "filters_applied" field.
func (m *ExportMutation) SetFiltersApplied(value map[string]interface{}) {
	m.filters_applied = &value
}

// FiltersApplied returns the value of the "filters_applied" field in the mutation.
func (m *ExportMutation) FiltersApplied() (r map[string]interface{}, exists bool) {
	v := m.filters_applied
	if v == nil {
		return
	}
	return *v, true
}

// OldFiltersApplied returns the old "filters_applied" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldFiltersApplied(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiltersApplied is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiltersApplied requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiltersApplied: %w", err)
	}
	return oldValue.FiltersApplied, nil
}

// ClearFiltersApplied clears the value of the "filters_applied" field.
func (m *ExportMutation) ClearFiltersApplied() {
	m.filters_applied = nil
	m.clearedFields[export.FieldFiltersApplied] = struct{}{}
}

// FiltersAppliedCleared returns if the "filters_applied" field was cleared in this mutation.
func (m *ExportMutation) FiltersAppliedCleared() bool {
	_, ok := m.clearedFields[export.FieldFiltersApplied]
	return ok
}

// ResetFiltersApplied resets all changes to the "filters_applied" field.
func (m *ExportMutation) ResetFiltersApplied() {
	m.filters_applied = nil
	delete(m.clearedFields, export.FieldFiltersApplied)
}

// SetLeadCount sets the "lead_count" field.
func (m *ExportMutation) SetLeadCount(i int) {
	m.lead_count = &i
	m.addlead_count = nil
}

// LeadCount returns the value of the "lead_count" field in the mutation.
func (m *ExportMutation) LeadCount() (r int, exists bool) {
	v := m.lead_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLeadCount returns the old "lead_count" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldLeadCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeadCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeadCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeadCount: %w", err)
	}
	return oldValue.LeadCount, nil
}

// AddLeadCount adds i to the "lead_count" field.
func (m *ExportMutation) AddLeadCount(i int) {
	if m.addlead_count != nil {
		*m.addlead_count += i
	} else {
		m.addlead_count = &i
	}
}

// AddedLeadCount returns the value that was added to the "lead_count" field in this mutation.
func (m *ExportMutation) AddedLeadCount() (r int, exists bool) {
	v := m.addlead_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLeadCount resets all changes to the "lead_count" field.
func (m *ExportMutation) ResetLeadCount() {
	m.lead_count = nil
	m.addlead_count = nil
}

// SetFileURL sets the "file_url" field.
func (m *ExportMutation) SetFileURL(s string) {
	m.file_url = &s
}

// FileURL returns the value of the "file_url" field in the mutation.
func (m *ExportMutation) FileURL() (r string, exists bool) {
	v := m.file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFileURL returns the old "file_url" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileURL: %w", err)
	}
	return oldValue.FileURL, nil
}

// ClearFileURL clears the value of the "file_url" field.
func (m *ExportMutation) ClearFileURL() {
	m.file_url = nil
	m.clearedFields[export.FieldFileURL] = struct{}{}
}

// FileURLCleared returns if the "file_url" field was cleared in this mutation.
func (m *ExportMutation) FileURLCleared() bool {
	_, ok := m.clearedFields[export.FieldFileURL]
	return ok
}

// ResetFileURL resets all changes to the "file_url" field.
func (m *ExportMutation) ResetFileURL() {
	m.file_url = nil
	delete(m.clearedFields, export.FieldFileURL)
}

// SetFilePath sets the "file_path" field.
func (m *ExportMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *ExportMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ClearFilePath clears the value of the "file_path" field.
func (m *ExportMutation) ClearFilePath() {
	m.file_path = nil
	m.clearedFields[export.FieldFilePath] = struct{}{}
}

// FilePathCleared returns if the "file_path" field was cleared in this mutation.
func (m *ExportMutation) FilePathCleared() bool {
	_, ok := m.clearedFields[export.FieldFilePath]
	return ok
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *ExportMutation) ResetFilePath() {
	m.file_path = nil
	delete(m.clearedFields, export.FieldFilePath)
}

// SetStatus sets the "status" field.
func (m *ExportMutation) SetStatus(e export.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *ExportMutation) Status() (r export.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldStatus(ctx context.Context) (v export.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ExportMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *ExportMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ExportMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ExportMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[export.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ExportMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[export.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ExportMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, export.FieldErrorMessage)
}

// SetExpiresAt sets the "expires_at" field.
func (m *ExportMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ExportMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ExportMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[export.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ExportMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[export.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ExportMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, export.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ExportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ExportMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[export.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ExportMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ExportMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ExportMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ExportMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[export.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ExportMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ExportMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ExportMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ExportMutation builder.
func (m *ExportMutation) Where(ps ...predicate.Export) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Export, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Export).
func (m *ExportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExportMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, export.FieldUserID)
	}
	if m.organization != nil {
		fields = append(fields, export.FieldOrganizationID)
	}
	if m.format != nil {
		fields = append(fields, export.FieldFormat)
	}
	if m.filters_applied != nil {
		fields = append(fields, export.FieldFiltersApplied)
	}
	if m.lead_count != nil {
		fields = append(fields, export.FieldLeadCount)
	}
	if m.file_url != nil {
		fields = append(fields, export.FieldFileURL)
	}
	if m.file_path != nil {
		fields = append(fields, export.FieldFilePath)
	}
	if m.status != nil {
		fields = append(fields, export.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, export.FieldErrorMessage)
	}
	if m.expires_at != nil {
		fields = append(fields, export.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, export.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, export.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case export.FieldUserID:
		return m.UserID()
	case export.FieldOrganizationID:
		return m.OrganizationID()
	case export.FieldFormat:
		return m.Format()
	case export.FieldFiltersApplied:
		return m.FiltersApplied()
	case export.FieldLeadCount:
		return m.LeadCount()
	case export.FieldFileURL:
		return m.FileURL()
	case export.FieldFilePath:
		return m.FilePath()
	case export.FieldStatus:
		return m.Status()
	case export.FieldErrorMessage:
		return m.ErrorMessage()
	case export.FieldExpiresAt:
		return m.ExpiresAt()
	case export.FieldCreatedAt:
		return m.CreatedAt()
	case export.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case export.FieldUserID:
		return m.OldUserID(ctx)
	case export.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case export.FieldFormat:
		return m.OldFormat(ctx)
	case export.FieldFiltersApplied:
		return m.OldFiltersApplied(ctx)
	case export.FieldLeadCount:
		return m.OldLeadCount(ctx)
	case export.FieldFileURL:
		return m.OldFileURL(ctx)
	case export.FieldFilePath:
		return m.OldFilePath(ctx)
	case export.FieldStatus:
		return m.OldStatus(ctx)
	case export.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case export.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case export.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case export.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Export field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case export.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case export.FieldOrganizationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case export.FieldFormat:
		v, ok := value.(export.Format)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case export.FieldFiltersApplied:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiltersApplied(v)
		return nil
	case export.FieldLeadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeadCount(v)
		return nil
	case export.FieldFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileURL(v)
		return nil
	case export.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case export.FieldStatus:
		v, ok := value.(export.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case export.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case export.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case export.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case export.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Export field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExportMutation) AddedFields() []string {
	var fields []string
	if m.addlead_count != nil {
		fields = append(fields, export.FieldLeadCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case export.FieldLeadCount:
		return m.AddedLeadCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case export.FieldLeadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeadCount(v)
		return nil
	}
	return fmt.Errorf("unknown Export numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(export.FieldOrganizationID) {
		fields = append(fields, export.FieldOrganizationID)
	}
	if m.FieldCleared(export.FieldFiltersApplied) {
		fields = append(fields, export.FieldFiltersApplied)
	}
	if m.FieldCleared(export.FieldFileURL) {
		fields = append(fields, export.FieldFileURL)
	}
	if m.FieldCleared(export.FieldFilePath) {
		fields = append(fields, export.FieldFilePath)
	}
	if m.FieldCleared(export.FieldErrorMessage) {
		fields = append(fields, export.FieldErrorMessage)
	}
	if m.FieldCleared(export.FieldExpiresAt) {
		fields = append(fields, export.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExportMutation) ClearField(name string) error {
	switch name {
	case export.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	case export.FieldFiltersApplied:
		m.ClearFiltersApplied()
		return nil
	case export.FieldFileURL:
		m.ClearFileURL()
		return nil
	case export.FieldFilePath:
		m.ClearFilePath()
		return nil
	case export.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case export.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Export nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExportMutation) ResetField(name string) error {
	switch name {
	case export.FieldUserID:
		m.ResetUserID()
		return nil
	case export.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case export.FieldFormat:
		m.ResetFormat()
		return nil
	case export.FieldFiltersApplied:
		m.ResetFiltersApplied()
		return nil
	case export.FieldLeadCount:
		m.ResetLeadCount()
		return nil
	case export.FieldFileURL:
		m.ResetFileURL()
		return nil
	case export.FieldFilePath:
		m.ResetFilePath()
		return nil
	case export.FieldStatus:
		m.ResetStatus()
		return nil
	case export.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case export.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case export.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case export.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Export field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, export.EdgeUser)
	}
	if m.organization != nil {
		edges = append(edges, export.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case export.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case export.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, export.EdgeUser)
	}
	if m.clearedorganization {
		edges = append(edges, export.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExportMutation) EdgeCleared(name string) bool {
	switch name {
	case export.EdgeUser:
		return m.cleareduser
	case export.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExportMutation) ClearEdge(name string) error {
	switch name {
	case export.EdgeUser:
		m.ClearUser()
		return nil
	case export.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Export unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExportMutation) ResetEdge(name string) error {
	switch name {
	case export.EdgeUser:
		m.ResetUser()
		return nil
	case export.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown Export edge %s", name)
}

// IndustryMutation represents an operation that mutates the Industry nodes in the graph.
type IndustryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	name                      *string
	category                  *string
	icon                      *string
	osm_primary_tag           *string
	osm_additional_tags       *[]string
	appendosm_additional_tags []string
	description               *string
	active                    *bool
	sort_order                *int
	addsort_order             *int
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Industry, error)
	predicates                []predicate.Industry
}

var _ ent.Mutation = (*IndustryMutation)(nil)

// industryOption allows management of the mutation configuration using functional options.
type industryOption func(*IndustryMutation)

// newIndustryMutation creates new mutation for the Industry entity.
func newIndustryMutation(c config, op Op, opts ...industryOption) *IndustryMutation {
	m := &IndustryMutation{
		config:        c,
		op:            op,
		typ:           TypeIndustry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIndustryID sets the ID field of the mutation.
func withIndustryID(id string) industryOption {
	return func(m *IndustryMutation) {
		var (
			err   error
			once  sync.Once
			value *Industry
		)
		m.oldValue = func(ctx context.Context) (*Industry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Industry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIndustry sets the old Industry of the mutation.
func withIndustry(node *Industry) industryOption {
	return func(m *IndustryMutation) {
		m.oldValue = func(context.Context) (*Industry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IndustryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IndustryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Industry entities.
func (m *IndustryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IndustryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IndustryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Industry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IndustryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IndustryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IndustryMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *IndustryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *IndustryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *IndustryMutation) ResetCategory() {
	m.category = nil
}

// SetIcon sets the "icon" field.
func (m *IndustryMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *IndustryMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *IndustryMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[industry.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *IndustryMutation) IconCleared() bool {
	_, ok := m.clearedFields[industry.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *IndustryMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, industry.FieldIcon)
}

// SetOsmPrimaryTag sets the "osm_primary_tag" field.
func (m *IndustryMutation) SetOsmPrimaryTag(s string) {
	m.osm_primary_tag = &s
}

// OsmPrimaryTag returns the value of the "osm_primary_tag" field in the mutation.
func (m *IndustryMutation) OsmPrimaryTag() (r string, exists bool) {
	v := m.osm_primary_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldOsmPrimaryTag returns the old "osm_primary_tag" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldOsmPrimaryTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsmPrimaryTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsmPrimaryTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsmPrimaryTag: %w", err)
	}
	return oldValue.OsmPrimaryTag, nil
}

// ResetOsmPrimaryTag resets all changes to the "osm_primary_tag" field.
func (m *IndustryMutation) ResetOsmPrimaryTag() {
	m.osm_primary_tag = nil
}

// SetOsmAdditionalTags sets the "osm_additional_tags" field.
func (m *IndustryMutation) SetOsmAdditionalTags(s []string) {
	m.osm_additional_tags = &s
	m.appendosm_additional_tags = nil
}

// OsmAdditionalTags returns the value of the "osm_additional_tags" field in the mutation.
func (m *IndustryMutation) OsmAdditionalTags() (r []string, exists bool) {
	v := m.osm_additional_tags
	if v == nil {
		return
	}
	return *v, true
}

// OldOsmAdditionalTags returns the old "osm_additional_tags" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldOsmAdditionalTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsmAdditionalTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsmAdditionalTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsmAdditionalTags: %w", err)
	}
	return oldValue.OsmAdditionalTags, nil
}

// AppendOsmAdditionalTags adds s to the "osm_additional_tags" field.
func (m *IndustryMutation) AppendOsmAdditionalTags(s []string) {
	m.appendosm_additional_tags = append(m.appendosm_additional_tags, s...)
}

// AppendedOsmAdditionalTags returns the list of values that were appended to the "osm_additional_tags" field in this mutation.
func (m *IndustryMutation) AppendedOsmAdditionalTags() ([]string, bool) {
	if len(m.appendosm_additional_tags) == 0 {
		return nil, false
	}
	return m.appendosm_additional_tags, true
}

// ClearOsmAdditionalTags clears the value of the "osm_additional_tags" field.
func (m *IndustryMutation) ClearOsmAdditionalTags() {
	m.osm_additional_tags = nil
	m.appendosm_additional_tags = nil
	m.clearedFields[industry.FieldOsmAdditionalTags] = struct{}{}
}

// OsmAdditionalTagsCleared returns if the "osm_additional_tags" field was cleared in this mutation.
func (m *IndustryMutation) OsmAdditionalTagsCleared() bool {
	_, ok := m.clearedFields[industry.FieldOsmAdditionalTags]
	return ok
}

// ResetOsmAdditionalTags resets all changes to the "osm_additional_tags" field.
func (m *IndustryMutation) ResetOsmAdditionalTags() {
	m.osm_additional_tags = nil
	m.appendosm_additional_tags = nil
	delete(m.clearedFields, industry.FieldOsmAdditionalTags)
}

// SetDescription sets the "description" field.
func (m *IndustryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IndustryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IndustryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[industry.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IndustryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[industry.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IndustryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, industry.FieldDescription)
}

// SetActive sets the "active" field.
func (m *IndustryMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *IndustryMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *IndustryMutation) ResetActive() {
	m.active = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *IndustryMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *IndustryMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *IndustryMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *IndustryMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *IndustryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IndustryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IndustryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IndustryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IndustryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IndustryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IndustryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the IndustryMutation builder.
func (m *IndustryMutation) Where(ps ...predicate.Industry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IndustryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IndustryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Industry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IndustryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IndustryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Industry).
func (m *IndustryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IndustryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, industry.FieldName)
	}
	if m.category != nil {
		fields = append(fields, industry.FieldCategory)
	}
	if m.icon != nil {
		fields = append(fields, industry.FieldIcon)
	}
	if m.osm_primary_tag != nil {
		fields = append(fields, industry.FieldOsmPrimaryTag)
	}
	if m.osm_additional_tags != nil {
		fields = append(fields, industry.FieldOsmAdditionalTags)
	}
	if m.description != nil {
		fields = append(fields, industry.FieldDescription)
	}
	if m.active != nil {
		fields = append(fields, industry.FieldActive)
	}
	if m.sort_order != nil {
		fields = append(fields, industry.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, industry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, industry.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IndustryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case industry.FieldName:
		return m.Name()
	case industry.FieldCategory:
		return m.Category()
	case industry.FieldIcon:
		return m.Icon()
	case industry.FieldOsmPrimaryTag:
		return m.OsmPrimaryTag()
	case industry.FieldOsmAdditionalTags:
		return m.OsmAdditionalTags()
	case industry.FieldDescription:
		return m.Description()
	case industry.FieldActive:
		return m.Active()
	case industry.FieldSortOrder:
		return m.SortOrder()
	case industry.FieldCreatedAt:
		return m.CreatedAt()
	case industry.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IndustryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case industry.FieldName:
		return m.OldName(ctx)
	case industry.FieldCategory:
		return m.OldCategory(ctx)
	case industry.FieldIcon:
		return m.OldIcon(ctx)
	case industry.FieldOsmPrimaryTag:
		return m.OldOsmPrimaryTag(ctx)
	case industry.FieldOsmAdditionalTags:
		return m.OldOsmAdditionalTags(ctx)
	case industry.FieldDescription:
		return m.OldDescription(ctx)
	case industry.FieldActive:
		return m.OldActive(ctx)
	case industry.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case industry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case industry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Industry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndustryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case industry.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case industry.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case industry.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case industry.FieldOsmPrimaryTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsmPrimaryTag(v)
		return nil
	case industry.FieldOsmAdditionalTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsmAdditionalTags(v)
		return nil
	case industry.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case industry.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case industry.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case industry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case industry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Industry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IndustryMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, industry.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IndustryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case industry.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndustryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case industry.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Industry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IndustryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(industry.FieldIcon) {
		fields = append(fields, industry.FieldIcon)
	}
	if m.FieldCleared(industry.FieldOsmAdditionalTags) {
		fields = append(fields, industry.FieldOsmAdditionalTags)
	}
	if m.FieldCleared(industry.FieldDescription) {
		fields = append(fields, industry.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IndustryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IndustryMutation) ClearField(name string) error {
	switch name {
	case industry.FieldIcon:
		m.ClearIcon()
		return nil
	case industry.FieldOsmAdditionalTags:
		m.ClearOsmAdditionalTags()
		return nil
	case industry.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Industry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IndustryMutation) ResetField(name string) error {
	switch name {
	case industry.FieldName:
		m.ResetName()
		return nil
	case industry.FieldCategory:
		m.ResetCategory()
		return nil
	case industry.FieldIcon:
		m.ResetIcon()
		return nil
	case industry.FieldOsmPrimaryTag:
		m.ResetOsmPrimaryTag()
		return nil
	case industry.FieldOsmAdditionalTags:
		m.ResetOsmAdditionalTags()
		return nil
	case industry.FieldDescription:
		m.ResetDescription()
		return nil
	case industry.FieldActive:
		m.ResetActive()
		return nil
	case industry.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case industry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case industry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Industry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IndustryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IndustryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IndustryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IndustryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IndustryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IndustryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IndustryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Industry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IndustryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Industry edge %s", name)
}

// LeadMutation represents an operation that mutates the Lead nodes in the graph.
type LeadMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	industry          *lead.Industry
	country           *string
	city              *string
	address           *string
	postal_code       *string
	phone             *string
	email             *string
	website           *string
	social_media      *map[string]string
	latitude          *float64
	addlatitude       *float64
	longitude         *float64
	addlongitude      *float64
	verified          *bool
	quality_score     *int
	addquality_score  *int
	osm_id            *string
	metadata          *map[string]interface{}
	sub_niche         *string
	specialties       *[]string
	appendspecialties []string
	cuisine_type      *string
	sport_type        *string
	tattoo_style      *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Lead, error)
	predicates        []predicate.Lead
}

var _ ent.Mutation = (*LeadMutation)(nil)

// leadOption allows management of the mutation configuration using functional options.
type leadOption func(*LeadMutation)

// newLeadMutation creates new mutation for the Lead entity.
func newLeadMutation(c config, op Op, opts ...leadOption) *LeadMutation {
	m := &LeadMutation{
		config:        c,
		op:            op,
		typ:           TypeLead,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeadID sets the ID field of the mutation.
func withLeadID(id int) leadOption {
	return func(m *LeadMutation) {
		var (
			err   error
			once  sync.Once
			value *Lead
		)
		m.oldValue = func(ctx context.Context) (*Lead, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lead.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLead sets the old Lead of the mutation.
func withLead(node *Lead) leadOption {
	return func(m *LeadMutation) {
		m.oldValue = func(context.Context) (*Lead, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lead.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LeadMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LeadMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LeadMutation) ResetName() {
	m.name = nil
}

// SetIndustry sets the "industry" field.
func (m *LeadMutation) SetIndustry(l lead.Industry) {
	m.industry = &l
}

// Industry returns the value of the "industry" field in the mutation.
func (m *LeadMutation) Industry() (r lead.Industry, exists bool) {
	v := m.industry
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustry returns the old "industry" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldIndustry(ctx context.Context) (v lead.Industry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustry: %w", err)
	}
	return oldValue.Industry, nil
}

// ResetIndustry resets all changes to the "industry" field.
func (m *LeadMutation) ResetIndustry() {
	m.industry = nil
}

// SetCountry sets the "country" field.
func (m *LeadMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *LeadMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *LeadMutation) ResetCountry() {
	m.country = nil
}

// SetCity sets the "city" field.
func (m *LeadMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *LeadMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *LeadMutation) ResetCity() {
	m.city = nil
}

// SetAddress sets the "address" field.
func (m *LeadMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *LeadMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *LeadMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[lead.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *LeadMutation) AddressCleared() bool {
	_, ok := m.clearedFields[lead.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *LeadMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, lead.FieldAddress)
}

// SetPostalCode sets the "postal_code" field.
func (m *LeadMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *LeadMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *LeadMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[lead.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *LeadMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[lead.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *LeadMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, lead.FieldPostalCode)
}

// SetPhone sets the "phone" field.
func (m *LeadMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *LeadMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *LeadMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[lead.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *LeadMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[lead.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *LeadMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, lead.FieldPhone)
}

// SetEmail sets the "email" field.
func (m *LeadMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *LeadMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *LeadMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[lead.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *LeadMutation) EmailCleared() bool {
	_, ok := m.clearedFields[lead.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *LeadMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, lead.FieldEmail)
}

// SetWebsite sets the "website" field.
func (m *LeadMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *LeadMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *LeadMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[lead.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *LeadMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[lead.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *LeadMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, lead.FieldWebsite)
}

// SetSocialMedia sets the "social_media" field.
func (m *LeadMutation) SetSocialMedia(value map[string]string) {
	m.social_media = &value
}

// SocialMedia returns the value of the "social_media" field in the mutation.
func (m *LeadMutation) SocialMedia() (r map[string]string, exists bool) {
	v := m.social_media
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialMedia returns the old "social_media" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldSocialMedia(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialMedia is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialMedia requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialMedia: %w", err)
	}
	return oldValue.SocialMedia, nil
}

// ClearSocialMedia clears the value of the "social_media" field.
func (m *LeadMutation) ClearSocialMedia() {
	m.social_media = nil
	m.clearedFields[lead.FieldSocialMedia] = struct{}{}
}

// SocialMediaCleared returns if the "social_media" field was cleared in this mutation.
func (m *LeadMutation) SocialMediaCleared() bool {
	_, ok := m.clearedFields[lead.FieldSocialMedia]
	return ok
}

// ResetSocialMedia resets all changes to the "social_media" field.
func (m *LeadMutation) ResetSocialMedia() {
	m.social_media = nil
	delete(m.clearedFields, lead.FieldSocialMedia)
}

// SetLatitude sets the "latitude" field.
func (m *LeadMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *LeadMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *LeadMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *LeadMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *LeadMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[lead.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *LeadMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[lead.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *LeadMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, lead.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *LeadMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *LeadMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *LeadMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *LeadMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *LeadMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[lead.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *LeadMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[lead.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *LeadMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, lead.FieldLongitude)
}

// SetVerified sets the "verified" field.
func (m *LeadMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *LeadMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *LeadMutation) ResetVerified() {
	m.verified = nil
}

// SetQualityScore sets the "quality_score" field.
func (m *LeadMutation) SetQualityScore(i int) {
	m.quality_score = &i
	m.addquality_score = nil
}

// QualityScore returns the value of the "quality_score" field in the mutation.
func (m *LeadMutation) QualityScore() (r int, exists bool) {
	v := m.quality_score
	if v == nil {
		return
	}
	return *v, true
}

// OldQualityScore returns the old "quality_score" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldQualityScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQualityScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQualityScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualityScore: %w", err)
	}
	return oldValue.QualityScore, nil
}

// AddQualityScore adds i to the "quality_score" field.
func (m *LeadMutation) AddQualityScore(i int) {
	if m.addquality_score != nil {
		*m.addquality_score += i
	} else {
		m.addquality_score = &i
	}
}

// AddedQualityScore returns the value that was added to the "quality_score" field in this mutation.
func (m *LeadMutation) AddedQualityScore() (r int, exists bool) {
	v := m.addquality_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetQualityScore resets all changes to the "quality_score" field.
func (m *LeadMutation) ResetQualityScore() {
	m.quality_score = nil
	m.addquality_score = nil
}

// SetOsmID sets the "osm_id" field.
func (m *LeadMutation) SetOsmID(s string) {
	m.osm_id = &s
}

// OsmID returns the value of the "osm_id" field in the mutation.
func (m *LeadMutation) OsmID() (r string, exists bool) {
	v := m.osm_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOsmID returns the old "osm_id" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldOsmID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsmID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsmID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsmID: %w", err)
	}
	return oldValue.OsmID, nil
}

// ClearOsmID clears the value of the "osm_id" field.
func (m *LeadMutation) ClearOsmID() {
	m.osm_id = nil
	m.clearedFields[lead.FieldOsmID] = struct{}{}
}

// OsmIDCleared returns if the "osm_id" field was cleared in this mutation.
func (m *LeadMutation) OsmIDCleared() bool {
	_, ok := m.clearedFields[lead.FieldOsmID]
	return ok
}

// ResetOsmID resets all changes to the "osm_id" field.
func (m *LeadMutation) ResetOsmID() {
	m.osm_id = nil
	delete(m.clearedFields, lead.FieldOsmID)
}

// SetMetadata sets the "metadata" field.
func (m *LeadMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *LeadMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *LeadMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[lead.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *LeadMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[lead.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *LeadMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, lead.FieldMetadata)
}

// SetSubNiche sets the "sub_niche" field.
func (m *LeadMutation) SetSubNiche(s string) {
	m.sub_niche = &s
}

// SubNiche returns the value of the "sub_niche" field in the mutation.
func (m *LeadMutation) SubNiche() (r string, exists bool) {
	v := m.sub_niche
	if v == nil {
		return
	}
	return *v, true
}

// OldSubNiche returns the old "sub_niche" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldSubNiche(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubNiche is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubNiche requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubNiche: %w", err)
	}
	return oldValue.SubNiche, nil
}

// ClearSubNiche clears the value of the "sub_niche" field.
func (m *LeadMutation) ClearSubNiche() {
	m.sub_niche = nil
	m.clearedFields[lead.FieldSubNiche] = struct{}{}
}

// SubNicheCleared returns if the "sub_niche" field was cleared in this mutation.
func (m *LeadMutation) SubNicheCleared() bool {
	_, ok := m.clearedFields[lead.FieldSubNiche]
	return ok
}

// ResetSubNiche resets all changes to the "sub_niche" field.
func (m *LeadMutation) ResetSubNiche() {
	m.sub_niche = nil
	delete(m.clearedFields, lead.FieldSubNiche)
}

// SetSpecialties sets the "specialties" field.
func (m *LeadMutation) SetSpecialties(s []string) {
	m.specialties = &s
	m.appendspecialties = nil
}

// Specialties returns the value of the "specialties" field in the mutation.
func (m *LeadMutation) Specialties() (r []string, exists bool) {
	v := m.specialties
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialties returns the old "specialties" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldSpecialties(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecialties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecialties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialties: %w", err)
	}
	return oldValue.Specialties, nil
}

// AppendSpecialties adds s to the "specialties" field.
func (m *LeadMutation) AppendSpecialties(s []string) {
	m.appendspecialties = append(m.appendspecialties, s...)
}

// AppendedSpecialties returns the list of values that were appended to the "specialties" field in this mutation.
func (m *LeadMutation) AppendedSpecialties() ([]string, bool) {
	if len(m.appendspecialties) == 0 {
		return nil, false
	}
	return m.appendspecialties, true
}

// ClearSpecialties clears the value of the "specialties" field.
func (m *LeadMutation) ClearSpecialties() {
	m.specialties = nil
	m.appendspecialties = nil
	m.clearedFields[lead.FieldSpecialties] = struct{}{}
}

// SpecialtiesCleared returns if the "specialties" field was cleared in this mutation.
func (m *LeadMutation) SpecialtiesCleared() bool {
	_, ok := m.clearedFields[lead.FieldSpecialties]
	return ok
}

// ResetSpecialties resets all changes to the "specialties" field.
func (m *LeadMutation) ResetSpecialties() {
	m.specialties = nil
	m.appendspecialties = nil
	delete(m.clearedFields, lead.FieldSpecialties)
}

// SetCuisineType sets the "cuisine_type" field.
func (m *LeadMutation) SetCuisineType(s string) {
	m.cuisine_type = &s
}

// CuisineType returns the value of the "cuisine_type" field in the mutation.
func (m *LeadMutation) CuisineType() (r string, exists bool) {
	v := m.cuisine_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCuisineType returns the old "cuisine_type" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCuisineType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCuisineType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCuisineType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCuisineType: %w", err)
	}
	return oldValue.CuisineType, nil
}

// ClearCuisineType clears the value of the "cuisine_type" field.
func (m *LeadMutation) ClearCuisineType() {
	m.cuisine_type = nil
	m.clearedFields[lead.FieldCuisineType] = struct{}{}
}

// CuisineTypeCleared returns if the "cuisine_type" field was cleared in this mutation.
func (m *LeadMutation) CuisineTypeCleared() bool {
	_, ok := m.clearedFields[lead.FieldCuisineType]
	return ok
}

// ResetCuisineType resets all changes to the "cuisine_type" field.
func (m *LeadMutation) ResetCuisineType() {
	m.cuisine_type = nil
	delete(m.clearedFields, lead.FieldCuisineType)
}

// SetSportType sets the "sport_type" field.
func (m *LeadMutation) SetSportType(s string) {
	m.sport_type = &s
}

// SportType returns the value of the "sport_type" field in the mutation.
func (m *LeadMutation) SportType() (r string, exists bool) {
	v := m.sport_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSportType returns the old "sport_type" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldSportType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSportType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSportType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSportType: %w", err)
	}
	return oldValue.SportType, nil
}

// ClearSportType clears the value of the "sport_type" field.
func (m *LeadMutation) ClearSportType() {
	m.sport_type = nil
	m.clearedFields[lead.FieldSportType] = struct{}{}
}

// SportTypeCleared returns if the "sport_type" field was cleared in this mutation.
func (m *LeadMutation) SportTypeCleared() bool {
	_, ok := m.clearedFields[lead.FieldSportType]
	return ok
}

// ResetSportType resets all changes to the "sport_type" field.
func (m *LeadMutation) ResetSportType() {
	m.sport_type = nil
	delete(m.clearedFields, lead.FieldSportType)
}

// SetTattooStyle sets the "tattoo_style" field.
func (m *LeadMutation) SetTattooStyle(s string) {
	m.tattoo_style = &s
}

// TattooStyle returns the value of the "tattoo_style" field in the mutation.
func (m *LeadMutation) TattooStyle() (r string, exists bool) {
	v := m.tattoo_style
	if v == nil {
		return
	}
	return *v, true
}

// OldTattooStyle returns the old "tattoo_style" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldTattooStyle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTattooStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTattooStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTattooStyle: %w", err)
	}
	return oldValue.TattooStyle, nil
}

// ClearTattooStyle clears the value of the "tattoo_style" field.
func (m *LeadMutation) ClearTattooStyle() {
	m.tattoo_style = nil
	m.clearedFields[lead.FieldTattooStyle] = struct{}{}
}

// TattooStyleCleared returns if the "tattoo_style" field was cleared in this mutation.
func (m *LeadMutation) TattooStyleCleared() bool {
	_, ok := m.clearedFields[lead.FieldTattooStyle]
	return ok
}

// ResetTattooStyle resets all changes to the "tattoo_style" field.
func (m *LeadMutation) ResetTattooStyle() {
	m.tattoo_style = nil
	delete(m.clearedFields, lead.FieldTattooStyle)
}

// SetCreatedAt sets the "created_at" field.
func (m *LeadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LeadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LeadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LeadMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LeadMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LeadMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the LeadMutation builder.
func (m *LeadMutation) Where(ps ...predicate.Lead) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lead, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lead).
func (m *LeadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeadMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.name != nil {
		fields = append(fields, lead.FieldName)
	}
	if m.industry != nil {
		fields = append(fields, lead.FieldIndustry)
	}
	if m.country != nil {
		fields = append(fields, lead.FieldCountry)
	}
	if m.city != nil {
		fields = append(fields, lead.FieldCity)
	}
	if m.address != nil {
		fields = append(fields, lead.FieldAddress)
	}
	if m.postal_code != nil {
		fields = append(fields, lead.FieldPostalCode)
	}
	if m.phone != nil {
		fields = append(fields, lead.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, lead.FieldEmail)
	}
	if m.website != nil {
		fields = append(fields, lead.FieldWebsite)
	}
	if m.social_media != nil {
		fields = append(fields, lead.FieldSocialMedia)
	}
	if m.latitude != nil {
		fields = append(fields, lead.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, lead.FieldLongitude)
	}
	if m.verified != nil {
		fields = append(fields, lead.FieldVerified)
	}
	if m.quality_score != nil {
		fields = append(fields, lead.FieldQualityScore)
	}
	if m.osm_id != nil {
		fields = append(fields, lead.FieldOsmID)
	}
	if m.metadata != nil {
		fields = append(fields, lead.FieldMetadata)
	}
	if m.sub_niche != nil {
		fields = append(fields, lead.FieldSubNiche)
	}
	if m.specialties != nil {
		fields = append(fields, lead.FieldSpecialties)
	}
	if m.cuisine_type != nil {
		fields = append(fields, lead.FieldCuisineType)
	}
	if m.sport_type != nil {
		fields = append(fields, lead.FieldSportType)
	}
	if m.tattoo_style != nil {
		fields = append(fields, lead.FieldTattooStyle)
	}
	if m.created_at != nil {
		fields = append(fields, lead.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, lead.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lead.FieldName:
		return m.Name()
	case lead.FieldIndustry:
		return m.Industry()
	case lead.FieldCountry:
		return m.Country()
	case lead.FieldCity:
		return m.City()
	case lead.FieldAddress:
		return m.Address()
	case lead.FieldPostalCode:
		return m.PostalCode()
	case lead.FieldPhone:
		return m.Phone()
	case lead.FieldEmail:
		return m.Email()
	case lead.FieldWebsite:
		return m.Website()
	case lead.FieldSocialMedia:
		return m.SocialMedia()
	case lead.FieldLatitude:
		return m.Latitude()
	case lead.FieldLongitude:
		return m.Longitude()
	case lead.FieldVerified:
		return m.Verified()
	case lead.FieldQualityScore:
		return m.QualityScore()
	case lead.FieldOsmID:
		return m.OsmID()
	case lead.FieldMetadata:
		return m.Metadata()
	case lead.FieldSubNiche:
		return m.SubNiche()
	case lead.FieldSpecialties:
		return m.Specialties()
	case lead.FieldCuisineType:
		return m.CuisineType()
	case lead.FieldSportType:
		return m.SportType()
	case lead.FieldTattooStyle:
		return m.TattooStyle()
	case lead.FieldCreatedAt:
		return m.CreatedAt()
	case lead.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lead.FieldName:
		return m.OldName(ctx)
	case lead.FieldIndustry:
		return m.OldIndustry(ctx)
	case lead.FieldCountry:
		return m.OldCountry(ctx)
	case lead.FieldCity:
		return m.OldCity(ctx)
	case lead.FieldAddress:
		return m.OldAddress(ctx)
	case lead.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case lead.FieldPhone:
		return m.OldPhone(ctx)
	case lead.FieldEmail:
		return m.OldEmail(ctx)
	case lead.FieldWebsite:
		return m.OldWebsite(ctx)
	case lead.FieldSocialMedia:
		return m.OldSocialMedia(ctx)
	case lead.FieldLatitude:
		return m.OldLatitude(ctx)
	case lead.FieldLongitude:
		return m.OldLongitude(ctx)
	case lead.FieldVerified:
		return m.OldVerified(ctx)
	case lead.FieldQualityScore:
		return m.OldQualityScore(ctx)
	case lead.FieldOsmID:
		return m.OldOsmID(ctx)
	case lead.FieldMetadata:
		return m.OldMetadata(ctx)
	case lead.FieldSubNiche:
		return m.OldSubNiche(ctx)
	case lead.FieldSpecialties:
		return m.OldSpecialties(ctx)
	case lead.FieldCuisineType:
		return m.OldCuisineType(ctx)
	case lead.FieldSportType:
		return m.OldSportType(ctx)
	case lead.FieldTattooStyle:
		return m.OldTattooStyle(ctx)
	case lead.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case lead.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Lead field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lead.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case lead.FieldIndustry:
		v, ok := value.(lead.Industry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustry(v)
		return nil
	case lead.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case lead.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case lead.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case lead.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case lead.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case lead.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case lead.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case lead.FieldSocialMedia:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialMedia(v)
		return nil
	case lead.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case lead.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case lead.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case lead.FieldQualityScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualityScore(v)
		return nil
	case lead.FieldOsmID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsmID(v)
		return nil
	case lead.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case lead.FieldSubNiche:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubNiche(v)
		return nil
	case lead.FieldSpecialties:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialties(v)
		return nil
	case lead.FieldCuisineType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCuisineType(v)
		return nil
	case lead.FieldSportType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSportType(v)
		return nil
	case lead.FieldTattooStyle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTattooStyle(v)
		return nil
	case lead.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case lead.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Lead field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeadMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, lead.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, lead.FieldLongitude)
	}
	if m.addquality_score != nil {
		fields = append(fields, lead.FieldQualityScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lead.FieldLatitude:
		return m.AddedLatitude()
	case lead.FieldLongitude:
		return m.AddedLongitude()
	case lead.FieldQualityScore:
		return m.AddedQualityScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lead.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case lead.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case lead.FieldQualityScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQualityScore(v)
		return nil
	}
	return fmt.Errorf("unknown Lead numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lead.FieldAddress) {
		fields = append(fields, lead.FieldAddress)
	}
	if m.FieldCleared(lead.FieldPostalCode) {
		fields = append(fields, lead.FieldPostalCode)
	}
	if m.FieldCleared(lead.FieldPhone) {
		fields = append(fields, lead.FieldPhone)
	}
	if m.FieldCleared(lead.FieldEmail) {
		fields = append(fields, lead.FieldEmail)
	}
	if m.FieldCleared(lead.FieldWebsite) {
		fields = append(fields, lead.FieldWebsite)
	}
	if m.FieldCleared(lead.FieldSocialMedia) {
		fields = append(fields, lead.FieldSocialMedia)
	}
	if m.FieldCleared(lead.FieldLatitude) {
		fields = append(fields, lead.FieldLatitude)
	}
	if m.FieldCleared(lead.FieldLongitude) {
		fields = append(fields, lead.FieldLongitude)
	}
	if m.FieldCleared(lead.FieldOsmID) {
		fields = append(fields, lead.FieldOsmID)
	}
	if m.FieldCleared(lead.FieldMetadata) {
		fields = append(fields, lead.FieldMetadata)
	}
	if m.FieldCleared(lead.FieldSubNiche) {
		fields = append(fields, lead.FieldSubNiche)
	}
	if m.FieldCleared(lead.FieldSpecialties) {
		fields = append(fields, lead.FieldSpecialties)
	}
	if m.FieldCleared(lead.FieldCuisineType) {
		fields = append(fields, lead.FieldCuisineType)
	}
	if m.FieldCleared(lead.FieldSportType) {
		fields = append(fields, lead.FieldSportType)
	}
	if m.FieldCleared(lead.FieldTattooStyle) {
		fields = append(fields, lead.FieldTattooStyle)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeadMutation) ClearField(name string) error {
	switch name {
	case lead.FieldAddress:
		m.ClearAddress()
		return nil
	case lead.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case lead.FieldPhone:
		m.ClearPhone()
		return nil
	case lead.FieldEmail:
		m.ClearEmail()
		return nil
	case lead.FieldWebsite:
		m.ClearWebsite()
		return nil
	case lead.FieldSocialMedia:
		m.ClearSocialMedia()
		return nil
	case lead.FieldLatitude:
		m.ClearLatitude()
		return nil
	case lead.FieldLongitude:
		m.ClearLongitude()
		return nil
	case lead.FieldOsmID:
		m.ClearOsmID()
		return nil
	case lead.FieldMetadata:
		m.ClearMetadata()
		return nil
	case lead.FieldSubNiche:
		m.ClearSubNiche()
		return nil
	case lead.FieldSpecialties:
		m.ClearSpecialties()
		return nil
	case lead.FieldCuisineType:
		m.ClearCuisineType()
		return nil
	case lead.FieldSportType:
		m.ClearSportType()
		return nil
	case lead.FieldTattooStyle:
		m.ClearTattooStyle()
		return nil
	}
	return fmt.Errorf("unknown Lead nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeadMutation) ResetField(name string) error {
	switch name {
	case lead.FieldName:
		m.ResetName()
		return nil
	case lead.FieldIndustry:
		m.ResetIndustry()
		return nil
	case lead.FieldCountry:
		m.ResetCountry()
		return nil
	case lead.FieldCity:
		m.ResetCity()
		return nil
	case lead.FieldAddress:
		m.ResetAddress()
		return nil
	case lead.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case lead.FieldPhone:
		m.ResetPhone()
		return nil
	case lead.FieldEmail:
		m.ResetEmail()
		return nil
	case lead.FieldWebsite:
		m.ResetWebsite()
		return nil
	case lead.FieldSocialMedia:
		m.ResetSocialMedia()
		return nil
	case lead.FieldLatitude:
		m.ResetLatitude()
		return nil
	case lead.FieldLongitude:
		m.ResetLongitude()
		return nil
	case lead.FieldVerified:
		m.ResetVerified()
		return nil
	case lead.FieldQualityScore:
		m.ResetQualityScore()
		return nil
	case lead.FieldOsmID:
		m.ResetOsmID()
		return nil
	case lead.FieldMetadata:
		m.ResetMetadata()
		return nil
	case lead.FieldSubNiche:
		m.ResetSubNiche()
		return nil
	case lead.FieldSpecialties:
		m.ResetSpecialties()
		return nil
	case lead.FieldCuisineType:
		m.ResetCuisineType()
		return nil
	case lead.FieldSportType:
		m.ResetSportType()
		return nil
	case lead.FieldTattooStyle:
		m.ResetTattooStyle()
		return nil
	case lead.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case lead.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Lead field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeadMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeadMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeadMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeadMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Lead unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeadMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Lead edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	slug               *string
	subscription_tier  *organization.SubscriptionTier
	usage_limit        *int
	addusage_limit     *int
	usage_count        *int
	addusage_count     *int
	last_reset_at      *time.Time
	stripe_customer_id *string
	billing_email      *string
	active             *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	owner              *int
	clearedowner       bool
	members            map[int]struct{}
	removedmembers     map[int]struct{}
	clearedmembers     bool
	exports            map[int]struct{}
	removedexports     map[int]struct{}
	clearedexports     bool
	done               bool
	oldValue           func(context.Context) (*Organization, error)
	predicates         []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *OrganizationMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *OrganizationMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *OrganizationMutation) ResetSlug() {
	m.slug = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *OrganizationMutation) SetOwnerID(i int) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *OrganizationMutation) OwnerID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *OrganizationMutation) ResetOwnerID() {
	m.owner = nil
}

// SetSubscriptionTier sets the "subscription_tier" field.
func (m *OrganizationMutation) SetSubscriptionTier(ot organization.SubscriptionTier) {
	m.subscription_tier = &ot
}

// SubscriptionTier returns the value of the "subscription_tier" field in the mutation.
func (m *OrganizationMutation) SubscriptionTier() (r organization.SubscriptionTier, exists bool) {
	v := m.subscription_tier
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionTier returns the old "subscription_tier" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSubscriptionTier(ctx context.Context) (v organization.SubscriptionTier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionTier: %w", err)
	}
	return oldValue.SubscriptionTier, nil
}

// ResetSubscriptionTier resets all changes to the "subscription_tier" field.
func (m *OrganizationMutation) ResetSubscriptionTier() {
	m.subscription_tier = nil
}

// SetUsageLimit sets the "usage_limit" field.
func (m *OrganizationMutation) SetUsageLimit(i int) {
	m.usage_limit = &i
	m.addusage_limit = nil
}

// UsageLimit returns the value of the "usage_limit" field in the mutation.
func (m *OrganizationMutation) UsageLimit() (r int, exists bool) {
	v := m.usage_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageLimit returns the old "usage_limit" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUsageLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageLimit: %w", err)
	}
	return oldValue.UsageLimit, nil
}

// AddUsageLimit adds i to the "usage_limit" field.
func (m *OrganizationMutation) AddUsageLimit(i int) {
	if m.addusage_limit != nil {
		*m.addusage_limit += i
	} else {
		m.addusage_limit = &i
	}
}

// AddedUsageLimit returns the value that was added to the "usage_limit" field in this mutation.
func (m *OrganizationMutation) AddedUsageLimit() (r int, exists bool) {
	v := m.addusage_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageLimit resets all changes to the "usage_limit" field.
func (m *OrganizationMutation) ResetUsageLimit() {
	m.usage_limit = nil
	m.addusage_limit = nil
}

// SetUsageCount sets the "usage_count" field.
func (m *OrganizationMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *OrganizationMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *OrganizationMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *OrganizationMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *OrganizationMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetLastResetAt sets the "last_reset_at" field.
func (m *OrganizationMutation) SetLastResetAt(t time.Time) {
	m.last_reset_at = &t
}

// LastResetAt returns the value of the "last_reset_at" field in the mutation.
func (m *OrganizationMutation) LastResetAt() (r time.Time, exists bool) {
	v := m.last_reset_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastResetAt returns the old "last_reset_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLastResetAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastResetAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastResetAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastResetAt: %w", err)
	}
	return oldValue.LastResetAt, nil
}

// ResetLastResetAt resets all changes to the "last_reset_at" field.
func (m *OrganizationMutation) ResetLastResetAt() {
	m.last_reset_at = nil
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *OrganizationMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *OrganizationMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldStripeCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (m *OrganizationMutation) ClearStripeCustomerID() {
	m.stripe_customer_id = nil
	m.clearedFields[organization.FieldStripeCustomerID] = struct{}{}
}

// StripeCustomerIDCleared returns if the "stripe_customer_id" field was cleared in this mutation.
func (m *OrganizationMutation) StripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldStripeCustomerID]
	return ok
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *OrganizationMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
	delete(m.clearedFields, organization.FieldStripeCustomerID)
}

// SetBillingEmail sets the "billing_email" field.
func (m *OrganizationMutation) SetBillingEmail(s string) {
	m.billing_email = &s
}

// BillingEmail returns the value of the "billing_email" field in the mutation.
func (m *OrganizationMutation) BillingEmail() (r string, exists bool) {
	v := m.billing_email
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingEmail returns the old "billing_email" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldBillingEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingEmail: %w", err)
	}
	return oldValue.BillingEmail, nil
}

// ClearBillingEmail clears the value of the "billing_email" field.
func (m *OrganizationMutation) ClearBillingEmail() {
	m.billing_email = nil
	m.clearedFields[organization.FieldBillingEmail] = struct{}{}
}

// BillingEmailCleared returns if the "billing_email" field was cleared in this mutation.
func (m *OrganizationMutation) BillingEmailCleared() bool {
	_, ok := m.clearedFields[organization.FieldBillingEmail]
	return ok
}

// ResetBillingEmail resets all changes to the "billing_email" field.
func (m *OrganizationMutation) ResetBillingEmail() {
	m.billing_email = nil
	delete(m.clearedFields, organization.FieldBillingEmail)
}

// SetActive sets the "active" field.
func (m *OrganizationMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *OrganizationMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *OrganizationMutation) ResetActive() {
	m.active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *OrganizationMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[organization.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *OrganizationMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *OrganizationMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddMemberIDs adds the "members" edge to the OrganizationMember entity by ids.
func (m *OrganizationMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the OrganizationMember entity.
func (m *OrganizationMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the OrganizationMember entity was cleared.
func (m *OrganizationMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the OrganizationMember entity by IDs.
func (m *OrganizationMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the OrganizationMember entity.
func (m *OrganizationMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *OrganizationMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *OrganizationMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddExportIDs adds the "exports" edge to the Export entity by ids.
func (m *OrganizationMutation) AddExportIDs(ids ...int) {
	if m.exports == nil {
		m.exports = make(map[int]struct{})
	}
	for i := range ids {
		m.exports[ids[i]] = struct{}{}
	}
}

// ClearExports clears the "exports" edge to the Export entity.
func (m *OrganizationMutation) ClearExports() {
	m.clearedexports = true
}

// ExportsCleared reports if the "exports" edge to the Export entity was cleared.
func (m *OrganizationMutation) ExportsCleared() bool {
	return m.clearedexports
}

// RemoveExportIDs removes the "exports" edge to the Export entity by IDs.
func (m *OrganizationMutation) RemoveExportIDs(ids ...int) {
	if m.removedexports == nil {
		m.removedexports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.exports, ids[i])
		m.removedexports[ids[i]] = struct{}{}
	}
}

// RemovedExports returns the removed IDs of the "exports" edge to the Export entity.
func (m *OrganizationMutation) RemovedExportsIDs() (ids []int) {
	for id := range m.removedexports {
		ids = append(ids, id)
	}
	return
}

// ExportsIDs returns the "exports" edge IDs in the mutation.
func (m *OrganizationMutation) ExportsIDs() (ids []int) {
	for id := range m.exports {
		ids = append(ids, id)
	}
	return
}

// ResetExports resets all changes to the "exports" edge.
func (m *OrganizationMutation) ResetExports() {
	m.exports = nil
	m.clearedexports = false
	m.removedexports = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, organization.FieldSlug)
	}
	if m.owner != nil {
		fields = append(fields, organization.FieldOwnerID)
	}
	if m.subscription_tier != nil {
		fields = append(fields, organization.FieldSubscriptionTier)
	}
	if m.usage_limit != nil {
		fields = append(fields, organization.FieldUsageLimit)
	}
	if m.usage_count != nil {
		fields = append(fields, organization.FieldUsageCount)
	}
	if m.last_reset_at != nil {
		fields = append(fields, organization.FieldLastResetAt)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, organization.FieldStripeCustomerID)
	}
	if m.billing_email != nil {
		fields = append(fields, organization.FieldBillingEmail)
	}
	if m.active != nil {
		fields = append(fields, organization.FieldActive)
	}
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldName:
		return m.Name()
	case organization.FieldSlug:
		return m.Slug()
	case organization.FieldOwnerID:
		return m.OwnerID()
	case organization.FieldSubscriptionTier:
		return m.SubscriptionTier()
	case organization.FieldUsageLimit:
		return m.UsageLimit()
	case organization.FieldUsageCount:
		return m.UsageCount()
	case organization.FieldLastResetAt:
		return m.LastResetAt()
	case organization.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case organization.FieldBillingEmail:
		return m.BillingEmail()
	case organization.FieldActive:
		return m.Active()
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldSlug:
		return m.OldSlug(ctx)
	case organization.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case organization.FieldSubscriptionTier:
		return m.OldSubscriptionTier(ctx)
	case organization.FieldUsageLimit:
		return m.OldUsageLimit(ctx)
	case organization.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case organization.FieldLastResetAt:
		return m.OldLastResetAt(ctx)
	case organization.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case organization.FieldBillingEmail:
		return m.OldBillingEmail(ctx)
	case organization.FieldActive:
		return m.OldActive(ctx)
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case organization.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case organization.FieldSubscriptionTier:
		v, ok := value.(organization.SubscriptionTier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionTier(v)
		return nil
	case organization.FieldUsageLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageLimit(v)
		return nil
	case organization.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case organization.FieldLastResetAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastResetAt(v)
		return nil
	case organization.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case organization.FieldBillingEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingEmail(v)
		return nil
	case organization.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	var fields []string
	if m.addusage_limit != nil {
		fields = append(fields, organization.FieldUsageLimit)
	}
	if m.addusage_count != nil {
		fields = append(fields, organization.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldUsageLimit:
		return m.AddedUsageLimit()
	case organization.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organization.FieldUsageLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageLimit(v)
		return nil
	case organization.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldStripeCustomerID) {
		fields = append(fields, organization.FieldStripeCustomerID)
	}
	if m.FieldCleared(organization.FieldBillingEmail) {
		fields = append(fields, organization.FieldBillingEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldStripeCustomerID:
		m.ClearStripeCustomerID()
		return nil
	case organization.FieldBillingEmail:
		m.ClearBillingEmail()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldSlug:
		m.ResetSlug()
		return nil
	case organization.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case organization.FieldSubscriptionTier:
		m.ResetSubscriptionTier()
		return nil
	case organization.FieldUsageLimit:
		m.ResetUsageLimit()
		return nil
	case organization.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case organization.FieldLastResetAt:
		m.ResetLastResetAt()
		return nil
	case organization.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case organization.FieldBillingEmail:
		m.ResetBillingEmail()
		return nil
	case organization.FieldActive:
		m.ResetActive()
		return nil
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, organization.EdgeOwner)
	}
	if m.members != nil {
		edges = append(edges, organization.EdgeMembers)
	}
	if m.exports != nil {
		edges = append(edges, organization.EdgeExports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeExports:
		ids := make([]ent.Value, 0, len(m.exports))
		for id := range m.exports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmembers != nil {
		edges = append(edges, organization.EdgeMembers)
	}
	if m.removedexports != nil {
		edges = append(edges, organization.EdgeExports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeExports:
		ids := make([]ent.Value, 0, len(m.removedexports))
		for id := range m.removedexports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, organization.EdgeOwner)
	}
	if m.clearedmembers {
		edges = append(edges, organization.EdgeMembers)
	}
	if m.clearedexports {
		edges = append(edges, organization.EdgeExports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeOwner:
		return m.clearedowner
	case organization.EdgeMembers:
		return m.clearedmembers
	case organization.EdgeExports:
		return m.clearedexports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeOwner:
		m.ResetOwner()
		return nil
	case organization.EdgeMembers:
		m.ResetMembers()
		return nil
	case organization.EdgeExports:
		m.ResetExports()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationMemberMutation represents an operation that mutates the OrganizationMember nodes in the graph.
type OrganizationMemberMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	role                *organizationmember.Role
	invited_by_email    *string
	status              *organizationmember.Status
	invited_at          *time.Time
	joined_at           *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	user                *int
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*OrganizationMember, error)
	predicates          []predicate.OrganizationMember
}

var _ ent.Mutation = (*OrganizationMemberMutation)(nil)

// organizationmemberOption allows management of the mutation configuration using functional options.
type organizationmemberOption func(*OrganizationMemberMutation)

// newOrganizationMemberMutation creates new mutation for the OrganizationMember entity.
func newOrganizationMemberMutation(c config, op Op, opts ...organizationmemberOption) *OrganizationMemberMutation {
	m := &OrganizationMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationMemberID sets the ID field of the mutation.
func withOrganizationMemberID(id int) organizationmemberOption {
	return func(m *OrganizationMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationMember
		)
		m.oldValue = func(ctx context.Context) (*OrganizationMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationMember sets the old OrganizationMember of the mutation.
func withOrganizationMember(node *OrganizationMember) organizationmemberOption {
	return func(m *OrganizationMemberMutation) {
		m.oldValue = func(context.Context) (*OrganizationMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationMemberMutation) SetOrganizationID(i int) {
	m.organization = &i
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationMemberMutation) OrganizationID() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldOrganizationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationMemberMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetUserID sets the "user_id" field.
func (m *OrganizationMemberMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrganizationMemberMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrganizationMemberMutation) ResetUserID() {
	m.user = nil
}

// SetRole sets the "role" field.
func (m *OrganizationMemberMutation) SetRole(o organizationmember.Role) {
	m.role = &o
}

// Role returns the value of the "role" field in the mutation.
func (m *OrganizationMemberMutation) Role() (r organizationmember.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldRole(ctx context.Context) (v organizationmember.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *OrganizationMemberMutation) ResetRole() {
	m.role = nil
}

// SetInvitedByEmail sets the "invited_by_email" field.
func (m *OrganizationMemberMutation) SetInvitedByEmail(s string) {
	m.invited_by_email = &s
}

// InvitedByEmail returns the value of the "invited_by_email" field in the mutation.
func (m *OrganizationMemberMutation) InvitedByEmail() (r string, exists bool) {
	v := m.invited_by_email
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitedByEmail returns the old "invited_by_email" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldInvitedByEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitedByEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitedByEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitedByEmail: %w", err)
	}
	return oldValue.InvitedByEmail, nil
}

// ClearInvitedByEmail clears the value of the "invited_by_email" field.
func (m *OrganizationMemberMutation) ClearInvitedByEmail() {
	m.invited_by_email = nil
	m.clearedFields[organizationmember.FieldInvitedByEmail] = struct{}{}
}

// InvitedByEmailCleared returns if the "invited_by_email" field was cleared in this mutation.
func (m *OrganizationMemberMutation) InvitedByEmailCleared() bool {
	_, ok := m.clearedFields[organizationmember.FieldInvitedByEmail]
	return ok
}

// ResetInvitedByEmail resets all changes to the "invited_by_email" field.
func (m *OrganizationMemberMutation) ResetInvitedByEmail() {
	m.invited_by_email = nil
	delete(m.clearedFields, organizationmember.FieldInvitedByEmail)
}

// SetStatus sets the "status" field.
func (m *OrganizationMemberMutation) SetStatus(o organizationmember.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrganizationMemberMutation) Status() (r organizationmember.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldStatus(ctx context.Context) (v organizationmember.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrganizationMemberMutation) ResetStatus() {
	m.status = nil
}

// SetInvitedAt sets the "invited_at" field.
func (m *OrganizationMemberMutation) SetInvitedAt(t time.Time) {
	m.invited_at = &t
}

// InvitedAt returns the value of the "invited_at" field in the mutation.
func (m *OrganizationMemberMutation) InvitedAt() (r time.Time, exists bool) {
	v := m.invited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitedAt returns the old "invited_at" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldInvitedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitedAt: %w", err)
	}
	return oldValue.InvitedAt, nil
}

// ClearInvitedAt clears the value of the "invited_at" field.
func (m *OrganizationMemberMutation) ClearInvitedAt() {
	m.invited_at = nil
	m.clearedFields[organizationmember.FieldInvitedAt] = struct{}{}
}

// InvitedAtCleared returns if the "invited_at" field was cleared in this mutation.
func (m *OrganizationMemberMutation) InvitedAtCleared() bool {
	_, ok := m.clearedFields[organizationmember.FieldInvitedAt]
	return ok
}

// ResetInvitedAt resets all changes to the "invited_at" field.
func (m *OrganizationMemberMutation) ResetInvitedAt() {
	m.invited_at = nil
	delete(m.clearedFields, organizationmember.FieldInvitedAt)
}

// SetJoinedAt sets the "joined_at" field.
func (m *OrganizationMemberMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *OrganizationMemberMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *OrganizationMemberMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationMember entity.
// If the OrganizationMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationMemberMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[organizationmember.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationMemberMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationMemberMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationMemberMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrganizationMemberMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[organizationmember.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrganizationMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrganizationMemberMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrganizationMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OrganizationMemberMutation builder.
func (m *OrganizationMemberMutation) Where(ps ...predicate.OrganizationMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationMember).
func (m *OrganizationMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMemberMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.organization != nil {
		fields = append(fields, organizationmember.FieldOrganizationID)
	}
	if m.user != nil {
		fields = append(fields, organizationmember.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, organizationmember.FieldRole)
	}
	if m.invited_by_email != nil {
		fields = append(fields, organizationmember.FieldInvitedByEmail)
	}
	if m.status != nil {
		fields = append(fields, organizationmember.FieldStatus)
	}
	if m.invited_at != nil {
		fields = append(fields, organizationmember.FieldInvitedAt)
	}
	if m.joined_at != nil {
		fields = append(fields, organizationmember.FieldJoinedAt)
	}
	if m.created_at != nil {
		fields = append(fields, organizationmember.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationmember.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationmember.FieldOrganizationID:
		return m.OrganizationID()
	case organizationmember.FieldUserID:
		return m.UserID()
	case organizationmember.FieldRole:
		return m.Role()
	case organizationmember.FieldInvitedByEmail:
		return m.InvitedByEmail()
	case organizationmember.FieldStatus:
		return m.Status()
	case organizationmember.FieldInvitedAt:
		return m.InvitedAt()
	case organizationmember.FieldJoinedAt:
		return m.JoinedAt()
	case organizationmember.FieldCreatedAt:
		return m.CreatedAt()
	case organizationmember.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationmember.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case organizationmember.FieldUserID:
		return m.OldUserID(ctx)
	case organizationmember.FieldRole:
		return m.OldRole(ctx)
	case organizationmember.FieldInvitedByEmail:
		return m.OldInvitedByEmail(ctx)
	case organizationmember.FieldStatus:
		return m.OldStatus(ctx)
	case organizationmember.FieldInvitedAt:
		return m.OldInvitedAt(ctx)
	case organizationmember.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case organizationmember.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationmember.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationmember.FieldOrganizationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case organizationmember.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case organizationmember.FieldRole:
		v, ok := value.(organizationmember.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case organizationmember.FieldInvitedByEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitedByEmail(v)
		return nil
	case organizationmember.FieldStatus:
		v, ok := value.(organizationmember.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case organizationmember.FieldInvitedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitedAt(v)
		return nil
	case organizationmember.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case organizationmember.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationmember.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMemberMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationmember.FieldInvitedByEmail) {
		fields = append(fields, organizationmember.FieldInvitedByEmail)
	}
	if m.FieldCleared(organizationmember.FieldInvitedAt) {
		fields = append(fields, organizationmember.FieldInvitedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMemberMutation) ClearField(name string) error {
	switch name {
	case organizationmember.FieldInvitedByEmail:
		m.ClearInvitedByEmail()
		return nil
	case organizationmember.FieldInvitedAt:
		m.ClearInvitedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMemberMutation) ResetField(name string) error {
	switch name {
	case organizationmember.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case organizationmember.FieldUserID:
		m.ResetUserID()
		return nil
	case organizationmember.FieldRole:
		m.ResetRole()
		return nil
	case organizationmember.FieldInvitedByEmail:
		m.ResetInvitedByEmail()
		return nil
	case organizationmember.FieldStatus:
		m.ResetStatus()
		return nil
	case organizationmember.FieldInvitedAt:
		m.ResetInvitedAt()
		return nil
	case organizationmember.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case organizationmember.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationmember.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, organizationmember.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, organizationmember.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationmember.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case organizationmember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, organizationmember.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, organizationmember.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationmember.EdgeOrganization:
		return m.clearedorganization
	case organizationmember.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMemberMutation) ClearEdge(name string) error {
	switch name {
	case organizationmember.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case organizationmember.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMemberMutation) ResetEdge(name string) error {
	switch name {
	case organizationmember.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case organizationmember.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OrganizationMember edge %s", name)
}

// SavedSearchMutation represents an operation that mutates the SavedSearch nodes in the graph.
type SavedSearchMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	filters       *map[string]interface{}
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*SavedSearch, error)
	predicates    []predicate.SavedSearch
}

var _ ent.Mutation = (*SavedSearchMutation)(nil)

// savedsearchOption allows management of the mutation configuration using functional options.
type savedsearchOption func(*SavedSearchMutation)

// newSavedSearchMutation creates new mutation for the SavedSearch entity.
func newSavedSearchMutation(c config, op Op, opts ...savedsearchOption) *SavedSearchMutation {
	m := &SavedSearchMutation{
		config:        c,
		op:            op,
		typ:           TypeSavedSearch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSavedSearchID sets the ID field of the mutation.
func withSavedSearchID(id int) savedsearchOption {
	return func(m *SavedSearchMutation) {
		var (
			err   error
			once  sync.Once
			value *SavedSearch
		)
		m.oldValue = func(ctx context.Context) (*SavedSearch, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SavedSearch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSavedSearch sets the old SavedSearch of the mutation.
func withSavedSearch(node *SavedSearch) savedsearchOption {
	return func(m *SavedSearchMutation) {
		m.oldValue = func(context.Context) (*SavedSearch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SavedSearchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SavedSearchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SavedSearchMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SavedSearchMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SavedSearch.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SavedSearchMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SavedSearchMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SavedSearch entity.
// If the SavedSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SavedSearchMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SavedSearchMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *SavedSearchMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SavedSearchMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SavedSearch entity.
// If the SavedSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SavedSearchMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SavedSearchMutation) ResetName() {
	m.name = nil
}

// SetFilters sets the "filters" field.
func (m *SavedSearchMutation) SetFilters(value map[string]interface{}) {
	m.filters = &value
}

// Filters returns the value of the "filters" field in the mutation.
func (m *SavedSearchMutation) Filters() (r map[string]interface{}, exists bool) {
	v := m.filters
	if v == nil {
		return
	}
	return *v, true
}

// OldFilters returns the old "filters" field's value of the SavedSearch entity.
// If the SavedSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SavedSearchMutation) OldFilters(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilters: %w", err)
	}
	return oldValue.Filters, nil
}

// ResetFilters resets all changes to the "filters" field.
func (m *SavedSearchMutation) ResetFilters() {
	m.filters = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SavedSearchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SavedSearchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SavedSearch entity.
// If the SavedSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SavedSearchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SavedSearchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SavedSearchMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SavedSearchMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SavedSearch entity.
// If the SavedSearch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SavedSearchMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SavedSearchMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SavedSearchMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[savedsearch.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SavedSearchMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SavedSearchMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SavedSearchMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SavedSearchMutation builder.
func (m *SavedSearchMutation) Where(ps ...predicate.SavedSearch) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SavedSearchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SavedSearchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SavedSearch, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SavedSearchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SavedSearchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SavedSearch).
func (m *SavedSearchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SavedSearchMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, savedsearch.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, savedsearch.FieldName)
	}
	if m.filters != nil {
		fields = append(fields, savedsearch.FieldFilters)
	}
	if m.created_at != nil {
		fields = append(fields, savedsearch.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, savedsearch.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SavedSearchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case savedsearch.FieldUserID:
		return m.UserID()
	case savedsearch.FieldName:
		return m.Name()
	case savedsearch.FieldFilters:
		return m.Filters()
	case savedsearch.FieldCreatedAt:
		return m.CreatedAt()
	case savedsearch.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SavedSearchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case savedsearch.FieldUserID:
		return m.OldUserID(ctx)
	case savedsearch.FieldName:
		return m.OldName(ctx)
	case savedsearch.FieldFilters:
		return m.OldFilters(ctx)
	case savedsearch.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case savedsearch.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SavedSearch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SavedSearchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case savedsearch.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case savedsearch.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case savedsearch.FieldFilters:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilters(v)
		return nil
	case savedsearch.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case savedsearch.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SavedSearch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SavedSearchMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SavedSearchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SavedSearchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SavedSearch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SavedSearchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SavedSearchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SavedSearchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SavedSearch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SavedSearchMutation) ResetField(name string) error {
	switch name {
	case savedsearch.FieldUserID:
		m.ResetUserID()
		return nil
	case savedsearch.FieldName:
		m.ResetName()
		return nil
	case savedsearch.FieldFilters:
		m.ResetFilters()
		return nil
	case savedsearch.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case savedsearch.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SavedSearch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SavedSearchMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, savedsearch.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SavedSearchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case savedsearch.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SavedSearchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SavedSearchMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SavedSearchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, savedsearch.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SavedSearchMutation) EdgeCleared(name string) bool {
	switch name {
	case savedsearch.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SavedSearchMutation) ClearEdge(name string) error {
	switch name {
	case savedsearch.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown SavedSearch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SavedSearchMutation) ResetEdge(name string) error {
	switch name {
	case savedsearch.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown SavedSearch edge %s", name)
}

// SubscriptionMutation represents an operation that mutates the Subscription nodes in the graph.
type SubscriptionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	tier                   *subscription.Tier
	status                 *subscription.Status
	stripe_subscription_id *string
	stripe_price_id        *string
	current_period_start   *time.Time
	current_period_end     *time.Time
	cancel_at_period_end   *bool
	canceled_at            *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	user                   *int
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*Subscription, error)
	predicates             []predicate.Subscription
}

var _ ent.Mutation = (*SubscriptionMutation)(nil)

// subscriptionOption allows management of the mutation configuration using functional options.
type subscriptionOption func(*SubscriptionMutation)

// newSubscriptionMutation creates new mutation for the Subscription entity.
func newSubscriptionMutation(c config, op Op, opts ...subscriptionOption) *SubscriptionMutation {
	m := &SubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionID sets the ID field of the mutation.
func withSubscriptionID(id int) subscriptionOption {
	return func(m *SubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscription
		)
		m.oldValue = func(ctx context.Context) (*Subscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscription sets the old Subscription of the mutation.
func withSubscription(node *Subscription) subscriptionOption {
	return func(m *SubscriptionMutation) {
		m.oldValue = func(context.Context) (*Subscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SubscriptionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SubscriptionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SubscriptionMutation) ResetUserID() {
	m.user = nil
}

// SetTier sets the "tier" field.
func (m *SubscriptionMutation) SetTier(s subscription.Tier) {
	m.tier = &s
}

// Tier returns the value of the "tier" field in the mutation.
func (m *SubscriptionMutation) Tier() (r subscription.Tier, exists bool) {
	v := m.tier
	if v == nil {
		return
	}
	return *v, true
}

// OldTier returns the old "tier" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldTier(ctx context.Context) (v subscription.Tier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTier: %w", err)
	}
	return oldValue.Tier, nil
}

// ResetTier resets all changes to the "tier" field.
func (m *SubscriptionMutation) ResetTier() {
	m.tier = nil
}

// SetStatus sets the "status" field.
func (m *SubscriptionMutation) SetStatus(s subscription.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SubscriptionMutation) Status() (r subscription.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldStatus(ctx context.Context) (v subscription.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SubscriptionMutation) ResetStatus() {
	m.status = nil
}

// SetStripeSubscriptionID sets the "stripe_subscription_id" field.
func (m *SubscriptionMutation) SetStripeSubscriptionID(s string) {
	m.stripe_subscription_id = &s
}

// StripeSubscriptionID returns the value of the "stripe_subscription_id" field in the mutation.
func (m *SubscriptionMutation) StripeSubscriptionID() (r string, exists bool) {
	v := m.stripe_subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeSubscriptionID returns the old "stripe_subscription_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldStripeSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeSubscriptionID: %w", err)
	}
	return oldValue.StripeSubscriptionID, nil
}

// ClearStripeSubscriptionID clears the value of the "stripe_subscription_id" field.
func (m *SubscriptionMutation) ClearStripeSubscriptionID() {
	m.stripe_subscription_id = nil
	m.clearedFields[subscription.FieldStripeSubscriptionID] = struct{}{}
}

// StripeSubscriptionIDCleared returns if the "stripe_subscription_id" field was cleared in this mutation.
func (m *SubscriptionMutation) StripeSubscriptionIDCleared() bool {
	_, ok := m.clearedFields[subscription.FieldStripeSubscriptionID]
	return ok
}

// ResetStripeSubscriptionID resets all changes to the "stripe_subscription_id" field.
func (m *SubscriptionMutation) ResetStripeSubscriptionID() {
	m.stripe_subscription_id = nil
	delete(m.clearedFields, subscription.FieldStripeSubscriptionID)
}

// SetStripePriceID sets the "stripe_price_id" field.
func (m *SubscriptionMutation) SetStripePriceID(s string) {
	m.stripe_price_id = &s
}

// StripePriceID returns the value of the "stripe_price_id" field in the mutation.
func (m *SubscriptionMutation) StripePriceID() (r string, exists bool) {
	v := m.stripe_price_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripePriceID returns the old "stripe_price_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldStripePriceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripePriceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripePriceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripePriceID: %w", err)
	}
	return oldValue.StripePriceID, nil
}

// ClearStripePriceID clears the value of the "stripe_price_id" field.
func (m *SubscriptionMutation) ClearStripePriceID() {
	m.stripe_price_id = nil
	m.clearedFields[subscription.FieldStripePriceID] = struct{}{}
}

// StripePriceIDCleared returns if the "stripe_price_id" field was cleared in this mutation.
func (m *SubscriptionMutation) StripePriceIDCleared() bool {
	_, ok := m.clearedFields[subscription.FieldStripePriceID]
	return ok
}

// ResetStripePriceID resets all changes to the "stripe_price_id" field.
func (m *SubscriptionMutation) ResetStripePriceID() {
	m.stripe_price_id = nil
	delete(m.clearedFields, subscription.FieldStripePriceID)
}

// SetCurrentPeriodStart sets the "current_period_start" field.
func (m *SubscriptionMutation) SetCurrentPeriodStart(t time.Time) {
	m.current_period_start = &t
}

// CurrentPeriodStart returns the value of the "current_period_start" field in the mutation.
func (m *SubscriptionMutation) CurrentPeriodStart() (r time.Time, exists bool) {
	v := m.current_period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPeriodStart returns the old "current_period_start" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCurrentPeriodStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPeriodStart: %w", err)
	}
	return oldValue.CurrentPeriodStart, nil
}

// ClearCurrentPeriodStart clears the value of the "current_period_start" field.
func (m *SubscriptionMutation) ClearCurrentPeriodStart() {
	m.current_period_start = nil
	m.clearedFields[subscription.FieldCurrentPeriodStart] = struct{}{}
}

// CurrentPeriodStartCleared returns if the "current_period_start" field was cleared in this mutation.
func (m *SubscriptionMutation) CurrentPeriodStartCleared() bool {
	_, ok := m.clearedFields[subscription.FieldCurrentPeriodStart]
	return ok
}

// ResetCurrentPeriodStart resets all changes to the "current_period_start" field.
func (m *SubscriptionMutation) ResetCurrentPeriodStart() {
	m.current_period_start = nil
	delete(m.clearedFields, subscription.FieldCurrentPeriodStart)
}

// SetCurrentPeriodEnd sets the "current_period_end" field.
func (m *SubscriptionMutation) SetCurrentPeriodEnd(t time.Time) {
	m.current_period_end = &t
}

// CurrentPeriodEnd returns the value of the "current_period_end" field in the mutation.
func (m *SubscriptionMutation) CurrentPeriodEnd() (r time.Time, exists bool) {
	v := m.current_period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPeriodEnd returns the old "current_period_end" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCurrentPeriodEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPeriodEnd: %w", err)
	}
	return oldValue.CurrentPeriodEnd, nil
}

// ClearCurrentPeriodEnd clears the value of the "current_period_end" field.
func (m *SubscriptionMutation) ClearCurrentPeriodEnd() {
	m.current_period_end = nil
	m.clearedFields[subscription.FieldCurrentPeriodEnd] = struct{}{}
}

// CurrentPeriodEndCleared returns if the "current_period_end" field was cleared in this mutation.
func (m *SubscriptionMutation) CurrentPeriodEndCleared() bool {
	_, ok := m.clearedFields[subscription.FieldCurrentPeriodEnd]
	return ok
}

// ResetCurrentPeriodEnd resets all changes to the "current_period_end" field.
func (m *SubscriptionMutation) ResetCurrentPeriodEnd() {
	m.current_period_end = nil
	delete(m.clearedFields, subscription.FieldCurrentPeriodEnd)
}

// SetCancelAtPeriodEnd sets the "cancel_at_period_end" field.
func (m *SubscriptionMutation) SetCancelAtPeriodEnd(b bool) {
	m.cancel_at_period_end = &b
}

// CancelAtPeriodEnd returns the value of the "cancel_at_period_end" field in the mutation.
func (m *SubscriptionMutation) CancelAtPeriodEnd() (r bool, exists bool) {
	v := m.cancel_at_period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelAtPeriodEnd returns the old "cancel_at_period_end" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCancelAtPeriodEnd(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelAtPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelAtPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelAtPeriodEnd: %w", err)
	}
	return oldValue.CancelAtPeriodEnd, nil
}

// ResetCancelAtPeriodEnd resets all changes to the "cancel_at_period_end" field.
func (m *SubscriptionMutation) ResetCancelAtPeriodEnd() {
	m.cancel_at_period_end = nil
}

// SetCanceledAt sets the "canceled_at" field.
func (m *SubscriptionMutation) SetCanceledAt(t time.Time) {
	m.canceled_at = &t
}

// CanceledAt returns the value of the "canceled_at" field in the mutation.
func (m *SubscriptionMutation) CanceledAt() (r time.Time, exists bool) {
	v := m.canceled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCanceledAt returns the old "canceled_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCanceledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanceledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanceledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanceledAt: %w", err)
	}
	return oldValue.CanceledAt, nil
}

// ClearCanceledAt clears the value of the "canceled_at" field.
func (m *SubscriptionMutation) ClearCanceledAt() {
	m.canceled_at = nil
	m.clearedFields[subscription.FieldCanceledAt] = struct{}{}
}

// CanceledAtCleared returns if the "canceled_at" field was cleared in this mutation.
func (m *SubscriptionMutation) CanceledAtCleared() bool {
	_, ok := m.clearedFields[subscription.FieldCanceledAt]
	return ok
}

// ResetCanceledAt resets all changes to the "canceled_at" field.
func (m *SubscriptionMutation) ResetCanceledAt() {
	m.canceled_at = nil
	delete(m.clearedFields, subscription.FieldCanceledAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[subscription.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SubscriptionMutation builder.
func (m *SubscriptionMutation) Where(ps ...predicate.Subscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscription).
func (m *SubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, subscription.FieldUserID)
	}
	if m.tier != nil {
		fields = append(fields, subscription.FieldTier)
	}
	if m.status != nil {
		fields = append(fields, subscription.FieldStatus)
	}
	if m.stripe_subscription_id != nil {
		fields = append(fields, subscription.FieldStripeSubscriptionID)
	}
	if m.stripe_price_id != nil {
		fields = append(fields, subscription.FieldStripePriceID)
	}
	if m.current_period_start != nil {
		fields = append(fields, subscription.FieldCurrentPeriodStart)
	}
	if m.current_period_end != nil {
		fields = append(fields, subscription.FieldCurrentPeriodEnd)
	}
	if m.cancel_at_period_end != nil {
		fields = append(fields, subscription.FieldCancelAtPeriodEnd)
	}
	if m.canceled_at != nil {
		fields = append(fields, subscription.FieldCanceledAt)
	}
	if m.created_at != nil {
		fields = append(fields, subscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscription.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldUserID:
		return m.UserID()
	case subscription.FieldTier:
		return m.Tier()
	case subscription.FieldStatus:
		return m.Status()
	case subscription.FieldStripeSubscriptionID:
		return m.StripeSubscriptionID()
	case subscription.FieldStripePriceID:
		return m.StripePriceID()
	case subscription.FieldCurrentPeriodStart:
		return m.CurrentPeriodStart()
	case subscription.FieldCurrentPeriodEnd:
		return m.CurrentPeriodEnd()
	case subscription.FieldCancelAtPeriodEnd:
		return m.CancelAtPeriodEnd()
	case subscription.FieldCanceledAt:
		return m.CanceledAt()
	case subscription.FieldCreatedAt:
		return m.CreatedAt()
	case subscription.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscription.FieldUserID:
		return m.OldUserID(ctx)
	case subscription.FieldTier:
		return m.OldTier(ctx)
	case subscription.FieldStatus:
		return m.OldStatus(ctx)
	case subscription.FieldStripeSubscriptionID:
		return m.OldStripeSubscriptionID(ctx)
	case subscription.FieldStripePriceID:
		return m.OldStripePriceID(ctx)
	case subscription.FieldCurrentPeriodStart:
		return m.OldCurrentPeriodStart(ctx)
	case subscription.FieldCurrentPeriodEnd:
		return m.OldCurrentPeriodEnd(ctx)
	case subscription.FieldCancelAtPeriodEnd:
		return m.OldCancelAtPeriodEnd(ctx)
	case subscription.FieldCanceledAt:
		return m.OldCanceledAt(ctx)
	case subscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Subscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case subscription.FieldTier:
		v, ok := value.(subscription.Tier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTier(v)
		return nil
	case subscription.FieldStatus:
		v, ok := value.(subscription.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case subscription.FieldStripeSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeSubscriptionID(v)
		return nil
	case subscription.FieldStripePriceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripePriceID(v)
		return nil
	case subscription.FieldCurrentPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPeriodStart(v)
		return nil
	case subscription.FieldCurrentPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPeriodEnd(v)
		return nil
	case subscription.FieldCancelAtPeriodEnd:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelAtPeriodEnd(v)
		return nil
	case subscription.FieldCanceledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanceledAt(v)
		return nil
	case subscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscription.FieldStripeSubscriptionID) {
		fields = append(fields, subscription.FieldStripeSubscriptionID)
	}
	if m.FieldCleared(subscription.FieldStripePriceID) {
		fields = append(fields, subscription.FieldStripePriceID)
	}
	if m.FieldCleared(subscription.FieldCurrentPeriodStart) {
		fields = append(fields, subscription.FieldCurrentPeriodStart)
	}
	if m.FieldCleared(subscription.FieldCurrentPeriodEnd) {
		fields = append(fields, subscription.FieldCurrentPeriodEnd)
	}
	if m.FieldCleared(subscription.FieldCanceledAt) {
		fields = append(fields, subscription.FieldCanceledAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionMutation) ClearField(name string) error {
	switch name {
	case subscription.FieldStripeSubscriptionID:
		m.ClearStripeSubscriptionID()
		return nil
	case subscription.FieldStripePriceID:
		m.ClearStripePriceID()
		return nil
	case subscription.FieldCurrentPeriodStart:
		m.ClearCurrentPeriodStart()
		return nil
	case subscription.FieldCurrentPeriodEnd:
		m.ClearCurrentPeriodEnd()
		return nil
	case subscription.FieldCanceledAt:
		m.ClearCanceledAt()
		return nil
	}
	return fmt.Errorf("unknown Subscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionMutation) ResetField(name string) error {
	switch name {
	case subscription.FieldUserID:
		m.ResetUserID()
		return nil
	case subscription.FieldTier:
		m.ResetTier()
		return nil
	case subscription.FieldStatus:
		m.ResetStatus()
		return nil
	case subscription.FieldStripeSubscriptionID:
		m.ResetStripeSubscriptionID()
		return nil
	case subscription.FieldStripePriceID:
		m.ResetStripePriceID()
		return nil
	case subscription.FieldCurrentPeriodStart:
		m.ResetCurrentPeriodStart()
		return nil
	case subscription.FieldCurrentPeriodEnd:
		m.ResetCurrentPeriodEnd()
		return nil
	case subscription.FieldCancelAtPeriodEnd:
		m.ResetCancelAtPeriodEnd()
		return nil
	case subscription.FieldCanceledAt:
		m.ResetCanceledAt()
		return nil
	case subscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, subscription.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, subscription.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case subscription.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Subscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Subscription edge %s", name)
}

// UsageLogMutation represents an operation that mutates the UsageLog nodes in the graph.
type UsageLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	action        *usagelog.Action
	count         *int
	addcount      *int
	metadata      *map[string]interface{}
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UsageLog, error)
	predicates    []predicate.UsageLog
}

var _ ent.Mutation = (*UsageLogMutation)(nil)

// usagelogOption allows management of the mutation configuration using functional options.
type usagelogOption func(*UsageLogMutation)

// newUsageLogMutation creates new mutation for the UsageLog entity.
func newUsageLogMutation(c config, op Op, opts ...usagelogOption) *UsageLogMutation {
	m := &UsageLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageLogID sets the ID field of the mutation.
func withUsageLogID(id int) usagelogOption {
	return func(m *UsageLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageLog
		)
		m.oldValue = func(ctx context.Context) (*UsageLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageLog sets the old UsageLog of the mutation.
func withUsageLog(node *UsageLog) usagelogOption {
	return func(m *UsageLogMutation) {
		m.oldValue = func(context.Context) (*UsageLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UsageLogMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UsageLogMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UsageLogMutation) ResetUserID() {
	m.user = nil
}

// SetAction sets the "action" field.
func (m *UsageLogMutation) SetAction(u usagelog.Action) {
	m.action = &u
}

// Action returns the value of the "action" field in the mutation.
func (m *UsageLogMutation) Action() (r usagelog.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldAction(ctx context.Context) (v usagelog.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *UsageLogMutation) ResetAction() {
	m.action = nil
}

// SetCount sets the "count" field.
func (m *UsageLogMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *UsageLogMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *UsageLogMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *UsageLogMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *UsageLogMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetMetadata sets the "metadata" field.
func (m *UsageLogMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *UsageLogMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *UsageLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[usagelog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *UsageLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *UsageLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, usagelog.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UsageLogMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usagelog.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UsageLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UsageLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UsageLogMutation builder.
func (m *UsageLogMutation) Where(ps ...predicate.UsageLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageLog).
func (m *UsageLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageLogMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, usagelog.FieldUserID)
	}
	if m.action != nil {
		fields = append(fields, usagelog.FieldAction)
	}
	if m.count != nil {
		fields = append(fields, usagelog.FieldCount)
	}
	if m.metadata != nil {
		fields = append(fields, usagelog.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, usagelog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldUserID:
		return m.UserID()
	case usagelog.FieldAction:
		return m.Action()
	case usagelog.FieldCount:
		return m.Count()
	case usagelog.FieldMetadata:
		return m.Metadata()
	case usagelog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagelog.FieldUserID:
		return m.OldUserID(ctx)
	case usagelog.FieldAction:
		return m.OldAction(ctx)
	case usagelog.FieldCount:
		return m.OldCount(ctx)
	case usagelog.FieldMetadata:
		return m.OldMetadata(ctx)
	case usagelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UsageLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usagelog.FieldAction:
		v, ok := value.(usagelog.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case usagelog.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case usagelog.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case usagelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageLogMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, usagelog.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagelog.FieldMetadata) {
		fields = append(fields, usagelog.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageLogMutation) ClearField(name string) error {
	switch name {
	case usagelog.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown UsageLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageLogMutation) ResetField(name string) error {
	switch name {
	case usagelog.FieldUserID:
		m.ResetUserID()
		return nil
	case usagelog.FieldAction:
		m.ResetAction()
		return nil
	case usagelog.FieldCount:
		m.ResetCount()
		return nil
	case usagelog.FieldMetadata:
		m.ResetMetadata()
		return nil
	case usagelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usagelog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagelog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usagelog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageLogMutation) EdgeCleared(name string) bool {
	switch name {
	case usagelog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageLogMutation) ClearEdge(name string) error {
	switch name {
	case usagelog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UsageLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageLogMutation) ResetEdge(name string) error {
	switch name {
	case usagelog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UsageLog edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	email                               *string
	password_hash                       *string
	name                                *string
	subscription_tier                   *user.SubscriptionTier
	role                                *user.Role
	usage_count                         *int
	addusage_count                      *int
	usage_limit                         *int
	addusage_limit                      *int
	last_reset_at                       *time.Time
	last_login_at                       *time.Time
	email_verified                      *bool
	email_verification_token            *string
	email_verification_token_expires_at *time.Time
	email_verified_at                   *time.Time
	accepted_terms_at                   *time.Time
	onboarding_completed                *bool
	totp_enabled                        *bool
	totp_secret                         *string
	oauth_provider                      *string
	oauth_id                            *string
	stripe_customer_id                  *string
	created_at                          *time.Time
	updated_at                          *time.Time
	deleted_at                          *time.Time
	onboarding_step                     *int
	addonboarding_step                  *int
	clearedFields                       map[string]struct{}
	subscriptions                       map[int]struct{}
	removedsubscriptions                map[int]struct{}
	clearedsubscriptions                bool
	exports                             map[int]struct{}
	removedexports                      map[int]struct{}
	clearedexports                      bool
	api_keys                            map[int]struct{}
	removedapi_keys                     map[int]struct{}
	clearedapi_keys                     bool
	audit_logs                          map[int]struct{}
	removedaudit_logs                   map[int]struct{}
	clearedaudit_logs                   bool
	usage_logs                          map[int]struct{}
	removedusage_logs                   map[int]struct{}
	clearedusage_logs                   bool
	owned_organizations                 map[int]struct{}
	removedowned_organizations          map[int]struct{}
	clearedowned_organizations          bool
	organization_memberships            map[int]struct{}
	removedorganization_memberships     map[int]struct{}
	clearedorganization_memberships     bool
	saved_searches                      map[int]struct{}
	removedsaved_searches               map[int]struct{}
	clearedsaved_searches               bool
	webhooks                            map[int]struct{}
	removedwebhooks                     map[int]struct{}
	clearedwebhooks                     bool
	done                                bool
	oldValue                            func(context.Context) (*User, error)
	predicates                          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetSubscriptionTier sets the "subscription_tier" field.
func (m *UserMutation) SetSubscriptionTier(ut user.SubscriptionTier) {
	m.subscription_tier = &ut
}

// SubscriptionTier returns the value of the "subscription_tier" field in the mutation.
func (m *UserMutation) SubscriptionTier() (r user.SubscriptionTier, exists bool) {
	v := m.subscription_tier
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionTier returns the old "subscription_tier" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSubscriptionTier(ctx context.Context) (v user.SubscriptionTier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionTier: %w", err)
	}
	return oldValue.SubscriptionTier, nil
}

// ResetSubscriptionTier resets all changes to the "subscription_tier" field.
func (m *UserMutation) ResetSubscriptionTier() {
	m.subscription_tier = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetUsageCount sets the "usage_count" field.
func (m *UserMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *UserMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *UserMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *UserMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *UserMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetUsageLimit sets the "usage_limit" field.
func (m *UserMutation) SetUsageLimit(i int) {
	m.usage_limit = &i
	m.addusage_limit = nil
}

// UsageLimit returns the value of the "usage_limit" field in the mutation.
func (m *UserMutation) UsageLimit() (r int, exists bool) {
	v := m.usage_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageLimit returns the old "usage_limit" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsageLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageLimit: %w", err)
	}
	return oldValue.UsageLimit, nil
}

// AddUsageLimit adds i to the "usage_limit" field.
func (m *UserMutation) AddUsageLimit(i int) {
	if m.addusage_limit != nil {
		*m.addusage_limit += i
	} else {
		m.addusage_limit = &i
	}
}

// AddedUsageLimit returns the value that was added to the "usage_limit" field in this mutation.
func (m *UserMutation) AddedUsageLimit() (r int, exists bool) {
	v := m.addusage_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageLimit resets all changes to the "usage_limit" field.
func (m *UserMutation) ResetUsageLimit() {
	m.usage_limit = nil
	m.addusage_limit = nil
}

// SetLastResetAt sets the "last_reset_at" field.
func (m *UserMutation) SetLastResetAt(t time.Time) {
	m.last_reset_at = &t
}

// LastResetAt returns the value of the "last_reset_at" field in the mutation.
func (m *UserMutation) LastResetAt() (r time.Time, exists bool) {
	v := m.last_reset_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastResetAt returns the old "last_reset_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastResetAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastResetAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastResetAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastResetAt: %w", err)
	}
	return oldValue.LastResetAt, nil
}

// ResetLastResetAt resets all changes to the "last_reset_at" field.
func (m *UserMutation) ResetLastResetAt() {
	m.last_reset_at = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetEmailVerificationToken sets the "email_verification_token" field.
func (m *UserMutation) SetEmailVerificationToken(s string) {
	m.email_verification_token = &s
}

// EmailVerificationToken returns the value of the "email_verification_token" field in the mutation.
func (m *UserMutation) EmailVerificationToken() (r string, exists bool) {
	v := m.email_verification_token
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerificationToken returns the old "email_verification_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerificationToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerificationToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerificationToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerificationToken: %w", err)
	}
	return oldValue.EmailVerificationToken, nil
}

// ClearEmailVerificationToken clears the value of the "email_verification_token" field.
func (m *UserMutation) ClearEmailVerificationToken() {
	m.email_verification_token = nil
	m.clearedFields[user.FieldEmailVerificationToken] = struct{}{}
}

// EmailVerificationTokenCleared returns if the "email_verification_token" field was cleared in this mutation.
func (m *UserMutation) EmailVerificationTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailVerificationToken]
	return ok
}

// ResetEmailVerificationToken resets all changes to the "email_verification_token" field.
func (m *UserMutation) ResetEmailVerificationToken() {
	m.email_verification_token = nil
	delete(m.clearedFields, user.FieldEmailVerificationToken)
}

// SetEmailVerificationTokenExpiresAt sets the "email_verification_token_expires_at" field.
func (m *UserMutation) SetEmailVerificationTokenExpiresAt(t time.Time) {
	m.email_verification_token_expires_at = &t
}

// EmailVerificationTokenExpiresAt returns the value of the "email_verification_token_expires_at" field in the mutation.
func (m *UserMutation) EmailVerificationTokenExpiresAt() (r time.Time, exists bool) {
	v := m.email_verification_token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerificationTokenExpiresAt returns the old "email_verification_token_expires_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerificationTokenExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerificationTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerificationTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerificationTokenExpiresAt: %w", err)
	}
	return oldValue.EmailVerificationTokenExpiresAt, nil
}

// ClearEmailVerificationTokenExpiresAt clears the value of the "email_verification_token_expires_at" field.
func (m *UserMutation) ClearEmailVerificationTokenExpiresAt() {
	m.email_verification_token_expires_at = nil
	m.clearedFields[user.FieldEmailVerificationTokenExpiresAt] = struct{}{}
}

// EmailVerificationTokenExpiresAtCleared returns if the "email_verification_token_expires_at" field was cleared in this mutation.
func (m *UserMutation) EmailVerificationTokenExpiresAtCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailVerificationTokenExpiresAt]
	return ok
}

// ResetEmailVerificationTokenExpiresAt resets all changes to the "email_verification_token_expires_at" field.
func (m *UserMutation) ResetEmailVerificationTokenExpiresAt() {
	m.email_verification_token_expires_at = nil
	delete(m.clearedFields, user.FieldEmailVerificationTokenExpiresAt)
}

// SetEmailVerifiedAt sets the "email_verified_at" field.
func (m *UserMutation) SetEmailVerifiedAt(t time.Time) {
	m.email_verified_at = &t
}

// EmailVerifiedAt returns the value of the "email_verified_at" field in the mutation.
func (m *UserMutation) EmailVerifiedAt() (r time.Time, exists bool) {
	v := m.email_verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerifiedAt returns the old "email_verified_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerifiedAt: %w", err)
	}
	return oldValue.EmailVerifiedAt, nil
}

// ClearEmailVerifiedAt clears the value of the "email_verified_at" field.
func (m *UserMutation) ClearEmailVerifiedAt() {
	m.email_verified_at = nil
	m.clearedFields[user.FieldEmailVerifiedAt] = struct{}{}
}

// EmailVerifiedAtCleared returns if the "email_verified_at" field was cleared in this mutation.
func (m *UserMutation) EmailVerifiedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailVerifiedAt]
	return ok
}

// ResetEmailVerifiedAt resets all changes to the "email_verified_at" field.
func (m *UserMutation) ResetEmailVerifiedAt() {
	m.email_verified_at = nil
	delete(m.clearedFields, user.FieldEmailVerifiedAt)
}

// SetAcceptedTermsAt sets the "accepted_terms_at" field.
func (m *UserMutation) SetAcceptedTermsAt(t time.Time) {
	m.accepted_terms_at = &t
}

// AcceptedTermsAt returns the value of the "accepted_terms_at" field in the mutation.
func (m *UserMutation) AcceptedTermsAt() (r time.Time, exists bool) {
	v := m.accepted_terms_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedTermsAt returns the old "accepted_terms_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAcceptedTermsAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedTermsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedTermsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedTermsAt: %w", err)
	}
	return oldValue.AcceptedTermsAt, nil
}

// ClearAcceptedTermsAt clears the value of the "accepted_terms_at" field.
func (m *UserMutation) ClearAcceptedTermsAt() {
	m.accepted_terms_at = nil
	m.clearedFields[user.FieldAcceptedTermsAt] = struct{}{}
}

// AcceptedTermsAtCleared returns if the "accepted_terms_at" field was cleared in this mutation.
func (m *UserMutation) AcceptedTermsAtCleared() bool {
	_, ok := m.clearedFields[user.FieldAcceptedTermsAt]
	return ok
}

// ResetAcceptedTermsAt resets all changes to the "accepted_terms_at" field.
func (m *UserMutation) ResetAcceptedTermsAt() {
	m.accepted_terms_at = nil
	delete(m.clearedFields, user.FieldAcceptedTermsAt)
}

// SetOnboardingCompleted sets the "onboarding_completed" field.
func (m *UserMutation) SetOnboardingCompleted(b bool) {
	m.onboarding_completed = &b
}

// OnboardingCompleted returns the value of the "onboarding_completed" field in the mutation.
func (m *UserMutation) OnboardingCompleted() (r bool, exists bool) {
	v := m.onboarding_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardingCompleted returns the old "onboarding_completed" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOnboardingCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardingCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardingCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardingCompleted: %w", err)
	}
	return oldValue.OnboardingCompleted, nil
}

// ResetOnboardingCompleted resets all changes to the "onboarding_completed" field.
func (m *UserMutation) ResetOnboardingCompleted() {
	m.onboarding_completed = nil
}

// SetTotpEnabled sets the "totp_enabled" field.
func (m *UserMutation) SetTotpEnabled(b bool) {
	m.totp_enabled = &b
}

// TotpEnabled returns the value of the "totp_enabled" field in the mutation.
func (m *UserMutation) TotpEnabled() (r bool, exists bool) {
	v := m.totp_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpEnabled returns the old "totp_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpEnabled: %w", err)
	}
	return oldValue.TotpEnabled, nil
}

// ResetTotpEnabled resets all changes to the "totp_enabled" field.
func (m *UserMutation) ResetTotpEnabled() {
	m.totp_enabled = nil
}

// SetTotpSecret sets the "totp_secret" field.
func (m *UserMutation) SetTotpSecret(s string) {
	m.totp_secret = &s
}

// TotpSecret returns the value of the "totp_secret" field in the mutation.
func (m *UserMutation) TotpSecret() (r string, exists bool) {
	v := m.totp_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpSecret returns the old "totp_secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpSecret(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpSecret: %w", err)
	}
	return oldValue.TotpSecret, nil
}

// ClearTotpSecret clears the value of the "totp_secret" field.
func (m *UserMutation) ClearTotpSecret() {
	m.totp_secret = nil
	m.clearedFields[user.FieldTotpSecret] = struct{}{}
}

// TotpSecretCleared returns if the "totp_secret" field was cleared in this mutation.
func (m *UserMutation) TotpSecretCleared() bool {
	_, ok := m.clearedFields[user.FieldTotpSecret]
	return ok
}

// ResetTotpSecret resets all changes to the "totp_secret" field.
func (m *UserMutation) ResetTotpSecret() {
	m.totp_secret = nil
	delete(m.clearedFields, user.FieldTotpSecret)
}

// SetOauthProvider sets the "oauth_provider" field.
func (m *UserMutation) SetOauthProvider(s string) {
	m.oauth_provider = &s
}

// OauthProvider returns the value of the "oauth_provider" field in the mutation.
func (m *UserMutation) OauthProvider() (r string, exists bool) {
	v := m.oauth_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldOauthProvider returns the old "oauth_provider" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOauthProvider(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOauthProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOauthProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauthProvider: %w", err)
	}
	return oldValue.OauthProvider, nil
}

// ClearOauthProvider clears the value of the "oauth_provider" field.
func (m *UserMutation) ClearOauthProvider() {
	m.oauth_provider = nil
	m.clearedFields[user.FieldOauthProvider] = struct{}{}
}

// OauthProviderCleared returns if the "oauth_provider" field was cleared in this mutation.
func (m *UserMutation) OauthProviderCleared() bool {
	_, ok := m.clearedFields[user.FieldOauthProvider]
	return ok
}

// ResetOauthProvider resets all changes to the "oauth_provider" field.
func (m *UserMutation) ResetOauthProvider() {
	m.oauth_provider = nil
	delete(m.clearedFields, user.FieldOauthProvider)
}

// SetOauthID sets the "oauth_id" field.
func (m *UserMutation) SetOauthID(s string) {
	m.oauth_id = &s
}

// OauthID returns the value of the "oauth_id" field in the mutation.
func (m *UserMutation) OauthID() (r string, exists bool) {
	v := m.oauth_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOauthID returns the old "oauth_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOauthID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOauthID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOauthID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauthID: %w", err)
	}
	return oldValue.OauthID, nil
}

// ClearOauthID clears the value of the "oauth_id" field.
func (m *UserMutation) ClearOauthID() {
	m.oauth_id = nil
	m.clearedFields[user.FieldOauthID] = struct{}{}
}

// OauthIDCleared returns if the "oauth_id" field was cleared in this mutation.
func (m *UserMutation) OauthIDCleared() bool {
	_, ok := m.clearedFields[user.FieldOauthID]
	return ok
}

// ResetOauthID resets all changes to the "oauth_id" field.
func (m *UserMutation) ResetOauthID() {
	m.oauth_id = nil
	delete(m.clearedFields, user.FieldOauthID)
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *UserMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *UserMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStripeCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (m *UserMutation) ClearStripeCustomerID() {
	m.stripe_customer_id = nil
	m.clearedFields[user.FieldStripeCustomerID] = struct{}{}
}

// StripeCustomerIDCleared returns if the "stripe_customer_id" field was cleared in this mutation.
func (m *UserMutation) StripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[user.FieldStripeCustomerID]
	return ok
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *UserMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
	delete(m.clearedFields, user.FieldStripeCustomerID)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetOnboardingStep sets the "onboarding_step" field.
func (m *UserMutation) SetOnboardingStep(i int) {
	m.onboarding_step = &i
	m.addonboarding_step = nil
}

// OnboardingStep returns the value of the "onboarding_step" field in the mutation.
func (m *UserMutation) OnboardingStep() (r int, exists bool) {
	v := m.onboarding_step
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardingStep returns the old "onboarding_step" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOnboardingStep(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardingStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardingStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardingStep: %w", err)
	}
	return oldValue.OnboardingStep, nil
}

// AddOnboardingStep adds i to the "onboarding_step" field.
func (m *UserMutation) AddOnboardingStep(i int) {
	if m.addonboarding_step != nil {
		*m.addonboarding_step += i
	} else {
		m.addonboarding_step = &i
	}
}

// AddedOnboardingStep returns the value that was added to the "onboarding_step" field in this mutation.
func (m *UserMutation) AddedOnboardingStep() (r int, exists bool) {
	v := m.addonboarding_step
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnboardingStep resets all changes to the "onboarding_step" field.
func (m *UserMutation) ResetOnboardingStep() {
	m.onboarding_step = nil
	m.addonboarding_step = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *UserMutation) AddSubscriptionIDs(ids ...int) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *UserMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *UserMutation) RemoveSubscriptionIDs(ids ...int) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) RemovedSubscriptionsIDs() (ids []int) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *UserMutation) SubscriptionsIDs() (ids []int) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *UserMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddExportIDs adds the "exports" edge to the Export entity by ids.
func (m *UserMutation) AddExportIDs(ids ...int) {
	if m.exports == nil {
		m.exports = make(map[int]struct{})
	}
	for i := range ids {
		m.exports[ids[i]] = struct{}{}
	}
}

// ClearExports clears the "exports" edge to the Export entity.
func (m *UserMutation) ClearExports() {
	m.clearedexports = true
}

// ExportsCleared reports if the "exports" edge to the Export entity was cleared.
func (m *UserMutation) ExportsCleared() bool {
	return m.clearedexports
}

// RemoveExportIDs removes the "exports" edge to the Export entity by IDs.
func (m *UserMutation) RemoveExportIDs(ids ...int) {
	if m.removedexports == nil {
		m.removedexports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.exports, ids[i])
		m.removedexports[ids[i]] = struct{}{}
	}
}

// RemovedExports returns the removed IDs of the "exports" edge to the Export entity.
func (m *UserMutation) RemovedExportsIDs() (ids []int) {
	for id := range m.removedexports {
		ids = append(ids, id)
	}
	return
}

// ExportsIDs returns the "exports" edge IDs in the mutation.
func (m *UserMutation) ExportsIDs() (ids []int) {
	for id := range m.exports {
		ids = append(ids, id)
	}
	return
}

// ResetExports resets all changes to the "exports" edge.
func (m *UserMutation) ResetExports() {
	m.exports = nil
	m.clearedexports = false
	m.removedexports = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...int) {
	if m.api_keys == nil {
		m.api_keys = make(map[int]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...int) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []int) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []int) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddAuditLogIDs adds the "audit_logs" edge to the AuditLog entity by ids.
func (m *UserMutation) AddAuditLogIDs(ids ...int) {
	if m.audit_logs == nil {
		m.audit_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.audit_logs[ids[i]] = struct{}{}
	}
}

// ClearAuditLogs clears the "audit_logs" edge to the AuditLog entity.
func (m *UserMutation) ClearAuditLogs() {
	m.clearedaudit_logs = true
}

// AuditLogsCleared reports if the "audit_logs" edge to the AuditLog entity was cleared.
func (m *UserMutation) AuditLogsCleared() bool {
	return m.clearedaudit_logs
}

// RemoveAuditLogIDs removes the "audit_logs" edge to the AuditLog entity by IDs.
func (m *UserMutation) RemoveAuditLogIDs(ids ...int) {
	if m.removedaudit_logs == nil {
		m.removedaudit_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.audit_logs, ids[i])
		m.removedaudit_logs[ids[i]] = struct{}{}
	}
}

// RemovedAuditLogs returns the removed IDs of the "audit_logs" edge to the AuditLog entity.
func (m *UserMutation) RemovedAuditLogsIDs() (ids []int) {
	for id := range m.removedaudit_logs {
		ids = append(ids, id)
	}
	return
}

// AuditLogsIDs returns the "audit_logs" edge IDs in the mutation.
func (m *UserMutation) AuditLogsIDs() (ids []int) {
	for id := range m.audit_logs {
		ids = append(ids, id)
	}
	return
}

// ResetAuditLogs resets all changes to the "audit_logs" edge.
func (m *UserMutation) ResetAuditLogs() {
	m.audit_logs = nil
	m.clearedaudit_logs = false
	m.removedaudit_logs = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *UserMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *UserMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *UserMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *UserMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *UserMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *UserMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *UserMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// AddOwnedOrganizationIDs adds the "owned_organizations" edge to the Organization entity by ids.
func (m *UserMutation) AddOwnedOrganizationIDs(ids ...int) {
	if m.owned_organizations == nil {
		m.owned_organizations = make(map[int]struct{})
	}
	for i := range ids {
		m.owned_organizations[ids[i]] = struct{}{}
	}
}

// ClearOwnedOrganizations clears the "owned_organizations" edge to the Organization entity.
func (m *UserMutation) ClearOwnedOrganizations() {
	m.clearedowned_organizations = true
}

// OwnedOrganizationsCleared reports if the "owned_organizations" edge to the Organization entity was cleared.
func (m *UserMutation) OwnedOrganizationsCleared() bool {
	return m.clearedowned_organizations
}

// RemoveOwnedOrganizationIDs removes the "owned_organizations" edge to the Organization entity by IDs.
func (m *UserMutation) RemoveOwnedOrganizationIDs(ids ...int) {
	if m.removedowned_organizations == nil {
		m.removedowned_organizations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owned_organizations, ids[i])
		m.removedowned_organizations[ids[i]] = struct{}{}
	}
}

// RemovedOwnedOrganizations returns the removed IDs of the "owned_organizations" edge to the Organization entity.
func (m *UserMutation) RemovedOwnedOrganizationsIDs() (ids []int) {
	for id := range m.removedowned_organizations {
		ids = append(ids, id)
	}
	return
}

// OwnedOrganizationsIDs returns the "owned_organizations" edge IDs in the mutation.
func (m *UserMutation) OwnedOrganizationsIDs() (ids []int) {
	for id := range m.owned_organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedOrganizations resets all changes to the "owned_organizations" edge.
func (m *UserMutation) ResetOwnedOrganizations() {
	m.owned_organizations = nil
	m.clearedowned_organizations = false
	m.removedowned_organizations = nil
}

// AddOrganizationMembershipIDs adds the "organization_memberships" edge to the OrganizationMember entity by ids.
func (m *UserMutation) AddOrganizationMembershipIDs(ids ...int) {
	if m.organization_memberships == nil {
		m.organization_memberships = make(map[int]struct{})
	}
	for i := range ids {
		m.organization_memberships[ids[i]] = struct{}{}
	}
}

// ClearOrganizationMemberships clears the "organization_memberships" edge to the OrganizationMember entity.
func (m *UserMutation) ClearOrganizationMemberships() {
	m.clearedorganization_memberships = true
}

// OrganizationMembershipsCleared reports if the "organization_memberships" edge to the OrganizationMember entity was cleared.
func (m *UserMutation) OrganizationMembershipsCleared() bool {
	return m.clearedorganization_memberships
}

// RemoveOrganizationMembershipIDs removes the "organization_memberships" edge to the OrganizationMember entity by IDs.
func (m *UserMutation) RemoveOrganizationMembershipIDs(ids ...int) {
	if m.removedorganization_memberships == nil {
		m.removedorganization_memberships = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organization_memberships, ids[i])
		m.removedorganization_memberships[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationMemberships returns the removed IDs of the "organization_memberships" edge to the OrganizationMember entity.
func (m *UserMutation) RemovedOrganizationMembershipsIDs() (ids []int) {
	for id := range m.removedorganization_memberships {
		ids = append(ids, id)
	}
	return
}

// OrganizationMembershipsIDs returns the "organization_memberships" edge IDs in the mutation.
func (m *UserMutation) OrganizationMembershipsIDs() (ids []int) {
	for id := range m.organization_memberships {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationMemberships resets all changes to the "organization_memberships" edge.
func (m *UserMutation) ResetOrganizationMemberships() {
	m.organization_memberships = nil
	m.clearedorganization_memberships = false
	m.removedorganization_memberships = nil
}

// AddSavedSearchIDs adds the "saved_searches" edge to the SavedSearch entity by ids.
func (m *UserMutation) AddSavedSearchIDs(ids ...int) {
	if m.saved_searches == nil {
		m.saved_searches = make(map[int]struct{})
	}
	for i := range ids {
		m.saved_searches[ids[i]] = struct{}{}
	}
}

// ClearSavedSearches clears the "saved_searches" edge to the SavedSearch entity.
func (m *UserMutation) ClearSavedSearches() {
	m.clearedsaved_searches = true
}

// SavedSearchesCleared reports if the "saved_searches" edge to the SavedSearch entity was cleared.
func (m *UserMutation) SavedSearchesCleared() bool {
	return m.clearedsaved_searches
}

// RemoveSavedSearchIDs removes the "saved_searches" edge to the SavedSearch entity by IDs.
func (m *UserMutation) RemoveSavedSearchIDs(ids ...int) {
	if m.removedsaved_searches == nil {
		m.removedsaved_searches = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.saved_searches, ids[i])
		m.removedsaved_searches[ids[i]] = struct{}{}
	}
}

// RemovedSavedSearches returns the removed IDs of the "saved_searches" edge to the SavedSearch entity.
func (m *UserMutation) RemovedSavedSearchesIDs() (ids []int) {
	for id := range m.removedsaved_searches {
		ids = append(ids, id)
	}
	return
}

// SavedSearchesIDs returns the "saved_searches" edge IDs in the mutation.
func (m *UserMutation) SavedSearchesIDs() (ids []int) {
	for id := range m.saved_searches {
		ids = append(ids, id)
	}
	return
}

// ResetSavedSearches resets all changes to the "saved_searches" edge.
func (m *UserMutation) ResetSavedSearches() {
	m.saved_searches = nil
	m.clearedsaved_searches = false
	m.removedsaved_searches = nil
}

// AddWebhookIDs adds the "webhooks" edge to the Webhook entity by ids.
func (m *UserMutation) AddWebhookIDs(ids ...int) {
	if m.webhooks == nil {
		m.webhooks = make(map[int]struct{})
	}
	for i := range ids {
		m.webhooks[ids[i]] = struct{}{}
	}
}

// ClearWebhooks clears the "webhooks" edge to the Webhook entity.
func (m *UserMutation) ClearWebhooks() {
	m.clearedwebhooks = true
}

// WebhooksCleared reports if the "webhooks" edge to the Webhook entity was cleared.
func (m *UserMutation) WebhooksCleared() bool {
	return m.clearedwebhooks
}

// RemoveWebhookIDs removes the "webhooks" edge to the Webhook entity by IDs.
func (m *UserMutation) RemoveWebhookIDs(ids ...int) {
	if m.removedwebhooks == nil {
		m.removedwebhooks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.webhooks, ids[i])
		m.removedwebhooks[ids[i]] = struct{}{}
	}
}

// RemovedWebhooks returns the removed IDs of the "webhooks" edge to the Webhook entity.
func (m *UserMutation) RemovedWebhooksIDs() (ids []int) {
	for id := range m.removedwebhooks {
		ids = append(ids, id)
	}
	return
}

// WebhooksIDs returns the "webhooks" edge IDs in the mutation.
func (m *UserMutation) WebhooksIDs() (ids []int) {
	for id := range m.webhooks {
		ids = append(ids, id)
	}
	return
}

// ResetWebhooks resets all changes to the "webhooks" edge.
func (m *UserMutation) ResetWebhooks() {
	m.webhooks = nil
	m.clearedwebhooks = false
	m.removedwebhooks = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.subscription_tier != nil {
		fields = append(fields, user.FieldSubscriptionTier)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.usage_count != nil {
		fields = append(fields, user.FieldUsageCount)
	}
	if m.usage_limit != nil {
		fields = append(fields, user.FieldUsageLimit)
	}
	if m.last_reset_at != nil {
		fields = append(fields, user.FieldLastResetAt)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.email_verification_token != nil {
		fields = append(fields, user.FieldEmailVerificationToken)
	}
	if m.email_verification_token_expires_at != nil {
		fields = append(fields, user.FieldEmailVerificationTokenExpiresAt)
	}
	if m.email_verified_at != nil {
		fields = append(fields, user.FieldEmailVerifiedAt)
	}
	if m.accepted_terms_at != nil {
		fields = append(fields, user.FieldAcceptedTermsAt)
	}
	if m.onboarding_completed != nil {
		fields = append(fields, user.FieldOnboardingCompleted)
	}
	if m.totp_enabled != nil {
		fields = append(fields, user.FieldTotpEnabled)
	}
	if m.totp_secret != nil {
		fields = append(fields, user.FieldTotpSecret)
	}
	if m.oauth_provider != nil {
		fields = append(fields, user.FieldOauthProvider)
	}
	if m.oauth_id != nil {
		fields = append(fields, user.FieldOauthID)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, user.FieldStripeCustomerID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.onboarding_step != nil {
		fields = append(fields, user.FieldOnboardingStep)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldName:
		return m.Name()
	case user.FieldSubscriptionTier:
		return m.SubscriptionTier()
	case user.FieldRole:
		return m.Role()
	case user.FieldUsageCount:
		return m.UsageCount()
	case user.FieldUsageLimit:
		return m.UsageLimit()
	case user.FieldLastResetAt:
		return m.LastResetAt()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldEmailVerificationToken:
		return m.EmailVerificationToken()
	case user.FieldEmailVerificationTokenExpiresAt:
		return m.EmailVerificationTokenExpiresAt()
	case user.FieldEmailVerifiedAt:
		return m.EmailVerifiedAt()
	case user.FieldAcceptedTermsAt:
		return m.AcceptedTermsAt()
	case user.FieldOnboardingCompleted:
		return m.OnboardingCompleted()
	case user.FieldTotpEnabled:
		return m.TotpEnabled()
	case user.FieldTotpSecret:
		return m.TotpSecret()
	case user.FieldOauthProvider:
		return m.OauthProvider()
	case user.FieldOauthID:
		return m.OauthID()
	case user.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldOnboardingStep:
		return m.OnboardingStep()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldSubscriptionTier:
		return m.OldSubscriptionTier(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case user.FieldUsageLimit:
		return m.OldUsageLimit(ctx)
	case user.FieldLastResetAt:
		return m.OldLastResetAt(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldEmailVerificationToken:
		return m.OldEmailVerificationToken(ctx)
	case user.FieldEmailVerificationTokenExpiresAt:
		return m.OldEmailVerificationTokenExpiresAt(ctx)
	case user.FieldEmailVerifiedAt:
		return m.OldEmailVerifiedAt(ctx)
	case user.FieldAcceptedTermsAt:
		return m.OldAcceptedTermsAt(ctx)
	case user.FieldOnboardingCompleted:
		return m.OldOnboardingCompleted(ctx)
	case user.FieldTotpEnabled:
		return m.OldTotpEnabled(ctx)
	case user.FieldTotpSecret:
		return m.OldTotpSecret(ctx)
	case user.FieldOauthProvider:
		return m.OldOauthProvider(ctx)
	case user.FieldOauthID:
		return m.OldOauthID(ctx)
	case user.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldOnboardingStep:
		return m.OldOnboardingStep(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldSubscriptionTier:
		v, ok := value.(user.SubscriptionTier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionTier(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case user.FieldUsageLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageLimit(v)
		return nil
	case user.FieldLastResetAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastResetAt(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldEmailVerificationToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerificationToken(v)
		return nil
	case user.FieldEmailVerificationTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerificationTokenExpiresAt(v)
		return nil
	case user.FieldEmailVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerifiedAt(v)
		return nil
	case user.FieldAcceptedTermsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedTermsAt(v)
		return nil
	case user.FieldOnboardingCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardingCompleted(v)
		return nil
	case user.FieldTotpEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpEnabled(v)
		return nil
	case user.FieldTotpSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpSecret(v)
		return nil
	case user.FieldOauthProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauthProvider(v)
		return nil
	case user.FieldOauthID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauthID(v)
		return nil
	case user.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldOnboardingStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardingStep(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, user.FieldUsageCount)
	}
	if m.addusage_limit != nil {
		fields = append(fields, user.FieldUsageLimit)
	}
	if m.addonboarding_step != nil {
		fields = append(fields, user.FieldOnboardingStep)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsageCount:
		return m.AddedUsageCount()
	case user.FieldUsageLimit:
		return m.AddedUsageLimit()
	case user.FieldOnboardingStep:
		return m.AddedOnboardingStep()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	case user.FieldUsageLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageLimit(v)
		return nil
	case user.FieldOnboardingStep:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnboardingStep(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.FieldCleared(user.FieldEmailVerificationToken) {
		fields = append(fields, user.FieldEmailVerificationToken)
	}
	if m.FieldCleared(user.FieldEmailVerificationTokenExpiresAt) {
		fields = append(fields, user.FieldEmailVerificationTokenExpiresAt)
	}
	if m.FieldCleared(user.FieldEmailVerifiedAt) {
		fields = append(fields, user.FieldEmailVerifiedAt)
	}
	if m.FieldCleared(user.FieldAcceptedTermsAt) {
		fields = append(fields, user.FieldAcceptedTermsAt)
	}
	if m.FieldCleared(user.FieldTotpSecret) {
		fields = append(fields, user.FieldTotpSecret)
	}
	if m.FieldCleared(user.FieldOauthProvider) {
		fields = append(fields, user.FieldOauthProvider)
	}
	if m.FieldCleared(user.FieldOauthID) {
		fields = append(fields, user.FieldOauthID)
	}
	if m.FieldCleared(user.FieldStripeCustomerID) {
		fields = append(fields, user.FieldStripeCustomerID)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case user.FieldEmailVerificationToken:
		m.ClearEmailVerificationToken()
		return nil
	case user.FieldEmailVerificationTokenExpiresAt:
		m.ClearEmailVerificationTokenExpiresAt()
		return nil
	case user.FieldEmailVerifiedAt:
		m.ClearEmailVerifiedAt()
		return nil
	case user.FieldAcceptedTermsAt:
		m.ClearAcceptedTermsAt()
		return nil
	case user.FieldTotpSecret:
		m.ClearTotpSecret()
		return nil
	case user.FieldOauthProvider:
		m.ClearOauthProvider()
		return nil
	case user.FieldOauthID:
		m.ClearOauthID()
		return nil
	case user.FieldStripeCustomerID:
		m.ClearStripeCustomerID()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldSubscriptionTier:
		m.ResetSubscriptionTier()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case user.FieldUsageLimit:
		m.ResetUsageLimit()
		return nil
	case user.FieldLastResetAt:
		m.ResetLastResetAt()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldEmailVerificationToken:
		m.ResetEmailVerificationToken()
		return nil
	case user.FieldEmailVerificationTokenExpiresAt:
		m.ResetEmailVerificationTokenExpiresAt()
		return nil
	case user.FieldEmailVerifiedAt:
		m.ResetEmailVerifiedAt()
		return nil
	case user.FieldAcceptedTermsAt:
		m.ResetAcceptedTermsAt()
		return nil
	case user.FieldOnboardingCompleted:
		m.ResetOnboardingCompleted()
		return nil
	case user.FieldTotpEnabled:
		m.ResetTotpEnabled()
		return nil
	case user.FieldTotpSecret:
		m.ResetTotpSecret()
		return nil
	case user.FieldOauthProvider:
		m.ResetOauthProvider()
		return nil
	case user.FieldOauthID:
		m.ResetOauthID()
		return nil
	case user.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldOnboardingStep:
		m.ResetOnboardingStep()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.subscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.exports != nil {
		edges = append(edges, user.EdgeExports)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.audit_logs != nil {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.usage_logs != nil {
		edges = append(edges, user.EdgeUsageLogs)
	}
	if m.owned_organizations != nil {
		edges = append(edges, user.EdgeOwnedOrganizations)
	}
	if m.organization_memberships != nil {
		edges = append(edges, user.EdgeOrganizationMemberships)
	}
	if m.saved_searches != nil {
		edges = append(edges, user.EdgeSavedSearches)
	}
	if m.webhooks != nil {
		edges = append(edges, user.EdgeWebhooks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeExports:
		ids := make([]ent.Value, 0, len(m.exports))
		for id := range m.exports {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.audit_logs))
		for id := range m.audit_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedOrganizations:
		ids := make([]ent.Value, 0, len(m.owned_organizations))
		for id := range m.owned_organizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizationMemberships:
		ids := make([]ent.Value, 0, len(m.organization_memberships))
		for id := range m.organization_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSavedSearches:
		ids := make([]ent.Value, 0, len(m.saved_searches))
		for id := range m.saved_searches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWebhooks:
		ids := make([]ent.Value, 0, len(m.webhooks))
		for id := range m.webhooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedsubscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.removedexports != nil {
		edges = append(edges, user.EdgeExports)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removedaudit_logs != nil {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, user.EdgeUsageLogs)
	}
	if m.removedowned_organizations != nil {
		edges = append(edges, user.EdgeOwnedOrganizations)
	}
	if m.removedorganization_memberships != nil {
		edges = append(edges, user.EdgeOrganizationMemberships)
	}
	if m.removedsaved_searches != nil {
		edges = append(edges, user.EdgeSavedSearches)
	}
	if m.removedwebhooks != nil {
		edges = append(edges, user.EdgeWebhooks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeExports:
		ids := make([]ent.Value, 0, len(m.removedexports))
		for id := range m.removedexports {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.removedaudit_logs))
		for id := range m.removedaudit_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedOrganizations:
		ids := make([]ent.Value, 0, len(m.removedowned_organizations))
		for id := range m.removedowned_organizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizationMemberships:
		ids := make([]ent.Value, 0, len(m.removedorganization_memberships))
		for id := range m.removedorganization_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSavedSearches:
		ids := make([]ent.Value, 0, len(m.removedsaved_searches))
		for id := range m.removedsaved_searches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWebhooks:
		ids := make([]ent.Value, 0, len(m.removedwebhooks))
		for id := range m.removedwebhooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedsubscriptions {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.clearedexports {
		edges = append(edges, user.EdgeExports)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.clearedaudit_logs {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.clearedusage_logs {
		edges = append(edges, user.EdgeUsageLogs)
	}
	if m.clearedowned_organizations {
		edges = append(edges, user.EdgeOwnedOrganizations)
	}
	if m.clearedorganization_memberships {
		edges = append(edges, user.EdgeOrganizationMemberships)
	}
	if m.clearedsaved_searches {
		edges = append(edges, user.EdgeSavedSearches)
	}
	if m.clearedwebhooks {
		edges = append(edges, user.EdgeWebhooks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSubscriptions:
		return m.clearedsubscriptions
	case user.EdgeExports:
		return m.clearedexports
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeAuditLogs:
		return m.clearedaudit_logs
	case user.EdgeUsageLogs:
		return m.clearedusage_logs
	case user.EdgeOwnedOrganizations:
		return m.clearedowned_organizations
	case user.EdgeOrganizationMemberships:
		return m.clearedorganization_memberships
	case user.EdgeSavedSearches:
		return m.clearedsaved_searches
	case user.EdgeWebhooks:
		return m.clearedwebhooks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case user.EdgeExports:
		m.ResetExports()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeAuditLogs:
		m.ResetAuditLogs()
		return nil
	case user.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	case user.EdgeOwnedOrganizations:
		m.ResetOwnedOrganizations()
		return nil
	case user.EdgeOrganizationMemberships:
		m.ResetOrganizationMemberships()
		return nil
	case user.EdgeSavedSearches:
		m.ResetSavedSearches()
		return nil
	case user.EdgeWebhooks:
		m.ResetWebhooks()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WebhookMutation represents an operation that mutates the Webhook nodes in the graph.
type WebhookMutation struct {
	config
	op                Op
	typ               string
	id                *int
	url               *string
	events            *[]string
	appendevents      []string
	secret            *string
	active            *bool
	description       *string
	retry_count       *int
	addretry_count    *int
	last_triggered_at *time.Time
	success_count     *int
	addsuccess_count  *int
	failure_count     *int
	addfailure_count  *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	user              *int
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*Webhook, error)
	predicates        []predicate.Webhook
}

var _ ent.Mutation = (*WebhookMutation)(nil)

// webhookOption allows management of the mutation configuration using functional options.
type webhookOption func(*WebhookMutation)

// newWebhookMutation creates new mutation for the Webhook entity.
func newWebhookMutation(c config, op Op, opts ...webhookOption) *WebhookMutation {
	m := &WebhookMutation{
		config:        c,
		op:            op,
		typ:           TypeWebhook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebhookID sets the ID field of the mutation.
func withWebhookID(id int) webhookOption {
	return func(m *WebhookMutation) {
		var (
			err   error
			once  sync.Once
			value *Webhook
		)
		m.oldValue = func(ctx context.Context) (*Webhook, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Webhook.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebhook sets the old Webhook of the mutation.
func withWebhook(node *Webhook) webhookOption {
	return func(m *WebhookMutation) {
		m.oldValue = func(context.Context) (*Webhook, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebhookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebhookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebhookMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebhookMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Webhook.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *WebhookMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *WebhookMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *WebhookMutation) ResetURL() {
	m.url = nil
}

// SetEvents sets the "events" field.
func (m *WebhookMutation) SetEvents(s []string) {
	m.events = &s
	m.appendevents = nil
}

// Events returns the value of the "events" field in the mutation.
func (m *WebhookMutation) Events() (r []string, exists bool) {
	v := m.events
	if v == nil {
		return
	}
	return *v, true
}

// OldEvents returns the old "events" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldEvents(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvents: %w", err)
	}
	return oldValue.Events, nil
}

// AppendEvents adds s to the "events" field.
func (m *WebhookMutation) AppendEvents(s []string) {
	m.appendevents = append(m.appendevents, s...)
}

// AppendedEvents returns the list of values that were appended to the "events" field in this mutation.
func (m *WebhookMutation) AppendedEvents() ([]string, bool) {
	if len(m.appendevents) == 0 {
		return nil, false
	}
	return m.appendevents, true
}

// ResetEvents resets all changes to the "events" field.
func (m *WebhookMutation) ResetEvents() {
	m.events = nil
	m.appendevents = nil
}

// SetSecret sets the "secret" field.
func (m *WebhookMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *WebhookMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *WebhookMutation) ResetSecret() {
	m.secret = nil
}

// SetActive sets the "active" field.
func (m *WebhookMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *WebhookMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *WebhookMutation) ResetActive() {
	m.active = nil
}

// SetDescription sets the "description" field.
func (m *WebhookMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WebhookMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WebhookMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[webhook.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WebhookMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[webhook.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WebhookMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, webhook.FieldDescription)
}

// SetRetryCount sets the "retry_count" field.
func (m *WebhookMutation) SetRetryCount(i int) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *WebhookMutation) RetryCount() (r int, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *WebhookMutation) AddRetryCount(i int) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *WebhookMutation) AddedRetryCount() (r int, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *WebhookMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetLastTriggeredAt sets the "last_triggered_at" field.
func (m *WebhookMutation) SetLastTriggeredAt(t time.Time) {
	m.last_triggered_at = &t
}

// LastTriggeredAt returns the value of the "last_triggered_at" field in the mutation.
func (m *WebhookMutation) LastTriggeredAt() (r time.Time, exists bool) {
	v := m.last_triggered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastTriggeredAt returns the old "last_triggered_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldLastTriggeredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastTriggeredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastTriggeredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastTriggeredAt: %w", err)
	}
	return oldValue.LastTriggeredAt, nil
}

// ClearLastTriggeredAt clears the value of the "last_triggered_at" field.
func (m *WebhookMutation) ClearLastTriggeredAt() {
	m.last_triggered_at = nil
	m.clearedFields[webhook.FieldLastTriggeredAt] = struct{}{}
}

// LastTriggeredAtCleared returns if the "last_triggered_at" field was cleared in this mutation.
func (m *WebhookMutation) LastTriggeredAtCleared() bool {
	_, ok := m.clearedFields[webhook.FieldLastTriggeredAt]
	return ok
}

// ResetLastTriggeredAt resets all changes to the "last_triggered_at" field.
func (m *WebhookMutation) ResetLastTriggeredAt() {
	m.last_triggered_at = nil
	delete(m.clearedFields, webhook.FieldLastTriggeredAt)
}

// SetSuccessCount sets the "success_count" field.
func (m *WebhookMutation) SetSuccessCount(i int) {
	m.success_count = &i
	m.addsuccess_count = nil
}

// SuccessCount returns the value of the "success_count" field in the mutation.
func (m *WebhookMutation) SuccessCount() (r int, exists bool) {
	v := m.success_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessCount returns the old "success_count" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldSuccessCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessCount: %w", err)
	}
	return oldValue.SuccessCount, nil
}

// AddSuccessCount adds i to the "success_count" field.
func (m *WebhookMutation) AddSuccessCount(i int) {
	if m.addsuccess_count != nil {
		*m.addsuccess_count += i
	} else {
		m.addsuccess_count = &i
	}
}

// AddedSuccessCount returns the value that was added to the "success_count" field in this mutation.
func (m *WebhookMutation) AddedSuccessCount() (r int, exists bool) {
	v := m.addsuccess_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessCount resets all changes to the "success_count" field.
func (m *WebhookMutation) ResetSuccessCount() {
	m.success_count = nil
	m.addsuccess_count = nil
}

// SetFailureCount sets the "failure_count" field.
func (m *WebhookMutation) SetFailureCount(i int) {
	m.failure_count = &i
	m.addfailure_count = nil
}

// FailureCount returns the value of the "failure_count" field in the mutation.
func (m *WebhookMutation) FailureCount() (r int, exists bool) {
	v := m.failure_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureCount returns the old "failure_count" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldFailureCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureCount: %w", err)
	}
	return oldValue.FailureCount, nil
}

// AddFailureCount adds i to the "failure_count" field.
func (m *WebhookMutation) AddFailureCount(i int) {
	if m.addfailure_count != nil {
		*m.addfailure_count += i
	} else {
		m.addfailure_count = &i
	}
}

// AddedFailureCount returns the value that was added to the "failure_count" field in this mutation.
func (m *WebhookMutation) AddedFailureCount() (r int, exists bool) {
	v := m.addfailure_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailureCount resets all changes to the "failure_count" field.
func (m *WebhookMutation) ResetFailureCount() {
	m.failure_count = nil
	m.addfailure_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WebhookMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebhookMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebhookMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebhookMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebhookMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Webhook entity.
// If the Webhook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebhookMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebhookMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *WebhookMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *WebhookMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WebhookMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *WebhookMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WebhookMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WebhookMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WebhookMutation builder.
func (m *WebhookMutation) Where(ps ...predicate.Webhook) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebhookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebhookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Webhook, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebhookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebhookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Webhook).
func (m *WebhookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebhookMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.url != nil {
		fields = append(fields, webhook.FieldURL)
	}
	if m.events != nil {
		fields = append(fields, webhook.FieldEvents)
	}
	if m.secret != nil {
		fields = append(fields, webhook.FieldSecret)
	}
	if m.active != nil {
		fields = append(fields, webhook.FieldActive)
	}
	if m.description != nil {
		fields = append(fields, webhook.FieldDescription)
	}
	if m.retry_count != nil {
		fields = append(fields, webhook.FieldRetryCount)
	}
	if m.last_triggered_at != nil {
		fields = append(fields, webhook.FieldLastTriggeredAt)
	}
	if m.success_count != nil {
		fields = append(fields, webhook.FieldSuccessCount)
	}
	if m.failure_count != nil {
		fields = append(fields, webhook.FieldFailureCount)
	}
	if m.created_at != nil {
		fields = append(fields, webhook.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, webhook.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebhookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldURL:
		return m.URL()
	case webhook.FieldEvents:
		return m.Events()
	case webhook.FieldSecret:
		return m.Secret()
	case webhook.FieldActive:
		return m.Active()
	case webhook.FieldDescription:
		return m.Description()
	case webhook.FieldRetryCount:
		return m.RetryCount()
	case webhook.FieldLastTriggeredAt:
		return m.LastTriggeredAt()
	case webhook.FieldSuccessCount:
		return m.SuccessCount()
	case webhook.FieldFailureCount:
		return m.FailureCount()
	case webhook.FieldCreatedAt:
		return m.CreatedAt()
	case webhook.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebhookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webhook.FieldURL:
		return m.OldURL(ctx)
	case webhook.FieldEvents:
		return m.OldEvents(ctx)
	case webhook.FieldSecret:
		return m.OldSecret(ctx)
	case webhook.FieldActive:
		return m.OldActive(ctx)
	case webhook.FieldDescription:
		return m.OldDescription(ctx)
	case webhook.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case webhook.FieldLastTriggeredAt:
		return m.OldLastTriggeredAt(ctx)
	case webhook.FieldSuccessCount:
		return m.OldSuccessCount(ctx)
	case webhook.FieldFailureCount:
		return m.OldFailureCount(ctx)
	case webhook.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webhook.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Webhook field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case webhook.FieldEvents:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvents(v)
		return nil
	case webhook.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case webhook.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case webhook.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case webhook.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case webhook.FieldLastTriggeredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastTriggeredAt(v)
		return nil
	case webhook.FieldSuccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessCount(v)
		return nil
	case webhook.FieldFailureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureCount(v)
		return nil
	case webhook.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webhook.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebhookMutation) AddedFields() []string {
	var fields []string
	if m.addretry_count != nil {
		fields = append(fields, webhook.FieldRetryCount)
	}
	if m.addsuccess_count != nil {
		fields = append(fields, webhook.FieldSuccessCount)
	}
	if m.addfailure_count != nil {
		fields = append(fields, webhook.FieldFailureCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebhookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldRetryCount:
		return m.AddedRetryCount()
	case webhook.FieldSuccessCount:
		return m.AddedSuccessCount()
	case webhook.FieldFailureCount:
		return m.AddedFailureCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebhookMutation) AddField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	case webhook.FieldSuccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessCount(v)
		return nil
	case webhook.FieldFailureCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailureCount(v)
		return nil
	}
	return fmt.Errorf("unknown Webhook numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebhookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(webhook.FieldDescription) {
		fields = append(fields, webhook.FieldDescription)
	}
	if m.FieldCleared(webhook.FieldLastTriggeredAt) {
		fields = append(fields, webhook.FieldLastTriggeredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebhookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebhookMutation) ClearField(name string) error {
	switch name {
	case webhook.FieldDescription:
		m.ClearDescription()
		return nil
	case webhook.FieldLastTriggeredAt:
		m.ClearLastTriggeredAt()
		return nil
	}
	return fmt.Errorf("unknown Webhook nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebhookMutation) ResetField(name string) error {
	switch name {
	case webhook.FieldURL:
		m.ResetURL()
		return nil
	case webhook.FieldEvents:
		m.ResetEvents()
		return nil
	case webhook.FieldSecret:
		m.ResetSecret()
		return nil
	case webhook.FieldActive:
		m.ResetActive()
		return nil
	case webhook.FieldDescription:
		m.ResetDescription()
		return nil
	case webhook.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case webhook.FieldLastTriggeredAt:
		m.ResetLastTriggeredAt()
		return nil
	case webhook.FieldSuccessCount:
		m.ResetSuccessCount()
		return nil
	case webhook.FieldFailureCount:
		m.ResetFailureCount()
		return nil
	case webhook.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webhook.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Webhook field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebhookMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, webhook.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebhookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case webhook.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebhookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebhookMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebhookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, webhook.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebhookMutation) EdgeCleared(name string) bool {
	switch name {
	case webhook.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebhookMutation) ClearEdge(name string) error {
	switch name {
	case webhook.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Webhook unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebhookMutation) ResetEdge(name string) error {
	switch name {
	case webhook.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Webhook edge %s", name)
}
