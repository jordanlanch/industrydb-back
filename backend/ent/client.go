// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/jordanlanch/industrydb/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/jordanlanch/industrydb/ent/affiliate"
	"github.com/jordanlanch/industrydb/ent/affiliateclick"
	"github.com/jordanlanch/industrydb/ent/affiliateconversion"
	"github.com/jordanlanch/industrydb/ent/apikey"
	"github.com/jordanlanch/industrydb/ent/auditlog"
	"github.com/jordanlanch/industrydb/ent/calllog"
	"github.com/jordanlanch/industrydb/ent/competitormetric"
	"github.com/jordanlanch/industrydb/ent/competitorprofile"
	"github.com/jordanlanch/industrydb/ent/crmintegration"
	"github.com/jordanlanch/industrydb/ent/crmleadsync"
	"github.com/jordanlanch/industrydb/ent/emailcampaign"
	"github.com/jordanlanch/industrydb/ent/emailcampaignrecipient"
	"github.com/jordanlanch/industrydb/ent/emailsequence"
	"github.com/jordanlanch/industrydb/ent/emailsequenceenrollment"
	"github.com/jordanlanch/industrydb/ent/emailsequencesend"
	"github.com/jordanlanch/industrydb/ent/emailsequencestep"
	"github.com/jordanlanch/industrydb/ent/experiment"
	"github.com/jordanlanch/industrydb/ent/experimentassignment"
	"github.com/jordanlanch/industrydb/ent/export"
	"github.com/jordanlanch/industrydb/ent/industry"
	"github.com/jordanlanch/industrydb/ent/lead"
	"github.com/jordanlanch/industrydb/ent/leadassignment"
	"github.com/jordanlanch/industrydb/ent/leadnote"
	"github.com/jordanlanch/industrydb/ent/leadrecommendation"
	"github.com/jordanlanch/industrydb/ent/leadstatushistory"
	"github.com/jordanlanch/industrydb/ent/marketreport"
	"github.com/jordanlanch/industrydb/ent/organization"
	"github.com/jordanlanch/industrydb/ent/organizationmember"
	"github.com/jordanlanch/industrydb/ent/referral"
	"github.com/jordanlanch/industrydb/ent/savedsearch"
	"github.com/jordanlanch/industrydb/ent/smscampaign"
	"github.com/jordanlanch/industrydb/ent/smsmessage"
	"github.com/jordanlanch/industrydb/ent/subscription"
	"github.com/jordanlanch/industrydb/ent/territory"
	"github.com/jordanlanch/industrydb/ent/territorymember"
	"github.com/jordanlanch/industrydb/ent/usagelog"
	"github.com/jordanlanch/industrydb/ent/user"
	"github.com/jordanlanch/industrydb/ent/userbehavior"
	"github.com/jordanlanch/industrydb/ent/webhook"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// APIKey is the client for interacting with the APIKey builders.
	APIKey *APIKeyClient
	// Affiliate is the client for interacting with the Affiliate builders.
	Affiliate *AffiliateClient
	// AffiliateClick is the client for interacting with the AffiliateClick builders.
	AffiliateClick *AffiliateClickClient
	// AffiliateConversion is the client for interacting with the AffiliateConversion builders.
	AffiliateConversion *AffiliateConversionClient
	// AuditLog is the client for interacting with the AuditLog builders.
	AuditLog *AuditLogClient
	// CRMIntegration is the client for interacting with the CRMIntegration builders.
	CRMIntegration *CRMIntegrationClient
	// CRMLeadSync is the client for interacting with the CRMLeadSync builders.
	CRMLeadSync *CRMLeadSyncClient
	// CallLog is the client for interacting with the CallLog builders.
	CallLog *CallLogClient
	// CompetitorMetric is the client for interacting with the CompetitorMetric builders.
	CompetitorMetric *CompetitorMetricClient
	// CompetitorProfile is the client for interacting with the CompetitorProfile builders.
	CompetitorProfile *CompetitorProfileClient
	// EmailCampaign is the client for interacting with the EmailCampaign builders.
	EmailCampaign *EmailCampaignClient
	// EmailCampaignRecipient is the client for interacting with the EmailCampaignRecipient builders.
	EmailCampaignRecipient *EmailCampaignRecipientClient
	// EmailSequence is the client for interacting with the EmailSequence builders.
	EmailSequence *EmailSequenceClient
	// EmailSequenceEnrollment is the client for interacting with the EmailSequenceEnrollment builders.
	EmailSequenceEnrollment *EmailSequenceEnrollmentClient
	// EmailSequenceSend is the client for interacting with the EmailSequenceSend builders.
	EmailSequenceSend *EmailSequenceSendClient
	// EmailSequenceStep is the client for interacting with the EmailSequenceStep builders.
	EmailSequenceStep *EmailSequenceStepClient
	// Experiment is the client for interacting with the Experiment builders.
	Experiment *ExperimentClient
	// ExperimentAssignment is the client for interacting with the ExperimentAssignment builders.
	ExperimentAssignment *ExperimentAssignmentClient
	// Export is the client for interacting with the Export builders.
	Export *ExportClient
	// Industry is the client for interacting with the Industry builders.
	Industry *IndustryClient
	// Lead is the client for interacting with the Lead builders.
	Lead *LeadClient
	// LeadAssignment is the client for interacting with the LeadAssignment builders.
	LeadAssignment *LeadAssignmentClient
	// LeadNote is the client for interacting with the LeadNote builders.
	LeadNote *LeadNoteClient
	// LeadRecommendation is the client for interacting with the LeadRecommendation builders.
	LeadRecommendation *LeadRecommendationClient
	// LeadStatusHistory is the client for interacting with the LeadStatusHistory builders.
	LeadStatusHistory *LeadStatusHistoryClient
	// MarketReport is the client for interacting with the MarketReport builders.
	MarketReport *MarketReportClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// OrganizationMember is the client for interacting with the OrganizationMember builders.
	OrganizationMember *OrganizationMemberClient
	// Referral is the client for interacting with the Referral builders.
	Referral *ReferralClient
	// SMSCampaign is the client for interacting with the SMSCampaign builders.
	SMSCampaign *SMSCampaignClient
	// SMSMessage is the client for interacting with the SMSMessage builders.
	SMSMessage *SMSMessageClient
	// SavedSearch is the client for interacting with the SavedSearch builders.
	SavedSearch *SavedSearchClient
	// Subscription is the client for interacting with the Subscription builders.
	Subscription *SubscriptionClient
	// Territory is the client for interacting with the Territory builders.
	Territory *TerritoryClient
	// TerritoryMember is the client for interacting with the TerritoryMember builders.
	TerritoryMember *TerritoryMemberClient
	// UsageLog is the client for interacting with the UsageLog builders.
	UsageLog *UsageLogClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserBehavior is the client for interacting with the UserBehavior builders.
	UserBehavior *UserBehaviorClient
	// Webhook is the client for interacting with the Webhook builders.
	Webhook *WebhookClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.APIKey = NewAPIKeyClient(c.config)
	c.Affiliate = NewAffiliateClient(c.config)
	c.AffiliateClick = NewAffiliateClickClient(c.config)
	c.AffiliateConversion = NewAffiliateConversionClient(c.config)
	c.AuditLog = NewAuditLogClient(c.config)
	c.CRMIntegration = NewCRMIntegrationClient(c.config)
	c.CRMLeadSync = NewCRMLeadSyncClient(c.config)
	c.CallLog = NewCallLogClient(c.config)
	c.CompetitorMetric = NewCompetitorMetricClient(c.config)
	c.CompetitorProfile = NewCompetitorProfileClient(c.config)
	c.EmailCampaign = NewEmailCampaignClient(c.config)
	c.EmailCampaignRecipient = NewEmailCampaignRecipientClient(c.config)
	c.EmailSequence = NewEmailSequenceClient(c.config)
	c.EmailSequenceEnrollment = NewEmailSequenceEnrollmentClient(c.config)
	c.EmailSequenceSend = NewEmailSequenceSendClient(c.config)
	c.EmailSequenceStep = NewEmailSequenceStepClient(c.config)
	c.Experiment = NewExperimentClient(c.config)
	c.ExperimentAssignment = NewExperimentAssignmentClient(c.config)
	c.Export = NewExportClient(c.config)
	c.Industry = NewIndustryClient(c.config)
	c.Lead = NewLeadClient(c.config)
	c.LeadAssignment = NewLeadAssignmentClient(c.config)
	c.LeadNote = NewLeadNoteClient(c.config)
	c.LeadRecommendation = NewLeadRecommendationClient(c.config)
	c.LeadStatusHistory = NewLeadStatusHistoryClient(c.config)
	c.MarketReport = NewMarketReportClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.OrganizationMember = NewOrganizationMemberClient(c.config)
	c.Referral = NewReferralClient(c.config)
	c.SMSCampaign = NewSMSCampaignClient(c.config)
	c.SMSMessage = NewSMSMessageClient(c.config)
	c.SavedSearch = NewSavedSearchClient(c.config)
	c.Subscription = NewSubscriptionClient(c.config)
	c.Territory = NewTerritoryClient(c.config)
	c.TerritoryMember = NewTerritoryMemberClient(c.config)
	c.UsageLog = NewUsageLogClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserBehavior = NewUserBehaviorClient(c.config)
	c.Webhook = NewWebhookClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		APIKey:                  NewAPIKeyClient(cfg),
		Affiliate:               NewAffiliateClient(cfg),
		AffiliateClick:          NewAffiliateClickClient(cfg),
		AffiliateConversion:     NewAffiliateConversionClient(cfg),
		AuditLog:                NewAuditLogClient(cfg),
		CRMIntegration:          NewCRMIntegrationClient(cfg),
		CRMLeadSync:             NewCRMLeadSyncClient(cfg),
		CallLog:                 NewCallLogClient(cfg),
		CompetitorMetric:        NewCompetitorMetricClient(cfg),
		CompetitorProfile:       NewCompetitorProfileClient(cfg),
		EmailCampaign:           NewEmailCampaignClient(cfg),
		EmailCampaignRecipient:  NewEmailCampaignRecipientClient(cfg),
		EmailSequence:           NewEmailSequenceClient(cfg),
		EmailSequenceEnrollment: NewEmailSequenceEnrollmentClient(cfg),
		EmailSequenceSend:       NewEmailSequenceSendClient(cfg),
		EmailSequenceStep:       NewEmailSequenceStepClient(cfg),
		Experiment:              NewExperimentClient(cfg),
		ExperimentAssignment:    NewExperimentAssignmentClient(cfg),
		Export:                  NewExportClient(cfg),
		Industry:                NewIndustryClient(cfg),
		Lead:                    NewLeadClient(cfg),
		LeadAssignment:          NewLeadAssignmentClient(cfg),
		LeadNote:                NewLeadNoteClient(cfg),
		LeadRecommendation:      NewLeadRecommendationClient(cfg),
		LeadStatusHistory:       NewLeadStatusHistoryClient(cfg),
		MarketReport:            NewMarketReportClient(cfg),
		Organization:            NewOrganizationClient(cfg),
		OrganizationMember:      NewOrganizationMemberClient(cfg),
		Referral:                NewReferralClient(cfg),
		SMSCampaign:             NewSMSCampaignClient(cfg),
		SMSMessage:              NewSMSMessageClient(cfg),
		SavedSearch:             NewSavedSearchClient(cfg),
		Subscription:            NewSubscriptionClient(cfg),
		Territory:               NewTerritoryClient(cfg),
		TerritoryMember:         NewTerritoryMemberClient(cfg),
		UsageLog:                NewUsageLogClient(cfg),
		User:                    NewUserClient(cfg),
		UserBehavior:            NewUserBehaviorClient(cfg),
		Webhook:                 NewWebhookClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		APIKey:                  NewAPIKeyClient(cfg),
		Affiliate:               NewAffiliateClient(cfg),
		AffiliateClick:          NewAffiliateClickClient(cfg),
		AffiliateConversion:     NewAffiliateConversionClient(cfg),
		AuditLog:                NewAuditLogClient(cfg),
		CRMIntegration:          NewCRMIntegrationClient(cfg),
		CRMLeadSync:             NewCRMLeadSyncClient(cfg),
		CallLog:                 NewCallLogClient(cfg),
		CompetitorMetric:        NewCompetitorMetricClient(cfg),
		CompetitorProfile:       NewCompetitorProfileClient(cfg),
		EmailCampaign:           NewEmailCampaignClient(cfg),
		EmailCampaignRecipient:  NewEmailCampaignRecipientClient(cfg),
		EmailSequence:           NewEmailSequenceClient(cfg),
		EmailSequenceEnrollment: NewEmailSequenceEnrollmentClient(cfg),
		EmailSequenceSend:       NewEmailSequenceSendClient(cfg),
		EmailSequenceStep:       NewEmailSequenceStepClient(cfg),
		Experiment:              NewExperimentClient(cfg),
		ExperimentAssignment:    NewExperimentAssignmentClient(cfg),
		Export:                  NewExportClient(cfg),
		Industry:                NewIndustryClient(cfg),
		Lead:                    NewLeadClient(cfg),
		LeadAssignment:          NewLeadAssignmentClient(cfg),
		LeadNote:                NewLeadNoteClient(cfg),
		LeadRecommendation:      NewLeadRecommendationClient(cfg),
		LeadStatusHistory:       NewLeadStatusHistoryClient(cfg),
		MarketReport:            NewMarketReportClient(cfg),
		Organization:            NewOrganizationClient(cfg),
		OrganizationMember:      NewOrganizationMemberClient(cfg),
		Referral:                NewReferralClient(cfg),
		SMSCampaign:             NewSMSCampaignClient(cfg),
		SMSMessage:              NewSMSMessageClient(cfg),
		SavedSearch:             NewSavedSearchClient(cfg),
		Subscription:            NewSubscriptionClient(cfg),
		Territory:               NewTerritoryClient(cfg),
		TerritoryMember:         NewTerritoryMemberClient(cfg),
		UsageLog:                NewUsageLogClient(cfg),
		User:                    NewUserClient(cfg),
		UserBehavior:            NewUserBehaviorClient(cfg),
		Webhook:                 NewWebhookClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		APIKey.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.APIKey, c.Affiliate, c.AffiliateClick, c.AffiliateConversion, c.AuditLog,
		c.CRMIntegration, c.CRMLeadSync, c.CallLog, c.CompetitorMetric,
		c.CompetitorProfile, c.EmailCampaign, c.EmailCampaignRecipient,
		c.EmailSequence, c.EmailSequenceEnrollment, c.EmailSequenceSend,
		c.EmailSequenceStep, c.Experiment, c.ExperimentAssignment, c.Export,
		c.Industry, c.Lead, c.LeadAssignment, c.LeadNote, c.LeadRecommendation,
		c.LeadStatusHistory, c.MarketReport, c.Organization, c.OrganizationMember,
		c.Referral, c.SMSCampaign, c.SMSMessage, c.SavedSearch, c.Subscription,
		c.Territory, c.TerritoryMember, c.UsageLog, c.User, c.UserBehavior, c.Webhook,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.APIKey, c.Affiliate, c.AffiliateClick, c.AffiliateConversion, c.AuditLog,
		c.CRMIntegration, c.CRMLeadSync, c.CallLog, c.CompetitorMetric,
		c.CompetitorProfile, c.EmailCampaign, c.EmailCampaignRecipient,
		c.EmailSequence, c.EmailSequenceEnrollment, c.EmailSequenceSend,
		c.EmailSequenceStep, c.Experiment, c.ExperimentAssignment, c.Export,
		c.Industry, c.Lead, c.LeadAssignment, c.LeadNote, c.LeadRecommendation,
		c.LeadStatusHistory, c.MarketReport, c.Organization, c.OrganizationMember,
		c.Referral, c.SMSCampaign, c.SMSMessage, c.SavedSearch, c.Subscription,
		c.Territory, c.TerritoryMember, c.UsageLog, c.User, c.UserBehavior, c.Webhook,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APIKeyMutation:
		return c.APIKey.mutate(ctx, m)
	case *AffiliateMutation:
		return c.Affiliate.mutate(ctx, m)
	case *AffiliateClickMutation:
		return c.AffiliateClick.mutate(ctx, m)
	case *AffiliateConversionMutation:
		return c.AffiliateConversion.mutate(ctx, m)
	case *AuditLogMutation:
		return c.AuditLog.mutate(ctx, m)
	case *CRMIntegrationMutation:
		return c.CRMIntegration.mutate(ctx, m)
	case *CRMLeadSyncMutation:
		return c.CRMLeadSync.mutate(ctx, m)
	case *CallLogMutation:
		return c.CallLog.mutate(ctx, m)
	case *CompetitorMetricMutation:
		return c.CompetitorMetric.mutate(ctx, m)
	case *CompetitorProfileMutation:
		return c.CompetitorProfile.mutate(ctx, m)
	case *EmailCampaignMutation:
		return c.EmailCampaign.mutate(ctx, m)
	case *EmailCampaignRecipientMutation:
		return c.EmailCampaignRecipient.mutate(ctx, m)
	case *EmailSequenceMutation:
		return c.EmailSequence.mutate(ctx, m)
	case *EmailSequenceEnrollmentMutation:
		return c.EmailSequenceEnrollment.mutate(ctx, m)
	case *EmailSequenceSendMutation:
		return c.EmailSequenceSend.mutate(ctx, m)
	case *EmailSequenceStepMutation:
		return c.EmailSequenceStep.mutate(ctx, m)
	case *ExperimentMutation:
		return c.Experiment.mutate(ctx, m)
	case *ExperimentAssignmentMutation:
		return c.ExperimentAssignment.mutate(ctx, m)
	case *ExportMutation:
		return c.Export.mutate(ctx, m)
	case *IndustryMutation:
		return c.Industry.mutate(ctx, m)
	case *LeadMutation:
		return c.Lead.mutate(ctx, m)
	case *LeadAssignmentMutation:
		return c.LeadAssignment.mutate(ctx, m)
	case *LeadNoteMutation:
		return c.LeadNote.mutate(ctx, m)
	case *LeadRecommendationMutation:
		return c.LeadRecommendation.mutate(ctx, m)
	case *LeadStatusHistoryMutation:
		return c.LeadStatusHistory.mutate(ctx, m)
	case *MarketReportMutation:
		return c.MarketReport.mutate(ctx, m)
	case *OrganizationMutation:
		return c.Organization.mutate(ctx, m)
	case *OrganizationMemberMutation:
		return c.OrganizationMember.mutate(ctx, m)
	case *ReferralMutation:
		return c.Referral.mutate(ctx, m)
	case *SMSCampaignMutation:
		return c.SMSCampaign.mutate(ctx, m)
	case *SMSMessageMutation:
		return c.SMSMessage.mutate(ctx, m)
	case *SavedSearchMutation:
		return c.SavedSearch.mutate(ctx, m)
	case *SubscriptionMutation:
		return c.Subscription.mutate(ctx, m)
	case *TerritoryMutation:
		return c.Territory.mutate(ctx, m)
	case *TerritoryMemberMutation:
		return c.TerritoryMember.mutate(ctx, m)
	case *UsageLogMutation:
		return c.UsageLog.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserBehaviorMutation:
		return c.UserBehavior.mutate(ctx, m)
	case *WebhookMutation:
		return c.Webhook.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// APIKeyClient is a client for the APIKey schema.
type APIKeyClient struct {
	config
}

// NewAPIKeyClient returns a client for the APIKey from the given config.
func NewAPIKeyClient(c config) *APIKeyClient {
	return &APIKeyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apikey.Hooks(f(g(h())))`.
func (c *APIKeyClient) Use(hooks ...Hook) {
	c.hooks.APIKey = append(c.hooks.APIKey, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apikey.Intercept(f(g(h())))`.
func (c *APIKeyClient) Intercept(interceptors ...Interceptor) {
	c.inters.APIKey = append(c.inters.APIKey, interceptors...)
}

// Create returns a builder for creating a APIKey entity.
func (c *APIKeyClient) Create() *APIKeyCreate {
	mutation := newAPIKeyMutation(c.config, OpCreate)
	return &APIKeyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of APIKey entities.
func (c *APIKeyClient) CreateBulk(builders ...*APIKeyCreate) *APIKeyCreateBulk {
	return &APIKeyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *APIKeyClient) MapCreateBulk(slice any, setFunc func(*APIKeyCreate, int)) *APIKeyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &APIKeyCreateBulk{err: fmt.Errorf("calling to APIKeyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*APIKeyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &APIKeyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for APIKey.
func (c *APIKeyClient) Update() *APIKeyUpdate {
	mutation := newAPIKeyMutation(c.config, OpUpdate)
	return &APIKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APIKeyClient) UpdateOne(_m *APIKey) *APIKeyUpdateOne {
	mutation := newAPIKeyMutation(c.config, OpUpdateOne, withAPIKey(_m))
	return &APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APIKeyClient) UpdateOneID(id int) *APIKeyUpdateOne {
	mutation := newAPIKeyMutation(c.config, OpUpdateOne, withAPIKeyID(id))
	return &APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for APIKey.
func (c *APIKeyClient) Delete() *APIKeyDelete {
	mutation := newAPIKeyMutation(c.config, OpDelete)
	return &APIKeyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APIKeyClient) DeleteOne(_m *APIKey) *APIKeyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APIKeyClient) DeleteOneID(id int) *APIKeyDeleteOne {
	builder := c.Delete().Where(apikey.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APIKeyDeleteOne{builder}
}

// Query returns a query builder for APIKey.
func (c *APIKeyClient) Query() *APIKeyQuery {
	return &APIKeyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPIKey},
		inters: c.Interceptors(),
	}
}

// Get returns a APIKey entity by its id.
func (c *APIKeyClient) Get(ctx context.Context, id int) (*APIKey, error) {
	return c.Query().Where(apikey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APIKeyClient) GetX(ctx context.Context, id int) *APIKey {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a APIKey.
func (c *APIKeyClient) QueryUser(_m *APIKey) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(apikey.Table, apikey.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, apikey.UserTable, apikey.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *APIKeyClient) Hooks() []Hook {
	return c.hooks.APIKey
}

// Interceptors returns the client interceptors.
func (c *APIKeyClient) Interceptors() []Interceptor {
	return c.inters.APIKey
}

func (c *APIKeyClient) mutate(ctx context.Context, m *APIKeyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APIKeyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APIKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APIKeyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown APIKey mutation op: %q", m.Op())
	}
}

// AffiliateClient is a client for the Affiliate schema.
type AffiliateClient struct {
	config
}

// NewAffiliateClient returns a client for the Affiliate from the given config.
func NewAffiliateClient(c config) *AffiliateClient {
	return &AffiliateClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `affiliate.Hooks(f(g(h())))`.
func (c *AffiliateClient) Use(hooks ...Hook) {
	c.hooks.Affiliate = append(c.hooks.Affiliate, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `affiliate.Intercept(f(g(h())))`.
func (c *AffiliateClient) Intercept(interceptors ...Interceptor) {
	c.inters.Affiliate = append(c.inters.Affiliate, interceptors...)
}

// Create returns a builder for creating a Affiliate entity.
func (c *AffiliateClient) Create() *AffiliateCreate {
	mutation := newAffiliateMutation(c.config, OpCreate)
	return &AffiliateCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Affiliate entities.
func (c *AffiliateClient) CreateBulk(builders ...*AffiliateCreate) *AffiliateCreateBulk {
	return &AffiliateCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AffiliateClient) MapCreateBulk(slice any, setFunc func(*AffiliateCreate, int)) *AffiliateCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AffiliateCreateBulk{err: fmt.Errorf("calling to AffiliateClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AffiliateCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AffiliateCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Affiliate.
func (c *AffiliateClient) Update() *AffiliateUpdate {
	mutation := newAffiliateMutation(c.config, OpUpdate)
	return &AffiliateUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AffiliateClient) UpdateOne(_m *Affiliate) *AffiliateUpdateOne {
	mutation := newAffiliateMutation(c.config, OpUpdateOne, withAffiliate(_m))
	return &AffiliateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AffiliateClient) UpdateOneID(id int) *AffiliateUpdateOne {
	mutation := newAffiliateMutation(c.config, OpUpdateOne, withAffiliateID(id))
	return &AffiliateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Affiliate.
func (c *AffiliateClient) Delete() *AffiliateDelete {
	mutation := newAffiliateMutation(c.config, OpDelete)
	return &AffiliateDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AffiliateClient) DeleteOne(_m *Affiliate) *AffiliateDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AffiliateClient) DeleteOneID(id int) *AffiliateDeleteOne {
	builder := c.Delete().Where(affiliate.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AffiliateDeleteOne{builder}
}

// Query returns a query builder for Affiliate.
func (c *AffiliateClient) Query() *AffiliateQuery {
	return &AffiliateQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAffiliate},
		inters: c.Interceptors(),
	}
}

// Get returns a Affiliate entity by its id.
func (c *AffiliateClient) Get(ctx context.Context, id int) (*Affiliate, error) {
	return c.Query().Where(affiliate.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AffiliateClient) GetX(ctx context.Context, id int) *Affiliate {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Affiliate.
func (c *AffiliateClient) QueryUser(_m *Affiliate) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(affiliate.Table, affiliate.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, affiliate.UserTable, affiliate.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClicks queries the clicks edge of a Affiliate.
func (c *AffiliateClient) QueryClicks(_m *Affiliate) *AffiliateClickQuery {
	query := (&AffiliateClickClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(affiliate.Table, affiliate.FieldID, id),
			sqlgraph.To(affiliateclick.Table, affiliateclick.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, affiliate.ClicksTable, affiliate.ClicksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConversions queries the conversions edge of a Affiliate.
func (c *AffiliateClient) QueryConversions(_m *Affiliate) *AffiliateConversionQuery {
	query := (&AffiliateConversionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(affiliate.Table, affiliate.FieldID, id),
			sqlgraph.To(affiliateconversion.Table, affiliateconversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, affiliate.ConversionsTable, affiliate.ConversionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AffiliateClient) Hooks() []Hook {
	return c.hooks.Affiliate
}

// Interceptors returns the client interceptors.
func (c *AffiliateClient) Interceptors() []Interceptor {
	return c.inters.Affiliate
}

func (c *AffiliateClient) mutate(ctx context.Context, m *AffiliateMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AffiliateCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AffiliateUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AffiliateUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AffiliateDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Affiliate mutation op: %q", m.Op())
	}
}

// AffiliateClickClient is a client for the AffiliateClick schema.
type AffiliateClickClient struct {
	config
}

// NewAffiliateClickClient returns a client for the AffiliateClick from the given config.
func NewAffiliateClickClient(c config) *AffiliateClickClient {
	return &AffiliateClickClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `affiliateclick.Hooks(f(g(h())))`.
func (c *AffiliateClickClient) Use(hooks ...Hook) {
	c.hooks.AffiliateClick = append(c.hooks.AffiliateClick, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `affiliateclick.Intercept(f(g(h())))`.
func (c *AffiliateClickClient) Intercept(interceptors ...Interceptor) {
	c.inters.AffiliateClick = append(c.inters.AffiliateClick, interceptors...)
}

// Create returns a builder for creating a AffiliateClick entity.
func (c *AffiliateClickClient) Create() *AffiliateClickCreate {
	mutation := newAffiliateClickMutation(c.config, OpCreate)
	return &AffiliateClickCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AffiliateClick entities.
func (c *AffiliateClickClient) CreateBulk(builders ...*AffiliateClickCreate) *AffiliateClickCreateBulk {
	return &AffiliateClickCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AffiliateClickClient) MapCreateBulk(slice any, setFunc func(*AffiliateClickCreate, int)) *AffiliateClickCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AffiliateClickCreateBulk{err: fmt.Errorf("calling to AffiliateClickClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AffiliateClickCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AffiliateClickCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AffiliateClick.
func (c *AffiliateClickClient) Update() *AffiliateClickUpdate {
	mutation := newAffiliateClickMutation(c.config, OpUpdate)
	return &AffiliateClickUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AffiliateClickClient) UpdateOne(_m *AffiliateClick) *AffiliateClickUpdateOne {
	mutation := newAffiliateClickMutation(c.config, OpUpdateOne, withAffiliateClick(_m))
	return &AffiliateClickUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AffiliateClickClient) UpdateOneID(id int) *AffiliateClickUpdateOne {
	mutation := newAffiliateClickMutation(c.config, OpUpdateOne, withAffiliateClickID(id))
	return &AffiliateClickUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AffiliateClick.
func (c *AffiliateClickClient) Delete() *AffiliateClickDelete {
	mutation := newAffiliateClickMutation(c.config, OpDelete)
	return &AffiliateClickDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AffiliateClickClient) DeleteOne(_m *AffiliateClick) *AffiliateClickDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AffiliateClickClient) DeleteOneID(id int) *AffiliateClickDeleteOne {
	builder := c.Delete().Where(affiliateclick.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AffiliateClickDeleteOne{builder}
}

// Query returns a query builder for AffiliateClick.
func (c *AffiliateClickClient) Query() *AffiliateClickQuery {
	return &AffiliateClickQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAffiliateClick},
		inters: c.Interceptors(),
	}
}

// Get returns a AffiliateClick entity by its id.
func (c *AffiliateClickClient) Get(ctx context.Context, id int) (*AffiliateClick, error) {
	return c.Query().Where(affiliateclick.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AffiliateClickClient) GetX(ctx context.Context, id int) *AffiliateClick {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAffiliate queries the affiliate edge of a AffiliateClick.
func (c *AffiliateClickClient) QueryAffiliate(_m *AffiliateClick) *AffiliateQuery {
	query := (&AffiliateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(affiliateclick.Table, affiliateclick.FieldID, id),
			sqlgraph.To(affiliate.Table, affiliate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, affiliateclick.AffiliateTable, affiliateclick.AffiliateColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AffiliateClickClient) Hooks() []Hook {
	return c.hooks.AffiliateClick
}

// Interceptors returns the client interceptors.
func (c *AffiliateClickClient) Interceptors() []Interceptor {
	return c.inters.AffiliateClick
}

func (c *AffiliateClickClient) mutate(ctx context.Context, m *AffiliateClickMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AffiliateClickCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AffiliateClickUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AffiliateClickUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AffiliateClickDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AffiliateClick mutation op: %q", m.Op())
	}
}

// AffiliateConversionClient is a client for the AffiliateConversion schema.
type AffiliateConversionClient struct {
	config
}

// NewAffiliateConversionClient returns a client for the AffiliateConversion from the given config.
func NewAffiliateConversionClient(c config) *AffiliateConversionClient {
	return &AffiliateConversionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `affiliateconversion.Hooks(f(g(h())))`.
func (c *AffiliateConversionClient) Use(hooks ...Hook) {
	c.hooks.AffiliateConversion = append(c.hooks.AffiliateConversion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `affiliateconversion.Intercept(f(g(h())))`.
func (c *AffiliateConversionClient) Intercept(interceptors ...Interceptor) {
	c.inters.AffiliateConversion = append(c.inters.AffiliateConversion, interceptors...)
}

// Create returns a builder for creating a AffiliateConversion entity.
func (c *AffiliateConversionClient) Create() *AffiliateConversionCreate {
	mutation := newAffiliateConversionMutation(c.config, OpCreate)
	return &AffiliateConversionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AffiliateConversion entities.
func (c *AffiliateConversionClient) CreateBulk(builders ...*AffiliateConversionCreate) *AffiliateConversionCreateBulk {
	return &AffiliateConversionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AffiliateConversionClient) MapCreateBulk(slice any, setFunc func(*AffiliateConversionCreate, int)) *AffiliateConversionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AffiliateConversionCreateBulk{err: fmt.Errorf("calling to AffiliateConversionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AffiliateConversionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AffiliateConversionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AffiliateConversion.
func (c *AffiliateConversionClient) Update() *AffiliateConversionUpdate {
	mutation := newAffiliateConversionMutation(c.config, OpUpdate)
	return &AffiliateConversionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AffiliateConversionClient) UpdateOne(_m *AffiliateConversion) *AffiliateConversionUpdateOne {
	mutation := newAffiliateConversionMutation(c.config, OpUpdateOne, withAffiliateConversion(_m))
	return &AffiliateConversionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AffiliateConversionClient) UpdateOneID(id int) *AffiliateConversionUpdateOne {
	mutation := newAffiliateConversionMutation(c.config, OpUpdateOne, withAffiliateConversionID(id))
	return &AffiliateConversionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AffiliateConversion.
func (c *AffiliateConversionClient) Delete() *AffiliateConversionDelete {
	mutation := newAffiliateConversionMutation(c.config, OpDelete)
	return &AffiliateConversionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AffiliateConversionClient) DeleteOne(_m *AffiliateConversion) *AffiliateConversionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AffiliateConversionClient) DeleteOneID(id int) *AffiliateConversionDeleteOne {
	builder := c.Delete().Where(affiliateconversion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AffiliateConversionDeleteOne{builder}
}

// Query returns a query builder for AffiliateConversion.
func (c *AffiliateConversionClient) Query() *AffiliateConversionQuery {
	return &AffiliateConversionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAffiliateConversion},
		inters: c.Interceptors(),
	}
}

// Get returns a AffiliateConversion entity by its id.
func (c *AffiliateConversionClient) Get(ctx context.Context, id int) (*AffiliateConversion, error) {
	return c.Query().Where(affiliateconversion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AffiliateConversionClient) GetX(ctx context.Context, id int) *AffiliateConversion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAffiliate queries the affiliate edge of a AffiliateConversion.
func (c *AffiliateConversionClient) QueryAffiliate(_m *AffiliateConversion) *AffiliateQuery {
	query := (&AffiliateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(affiliateconversion.Table, affiliateconversion.FieldID, id),
			sqlgraph.To(affiliate.Table, affiliate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, affiliateconversion.AffiliateTable, affiliateconversion.AffiliateColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a AffiliateConversion.
func (c *AffiliateConversionClient) QueryUser(_m *AffiliateConversion) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(affiliateconversion.Table, affiliateconversion.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, affiliateconversion.UserTable, affiliateconversion.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AffiliateConversionClient) Hooks() []Hook {
	return c.hooks.AffiliateConversion
}

// Interceptors returns the client interceptors.
func (c *AffiliateConversionClient) Interceptors() []Interceptor {
	return c.inters.AffiliateConversion
}

func (c *AffiliateConversionClient) mutate(ctx context.Context, m *AffiliateConversionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AffiliateConversionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AffiliateConversionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AffiliateConversionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AffiliateConversionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AffiliateConversion mutation op: %q", m.Op())
	}
}

// AuditLogClient is a client for the AuditLog schema.
type AuditLogClient struct {
	config
}

// NewAuditLogClient returns a client for the AuditLog from the given config.
func NewAuditLogClient(c config) *AuditLogClient {
	return &AuditLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `auditlog.Hooks(f(g(h())))`.
func (c *AuditLogClient) Use(hooks ...Hook) {
	c.hooks.AuditLog = append(c.hooks.AuditLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `auditlog.Intercept(f(g(h())))`.
func (c *AuditLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuditLog = append(c.inters.AuditLog, interceptors...)
}

// Create returns a builder for creating a AuditLog entity.
func (c *AuditLogClient) Create() *AuditLogCreate {
	mutation := newAuditLogMutation(c.config, OpCreate)
	return &AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuditLog entities.
func (c *AuditLogClient) CreateBulk(builders ...*AuditLogCreate) *AuditLogCreateBulk {
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuditLogClient) MapCreateBulk(slice any, setFunc func(*AuditLogCreate, int)) *AuditLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuditLogCreateBulk{err: fmt.Errorf("calling to AuditLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuditLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuditLog.
func (c *AuditLogClient) Update() *AuditLogUpdate {
	mutation := newAuditLogMutation(c.config, OpUpdate)
	return &AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuditLogClient) UpdateOne(_m *AuditLog) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLog(_m))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuditLogClient) UpdateOneID(id int) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLogID(id))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuditLog.
func (c *AuditLogClient) Delete() *AuditLogDelete {
	mutation := newAuditLogMutation(c.config, OpDelete)
	return &AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuditLogClient) DeleteOne(_m *AuditLog) *AuditLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuditLogClient) DeleteOneID(id int) *AuditLogDeleteOne {
	builder := c.Delete().Where(auditlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuditLogDeleteOne{builder}
}

// Query returns a query builder for AuditLog.
func (c *AuditLogClient) Query() *AuditLogQuery {
	return &AuditLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuditLog},
		inters: c.Interceptors(),
	}
}

// Get returns a AuditLog entity by its id.
func (c *AuditLogClient) Get(ctx context.Context, id int) (*AuditLog, error) {
	return c.Query().Where(auditlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuditLogClient) GetX(ctx context.Context, id int) *AuditLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a AuditLog.
func (c *AuditLogClient) QueryUser(_m *AuditLog) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(auditlog.Table, auditlog.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, auditlog.UserTable, auditlog.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuditLogClient) Hooks() []Hook {
	return c.hooks.AuditLog
}

// Interceptors returns the client interceptors.
func (c *AuditLogClient) Interceptors() []Interceptor {
	return c.inters.AuditLog
}

func (c *AuditLogClient) mutate(ctx context.Context, m *AuditLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuditLog mutation op: %q", m.Op())
	}
}

// CRMIntegrationClient is a client for the CRMIntegration schema.
type CRMIntegrationClient struct {
	config
}

// NewCRMIntegrationClient returns a client for the CRMIntegration from the given config.
func NewCRMIntegrationClient(c config) *CRMIntegrationClient {
	return &CRMIntegrationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `crmintegration.Hooks(f(g(h())))`.
func (c *CRMIntegrationClient) Use(hooks ...Hook) {
	c.hooks.CRMIntegration = append(c.hooks.CRMIntegration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `crmintegration.Intercept(f(g(h())))`.
func (c *CRMIntegrationClient) Intercept(interceptors ...Interceptor) {
	c.inters.CRMIntegration = append(c.inters.CRMIntegration, interceptors...)
}

// Create returns a builder for creating a CRMIntegration entity.
func (c *CRMIntegrationClient) Create() *CRMIntegrationCreate {
	mutation := newCRMIntegrationMutation(c.config, OpCreate)
	return &CRMIntegrationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CRMIntegration entities.
func (c *CRMIntegrationClient) CreateBulk(builders ...*CRMIntegrationCreate) *CRMIntegrationCreateBulk {
	return &CRMIntegrationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CRMIntegrationClient) MapCreateBulk(slice any, setFunc func(*CRMIntegrationCreate, int)) *CRMIntegrationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CRMIntegrationCreateBulk{err: fmt.Errorf("calling to CRMIntegrationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CRMIntegrationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CRMIntegrationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CRMIntegration.
func (c *CRMIntegrationClient) Update() *CRMIntegrationUpdate {
	mutation := newCRMIntegrationMutation(c.config, OpUpdate)
	return &CRMIntegrationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CRMIntegrationClient) UpdateOne(_m *CRMIntegration) *CRMIntegrationUpdateOne {
	mutation := newCRMIntegrationMutation(c.config, OpUpdateOne, withCRMIntegration(_m))
	return &CRMIntegrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CRMIntegrationClient) UpdateOneID(id int) *CRMIntegrationUpdateOne {
	mutation := newCRMIntegrationMutation(c.config, OpUpdateOne, withCRMIntegrationID(id))
	return &CRMIntegrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CRMIntegration.
func (c *CRMIntegrationClient) Delete() *CRMIntegrationDelete {
	mutation := newCRMIntegrationMutation(c.config, OpDelete)
	return &CRMIntegrationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CRMIntegrationClient) DeleteOne(_m *CRMIntegration) *CRMIntegrationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CRMIntegrationClient) DeleteOneID(id int) *CRMIntegrationDeleteOne {
	builder := c.Delete().Where(crmintegration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CRMIntegrationDeleteOne{builder}
}

// Query returns a query builder for CRMIntegration.
func (c *CRMIntegrationClient) Query() *CRMIntegrationQuery {
	return &CRMIntegrationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCRMIntegration},
		inters: c.Interceptors(),
	}
}

// Get returns a CRMIntegration entity by its id.
func (c *CRMIntegrationClient) Get(ctx context.Context, id int) (*CRMIntegration, error) {
	return c.Query().Where(crmintegration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CRMIntegrationClient) GetX(ctx context.Context, id int) *CRMIntegration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CRMIntegration.
func (c *CRMIntegrationClient) QueryUser(_m *CRMIntegration) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(crmintegration.Table, crmintegration.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, crmintegration.UserTable, crmintegration.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySyncedLeads queries the synced_leads edge of a CRMIntegration.
func (c *CRMIntegrationClient) QuerySyncedLeads(_m *CRMIntegration) *CRMLeadSyncQuery {
	query := (&CRMLeadSyncClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(crmintegration.Table, crmintegration.FieldID, id),
			sqlgraph.To(crmleadsync.Table, crmleadsync.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, crmintegration.SyncedLeadsTable, crmintegration.SyncedLeadsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CRMIntegrationClient) Hooks() []Hook {
	return c.hooks.CRMIntegration
}

// Interceptors returns the client interceptors.
func (c *CRMIntegrationClient) Interceptors() []Interceptor {
	return c.inters.CRMIntegration
}

func (c *CRMIntegrationClient) mutate(ctx context.Context, m *CRMIntegrationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CRMIntegrationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CRMIntegrationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CRMIntegrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CRMIntegrationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CRMIntegration mutation op: %q", m.Op())
	}
}

// CRMLeadSyncClient is a client for the CRMLeadSync schema.
type CRMLeadSyncClient struct {
	config
}

// NewCRMLeadSyncClient returns a client for the CRMLeadSync from the given config.
func NewCRMLeadSyncClient(c config) *CRMLeadSyncClient {
	return &CRMLeadSyncClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `crmleadsync.Hooks(f(g(h())))`.
func (c *CRMLeadSyncClient) Use(hooks ...Hook) {
	c.hooks.CRMLeadSync = append(c.hooks.CRMLeadSync, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `crmleadsync.Intercept(f(g(h())))`.
func (c *CRMLeadSyncClient) Intercept(interceptors ...Interceptor) {
	c.inters.CRMLeadSync = append(c.inters.CRMLeadSync, interceptors...)
}

// Create returns a builder for creating a CRMLeadSync entity.
func (c *CRMLeadSyncClient) Create() *CRMLeadSyncCreate {
	mutation := newCRMLeadSyncMutation(c.config, OpCreate)
	return &CRMLeadSyncCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CRMLeadSync entities.
func (c *CRMLeadSyncClient) CreateBulk(builders ...*CRMLeadSyncCreate) *CRMLeadSyncCreateBulk {
	return &CRMLeadSyncCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CRMLeadSyncClient) MapCreateBulk(slice any, setFunc func(*CRMLeadSyncCreate, int)) *CRMLeadSyncCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CRMLeadSyncCreateBulk{err: fmt.Errorf("calling to CRMLeadSyncClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CRMLeadSyncCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CRMLeadSyncCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CRMLeadSync.
func (c *CRMLeadSyncClient) Update() *CRMLeadSyncUpdate {
	mutation := newCRMLeadSyncMutation(c.config, OpUpdate)
	return &CRMLeadSyncUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CRMLeadSyncClient) UpdateOne(_m *CRMLeadSync) *CRMLeadSyncUpdateOne {
	mutation := newCRMLeadSyncMutation(c.config, OpUpdateOne, withCRMLeadSync(_m))
	return &CRMLeadSyncUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CRMLeadSyncClient) UpdateOneID(id int) *CRMLeadSyncUpdateOne {
	mutation := newCRMLeadSyncMutation(c.config, OpUpdateOne, withCRMLeadSyncID(id))
	return &CRMLeadSyncUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CRMLeadSync.
func (c *CRMLeadSyncClient) Delete() *CRMLeadSyncDelete {
	mutation := newCRMLeadSyncMutation(c.config, OpDelete)
	return &CRMLeadSyncDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CRMLeadSyncClient) DeleteOne(_m *CRMLeadSync) *CRMLeadSyncDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CRMLeadSyncClient) DeleteOneID(id int) *CRMLeadSyncDeleteOne {
	builder := c.Delete().Where(crmleadsync.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CRMLeadSyncDeleteOne{builder}
}

// Query returns a query builder for CRMLeadSync.
func (c *CRMLeadSyncClient) Query() *CRMLeadSyncQuery {
	return &CRMLeadSyncQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCRMLeadSync},
		inters: c.Interceptors(),
	}
}

// Get returns a CRMLeadSync entity by its id.
func (c *CRMLeadSyncClient) Get(ctx context.Context, id int) (*CRMLeadSync, error) {
	return c.Query().Where(crmleadsync.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CRMLeadSyncClient) GetX(ctx context.Context, id int) *CRMLeadSync {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIntegration queries the integration edge of a CRMLeadSync.
func (c *CRMLeadSyncClient) QueryIntegration(_m *CRMLeadSync) *CRMIntegrationQuery {
	query := (&CRMIntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(crmleadsync.Table, crmleadsync.FieldID, id),
			sqlgraph.To(crmintegration.Table, crmintegration.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, crmleadsync.IntegrationTable, crmleadsync.IntegrationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CRMLeadSyncClient) Hooks() []Hook {
	return c.hooks.CRMLeadSync
}

// Interceptors returns the client interceptors.
func (c *CRMLeadSyncClient) Interceptors() []Interceptor {
	return c.inters.CRMLeadSync
}

func (c *CRMLeadSyncClient) mutate(ctx context.Context, m *CRMLeadSyncMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CRMLeadSyncCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CRMLeadSyncUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CRMLeadSyncUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CRMLeadSyncDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CRMLeadSync mutation op: %q", m.Op())
	}
}

// CallLogClient is a client for the CallLog schema.
type CallLogClient struct {
	config
}

// NewCallLogClient returns a client for the CallLog from the given config.
func NewCallLogClient(c config) *CallLogClient {
	return &CallLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `calllog.Hooks(f(g(h())))`.
func (c *CallLogClient) Use(hooks ...Hook) {
	c.hooks.CallLog = append(c.hooks.CallLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `calllog.Intercept(f(g(h())))`.
func (c *CallLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.CallLog = append(c.inters.CallLog, interceptors...)
}

// Create returns a builder for creating a CallLog entity.
func (c *CallLogClient) Create() *CallLogCreate {
	mutation := newCallLogMutation(c.config, OpCreate)
	return &CallLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CallLog entities.
func (c *CallLogClient) CreateBulk(builders ...*CallLogCreate) *CallLogCreateBulk {
	return &CallLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CallLogClient) MapCreateBulk(slice any, setFunc func(*CallLogCreate, int)) *CallLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CallLogCreateBulk{err: fmt.Errorf("calling to CallLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CallLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CallLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CallLog.
func (c *CallLogClient) Update() *CallLogUpdate {
	mutation := newCallLogMutation(c.config, OpUpdate)
	return &CallLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CallLogClient) UpdateOne(_m *CallLog) *CallLogUpdateOne {
	mutation := newCallLogMutation(c.config, OpUpdateOne, withCallLog(_m))
	return &CallLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CallLogClient) UpdateOneID(id int) *CallLogUpdateOne {
	mutation := newCallLogMutation(c.config, OpUpdateOne, withCallLogID(id))
	return &CallLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CallLog.
func (c *CallLogClient) Delete() *CallLogDelete {
	mutation := newCallLogMutation(c.config, OpDelete)
	return &CallLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CallLogClient) DeleteOne(_m *CallLog) *CallLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CallLogClient) DeleteOneID(id int) *CallLogDeleteOne {
	builder := c.Delete().Where(calllog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CallLogDeleteOne{builder}
}

// Query returns a query builder for CallLog.
func (c *CallLogClient) Query() *CallLogQuery {
	return &CallLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCallLog},
		inters: c.Interceptors(),
	}
}

// Get returns a CallLog entity by its id.
func (c *CallLogClient) Get(ctx context.Context, id int) (*CallLog, error) {
	return c.Query().Where(calllog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CallLogClient) GetX(ctx context.Context, id int) *CallLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CallLog.
func (c *CallLogClient) QueryUser(_m *CallLog) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(calllog.Table, calllog.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, calllog.UserTable, calllog.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLead queries the lead edge of a CallLog.
func (c *CallLogClient) QueryLead(_m *CallLog) *LeadQuery {
	query := (&LeadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(calllog.Table, calllog.FieldID, id),
			sqlgraph.To(lead.Table, lead.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, calllog.LeadTable, calllog.LeadColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CallLogClient) Hooks() []Hook {
	return c.hooks.CallLog
}

// Interceptors returns the client interceptors.
func (c *CallLogClient) Interceptors() []Interceptor {
	return c.inters.CallLog
}

func (c *CallLogClient) mutate(ctx context.Context, m *CallLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CallLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CallLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CallLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CallLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CallLog mutation op: %q", m.Op())
	}
}

// CompetitorMetricClient is a client for the CompetitorMetric schema.
type CompetitorMetricClient struct {
	config
}

// NewCompetitorMetricClient returns a client for the CompetitorMetric from the given config.
func NewCompetitorMetricClient(c config) *CompetitorMetricClient {
	return &CompetitorMetricClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `competitormetric.Hooks(f(g(h())))`.
func (c *CompetitorMetricClient) Use(hooks ...Hook) {
	c.hooks.CompetitorMetric = append(c.hooks.CompetitorMetric, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `competitormetric.Intercept(f(g(h())))`.
func (c *CompetitorMetricClient) Intercept(interceptors ...Interceptor) {
	c.inters.CompetitorMetric = append(c.inters.CompetitorMetric, interceptors...)
}

// Create returns a builder for creating a CompetitorMetric entity.
func (c *CompetitorMetricClient) Create() *CompetitorMetricCreate {
	mutation := newCompetitorMetricMutation(c.config, OpCreate)
	return &CompetitorMetricCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CompetitorMetric entities.
func (c *CompetitorMetricClient) CreateBulk(builders ...*CompetitorMetricCreate) *CompetitorMetricCreateBulk {
	return &CompetitorMetricCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CompetitorMetricClient) MapCreateBulk(slice any, setFunc func(*CompetitorMetricCreate, int)) *CompetitorMetricCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CompetitorMetricCreateBulk{err: fmt.Errorf("calling to CompetitorMetricClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CompetitorMetricCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CompetitorMetricCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CompetitorMetric.
func (c *CompetitorMetricClient) Update() *CompetitorMetricUpdate {
	mutation := newCompetitorMetricMutation(c.config, OpUpdate)
	return &CompetitorMetricUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompetitorMetricClient) UpdateOne(_m *CompetitorMetric) *CompetitorMetricUpdateOne {
	mutation := newCompetitorMetricMutation(c.config, OpUpdateOne, withCompetitorMetric(_m))
	return &CompetitorMetricUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompetitorMetricClient) UpdateOneID(id int) *CompetitorMetricUpdateOne {
	mutation := newCompetitorMetricMutation(c.config, OpUpdateOne, withCompetitorMetricID(id))
	return &CompetitorMetricUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CompetitorMetric.
func (c *CompetitorMetricClient) Delete() *CompetitorMetricDelete {
	mutation := newCompetitorMetricMutation(c.config, OpDelete)
	return &CompetitorMetricDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompetitorMetricClient) DeleteOne(_m *CompetitorMetric) *CompetitorMetricDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompetitorMetricClient) DeleteOneID(id int) *CompetitorMetricDeleteOne {
	builder := c.Delete().Where(competitormetric.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompetitorMetricDeleteOne{builder}
}

// Query returns a query builder for CompetitorMetric.
func (c *CompetitorMetricClient) Query() *CompetitorMetricQuery {
	return &CompetitorMetricQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCompetitorMetric},
		inters: c.Interceptors(),
	}
}

// Get returns a CompetitorMetric entity by its id.
func (c *CompetitorMetricClient) Get(ctx context.Context, id int) (*CompetitorMetric, error) {
	return c.Query().Where(competitormetric.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompetitorMetricClient) GetX(ctx context.Context, id int) *CompetitorMetric {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompetitor queries the competitor edge of a CompetitorMetric.
func (c *CompetitorMetricClient) QueryCompetitor(_m *CompetitorMetric) *CompetitorProfileQuery {
	query := (&CompetitorProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(competitormetric.Table, competitormetric.FieldID, id),
			sqlgraph.To(competitorprofile.Table, competitorprofile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, competitormetric.CompetitorTable, competitormetric.CompetitorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompetitorMetricClient) Hooks() []Hook {
	return c.hooks.CompetitorMetric
}

// Interceptors returns the client interceptors.
func (c *CompetitorMetricClient) Interceptors() []Interceptor {
	return c.inters.CompetitorMetric
}

func (c *CompetitorMetricClient) mutate(ctx context.Context, m *CompetitorMetricMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompetitorMetricCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompetitorMetricUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompetitorMetricUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompetitorMetricDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CompetitorMetric mutation op: %q", m.Op())
	}
}

// CompetitorProfileClient is a client for the CompetitorProfile schema.
type CompetitorProfileClient struct {
	config
}

// NewCompetitorProfileClient returns a client for the CompetitorProfile from the given config.
func NewCompetitorProfileClient(c config) *CompetitorProfileClient {
	return &CompetitorProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `competitorprofile.Hooks(f(g(h())))`.
func (c *CompetitorProfileClient) Use(hooks ...Hook) {
	c.hooks.CompetitorProfile = append(c.hooks.CompetitorProfile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `competitorprofile.Intercept(f(g(h())))`.
func (c *CompetitorProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.CompetitorProfile = append(c.inters.CompetitorProfile, interceptors...)
}

// Create returns a builder for creating a CompetitorProfile entity.
func (c *CompetitorProfileClient) Create() *CompetitorProfileCreate {
	mutation := newCompetitorProfileMutation(c.config, OpCreate)
	return &CompetitorProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CompetitorProfile entities.
func (c *CompetitorProfileClient) CreateBulk(builders ...*CompetitorProfileCreate) *CompetitorProfileCreateBulk {
	return &CompetitorProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CompetitorProfileClient) MapCreateBulk(slice any, setFunc func(*CompetitorProfileCreate, int)) *CompetitorProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CompetitorProfileCreateBulk{err: fmt.Errorf("calling to CompetitorProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CompetitorProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CompetitorProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CompetitorProfile.
func (c *CompetitorProfileClient) Update() *CompetitorProfileUpdate {
	mutation := newCompetitorProfileMutation(c.config, OpUpdate)
	return &CompetitorProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompetitorProfileClient) UpdateOne(_m *CompetitorProfile) *CompetitorProfileUpdateOne {
	mutation := newCompetitorProfileMutation(c.config, OpUpdateOne, withCompetitorProfile(_m))
	return &CompetitorProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompetitorProfileClient) UpdateOneID(id int) *CompetitorProfileUpdateOne {
	mutation := newCompetitorProfileMutation(c.config, OpUpdateOne, withCompetitorProfileID(id))
	return &CompetitorProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CompetitorProfile.
func (c *CompetitorProfileClient) Delete() *CompetitorProfileDelete {
	mutation := newCompetitorProfileMutation(c.config, OpDelete)
	return &CompetitorProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompetitorProfileClient) DeleteOne(_m *CompetitorProfile) *CompetitorProfileDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompetitorProfileClient) DeleteOneID(id int) *CompetitorProfileDeleteOne {
	builder := c.Delete().Where(competitorprofile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompetitorProfileDeleteOne{builder}
}

// Query returns a query builder for CompetitorProfile.
func (c *CompetitorProfileClient) Query() *CompetitorProfileQuery {
	return &CompetitorProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCompetitorProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a CompetitorProfile entity by its id.
func (c *CompetitorProfileClient) Get(ctx context.Context, id int) (*CompetitorProfile, error) {
	return c.Query().Where(competitorprofile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompetitorProfileClient) GetX(ctx context.Context, id int) *CompetitorProfile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CompetitorProfile.
func (c *CompetitorProfileClient) QueryUser(_m *CompetitorProfile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(competitorprofile.Table, competitorprofile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, competitorprofile.UserTable, competitorprofile.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMetrics queries the metrics edge of a CompetitorProfile.
func (c *CompetitorProfileClient) QueryMetrics(_m *CompetitorProfile) *CompetitorMetricQuery {
	query := (&CompetitorMetricClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(competitorprofile.Table, competitorprofile.FieldID, id),
			sqlgraph.To(competitormetric.Table, competitormetric.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, competitorprofile.MetricsTable, competitorprofile.MetricsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompetitorProfileClient) Hooks() []Hook {
	return c.hooks.CompetitorProfile
}

// Interceptors returns the client interceptors.
func (c *CompetitorProfileClient) Interceptors() []Interceptor {
	return c.inters.CompetitorProfile
}

func (c *CompetitorProfileClient) mutate(ctx context.Context, m *CompetitorProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompetitorProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompetitorProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompetitorProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompetitorProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CompetitorProfile mutation op: %q", m.Op())
	}
}

// EmailCampaignClient is a client for the EmailCampaign schema.
type EmailCampaignClient struct {
	config
}

// NewEmailCampaignClient returns a client for the EmailCampaign from the given config.
func NewEmailCampaignClient(c config) *EmailCampaignClient {
	return &EmailCampaignClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emailcampaign.Hooks(f(g(h())))`.
func (c *EmailCampaignClient) Use(hooks ...Hook) {
	c.hooks.EmailCampaign = append(c.hooks.EmailCampaign, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `emailcampaign.Intercept(f(g(h())))`.
func (c *EmailCampaignClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmailCampaign = append(c.inters.EmailCampaign, interceptors...)
}

// Create returns a builder for creating a EmailCampaign entity.
func (c *EmailCampaignClient) Create() *EmailCampaignCreate {
	mutation := newEmailCampaignMutation(c.config, OpCreate)
	return &EmailCampaignCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailCampaign entities.
func (c *EmailCampaignClient) CreateBulk(builders ...*EmailCampaignCreate) *EmailCampaignCreateBulk {
	return &EmailCampaignCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmailCampaignClient) MapCreateBulk(slice any, setFunc func(*EmailCampaignCreate, int)) *EmailCampaignCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmailCampaignCreateBulk{err: fmt.Errorf("calling to EmailCampaignClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmailCampaignCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmailCampaignCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailCampaign.
func (c *EmailCampaignClient) Update() *EmailCampaignUpdate {
	mutation := newEmailCampaignMutation(c.config, OpUpdate)
	return &EmailCampaignUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailCampaignClient) UpdateOne(_m *EmailCampaign) *EmailCampaignUpdateOne {
	mutation := newEmailCampaignMutation(c.config, OpUpdateOne, withEmailCampaign(_m))
	return &EmailCampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailCampaignClient) UpdateOneID(id int) *EmailCampaignUpdateOne {
	mutation := newEmailCampaignMutation(c.config, OpUpdateOne, withEmailCampaignID(id))
	return &EmailCampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailCampaign.
func (c *EmailCampaignClient) Delete() *EmailCampaignDelete {
	mutation := newEmailCampaignMutation(c.config, OpDelete)
	return &EmailCampaignDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmailCampaignClient) DeleteOne(_m *EmailCampaign) *EmailCampaignDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmailCampaignClient) DeleteOneID(id int) *EmailCampaignDeleteOne {
	builder := c.Delete().Where(emailcampaign.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailCampaignDeleteOne{builder}
}

// Query returns a query builder for EmailCampaign.
func (c *EmailCampaignClient) Query() *EmailCampaignQuery {
	return &EmailCampaignQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmailCampaign},
		inters: c.Interceptors(),
	}
}

// Get returns a EmailCampaign entity by its id.
func (c *EmailCampaignClient) Get(ctx context.Context, id int) (*EmailCampaign, error) {
	return c.Query().Where(emailcampaign.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailCampaignClient) GetX(ctx context.Context, id int) *EmailCampaign {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a EmailCampaign.
func (c *EmailCampaignClient) QueryUser(_m *EmailCampaign) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailcampaign.Table, emailcampaign.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailcampaign.UserTable, emailcampaign.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecipients queries the recipients edge of a EmailCampaign.
func (c *EmailCampaignClient) QueryRecipients(_m *EmailCampaign) *EmailCampaignRecipientQuery {
	query := (&EmailCampaignRecipientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailcampaign.Table, emailcampaign.FieldID, id),
			sqlgraph.To(emailcampaignrecipient.Table, emailcampaignrecipient.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, emailcampaign.RecipientsTable, emailcampaign.RecipientsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailCampaignClient) Hooks() []Hook {
	return c.hooks.EmailCampaign
}

// Interceptors returns the client interceptors.
func (c *EmailCampaignClient) Interceptors() []Interceptor {
	return c.inters.EmailCampaign
}

func (c *EmailCampaignClient) mutate(ctx context.Context, m *EmailCampaignMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmailCampaignCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmailCampaignUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmailCampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmailCampaignDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmailCampaign mutation op: %q", m.Op())
	}
}

// EmailCampaignRecipientClient is a client for the EmailCampaignRecipient schema.
type EmailCampaignRecipientClient struct {
	config
}

// NewEmailCampaignRecipientClient returns a client for the EmailCampaignRecipient from the given config.
func NewEmailCampaignRecipientClient(c config) *EmailCampaignRecipientClient {
	return &EmailCampaignRecipientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emailcampaignrecipient.Hooks(f(g(h())))`.
func (c *EmailCampaignRecipientClient) Use(hooks ...Hook) {
	c.hooks.EmailCampaignRecipient = append(c.hooks.EmailCampaignRecipient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `emailcampaignrecipient.Intercept(f(g(h())))`.
func (c *EmailCampaignRecipientClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmailCampaignRecipient = append(c.inters.EmailCampaignRecipient, interceptors...)
}

// Create returns a builder for creating a EmailCampaignRecipient entity.
func (c *EmailCampaignRecipientClient) Create() *EmailCampaignRecipientCreate {
	mutation := newEmailCampaignRecipientMutation(c.config, OpCreate)
	return &EmailCampaignRecipientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailCampaignRecipient entities.
func (c *EmailCampaignRecipientClient) CreateBulk(builders ...*EmailCampaignRecipientCreate) *EmailCampaignRecipientCreateBulk {
	return &EmailCampaignRecipientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmailCampaignRecipientClient) MapCreateBulk(slice any, setFunc func(*EmailCampaignRecipientCreate, int)) *EmailCampaignRecipientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmailCampaignRecipientCreateBulk{err: fmt.Errorf("calling to EmailCampaignRecipientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmailCampaignRecipientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmailCampaignRecipientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailCampaignRecipient.
func (c *EmailCampaignRecipientClient) Update() *EmailCampaignRecipientUpdate {
	mutation := newEmailCampaignRecipientMutation(c.config, OpUpdate)
	return &EmailCampaignRecipientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailCampaignRecipientClient) UpdateOne(_m *EmailCampaignRecipient) *EmailCampaignRecipientUpdateOne {
	mutation := newEmailCampaignRecipientMutation(c.config, OpUpdateOne, withEmailCampaignRecipient(_m))
	return &EmailCampaignRecipientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailCampaignRecipientClient) UpdateOneID(id int) *EmailCampaignRecipientUpdateOne {
	mutation := newEmailCampaignRecipientMutation(c.config, OpUpdateOne, withEmailCampaignRecipientID(id))
	return &EmailCampaignRecipientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailCampaignRecipient.
func (c *EmailCampaignRecipientClient) Delete() *EmailCampaignRecipientDelete {
	mutation := newEmailCampaignRecipientMutation(c.config, OpDelete)
	return &EmailCampaignRecipientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmailCampaignRecipientClient) DeleteOne(_m *EmailCampaignRecipient) *EmailCampaignRecipientDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmailCampaignRecipientClient) DeleteOneID(id int) *EmailCampaignRecipientDeleteOne {
	builder := c.Delete().Where(emailcampaignrecipient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailCampaignRecipientDeleteOne{builder}
}

// Query returns a query builder for EmailCampaignRecipient.
func (c *EmailCampaignRecipientClient) Query() *EmailCampaignRecipientQuery {
	return &EmailCampaignRecipientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmailCampaignRecipient},
		inters: c.Interceptors(),
	}
}

// Get returns a EmailCampaignRecipient entity by its id.
func (c *EmailCampaignRecipientClient) Get(ctx context.Context, id int) (*EmailCampaignRecipient, error) {
	return c.Query().Where(emailcampaignrecipient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailCampaignRecipientClient) GetX(ctx context.Context, id int) *EmailCampaignRecipient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCampaign queries the campaign edge of a EmailCampaignRecipient.
func (c *EmailCampaignRecipientClient) QueryCampaign(_m *EmailCampaignRecipient) *EmailCampaignQuery {
	query := (&EmailCampaignClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailcampaignrecipient.Table, emailcampaignrecipient.FieldID, id),
			sqlgraph.To(emailcampaign.Table, emailcampaign.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailcampaignrecipient.CampaignTable, emailcampaignrecipient.CampaignColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailCampaignRecipientClient) Hooks() []Hook {
	return c.hooks.EmailCampaignRecipient
}

// Interceptors returns the client interceptors.
func (c *EmailCampaignRecipientClient) Interceptors() []Interceptor {
	return c.inters.EmailCampaignRecipient
}

func (c *EmailCampaignRecipientClient) mutate(ctx context.Context, m *EmailCampaignRecipientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmailCampaignRecipientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmailCampaignRecipientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmailCampaignRecipientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmailCampaignRecipientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmailCampaignRecipient mutation op: %q", m.Op())
	}
}

// EmailSequenceClient is a client for the EmailSequence schema.
type EmailSequenceClient struct {
	config
}

// NewEmailSequenceClient returns a client for the EmailSequence from the given config.
func NewEmailSequenceClient(c config) *EmailSequenceClient {
	return &EmailSequenceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emailsequence.Hooks(f(g(h())))`.
func (c *EmailSequenceClient) Use(hooks ...Hook) {
	c.hooks.EmailSequence = append(c.hooks.EmailSequence, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `emailsequence.Intercept(f(g(h())))`.
func (c *EmailSequenceClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmailSequence = append(c.inters.EmailSequence, interceptors...)
}

// Create returns a builder for creating a EmailSequence entity.
func (c *EmailSequenceClient) Create() *EmailSequenceCreate {
	mutation := newEmailSequenceMutation(c.config, OpCreate)
	return &EmailSequenceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailSequence entities.
func (c *EmailSequenceClient) CreateBulk(builders ...*EmailSequenceCreate) *EmailSequenceCreateBulk {
	return &EmailSequenceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmailSequenceClient) MapCreateBulk(slice any, setFunc func(*EmailSequenceCreate, int)) *EmailSequenceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmailSequenceCreateBulk{err: fmt.Errorf("calling to EmailSequenceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmailSequenceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmailSequenceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailSequence.
func (c *EmailSequenceClient) Update() *EmailSequenceUpdate {
	mutation := newEmailSequenceMutation(c.config, OpUpdate)
	return &EmailSequenceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailSequenceClient) UpdateOne(_m *EmailSequence) *EmailSequenceUpdateOne {
	mutation := newEmailSequenceMutation(c.config, OpUpdateOne, withEmailSequence(_m))
	return &EmailSequenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailSequenceClient) UpdateOneID(id int) *EmailSequenceUpdateOne {
	mutation := newEmailSequenceMutation(c.config, OpUpdateOne, withEmailSequenceID(id))
	return &EmailSequenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailSequence.
func (c *EmailSequenceClient) Delete() *EmailSequenceDelete {
	mutation := newEmailSequenceMutation(c.config, OpDelete)
	return &EmailSequenceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmailSequenceClient) DeleteOne(_m *EmailSequence) *EmailSequenceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmailSequenceClient) DeleteOneID(id int) *EmailSequenceDeleteOne {
	builder := c.Delete().Where(emailsequence.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailSequenceDeleteOne{builder}
}

// Query returns a query builder for EmailSequence.
func (c *EmailSequenceClient) Query() *EmailSequenceQuery {
	return &EmailSequenceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmailSequence},
		inters: c.Interceptors(),
	}
}

// Get returns a EmailSequence entity by its id.
func (c *EmailSequenceClient) Get(ctx context.Context, id int) (*EmailSequence, error) {
	return c.Query().Where(emailsequence.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailSequenceClient) GetX(ctx context.Context, id int) *EmailSequence {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCreatedBy queries the created_by edge of a EmailSequence.
func (c *EmailSequenceClient) QueryCreatedBy(_m *EmailSequence) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsequence.Table, emailsequence.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailsequence.CreatedByTable, emailsequence.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySteps queries the steps edge of a EmailSequence.
func (c *EmailSequenceClient) QuerySteps(_m *EmailSequence) *EmailSequenceStepQuery {
	query := (&EmailSequenceStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsequence.Table, emailsequence.FieldID, id),
			sqlgraph.To(emailsequencestep.Table, emailsequencestep.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, emailsequence.StepsTable, emailsequence.StepsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnrollments queries the enrollments edge of a EmailSequence.
func (c *EmailSequenceClient) QueryEnrollments(_m *EmailSequence) *EmailSequenceEnrollmentQuery {
	query := (&EmailSequenceEnrollmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsequence.Table, emailsequence.FieldID, id),
			sqlgraph.To(emailsequenceenrollment.Table, emailsequenceenrollment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, emailsequence.EnrollmentsTable, emailsequence.EnrollmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailSequenceClient) Hooks() []Hook {
	return c.hooks.EmailSequence
}

// Interceptors returns the client interceptors.
func (c *EmailSequenceClient) Interceptors() []Interceptor {
	return c.inters.EmailSequence
}

func (c *EmailSequenceClient) mutate(ctx context.Context, m *EmailSequenceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmailSequenceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmailSequenceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmailSequenceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmailSequenceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmailSequence mutation op: %q", m.Op())
	}
}

// EmailSequenceEnrollmentClient is a client for the EmailSequenceEnrollment schema.
type EmailSequenceEnrollmentClient struct {
	config
}

// NewEmailSequenceEnrollmentClient returns a client for the EmailSequenceEnrollment from the given config.
func NewEmailSequenceEnrollmentClient(c config) *EmailSequenceEnrollmentClient {
	return &EmailSequenceEnrollmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emailsequenceenrollment.Hooks(f(g(h())))`.
func (c *EmailSequenceEnrollmentClient) Use(hooks ...Hook) {
	c.hooks.EmailSequenceEnrollment = append(c.hooks.EmailSequenceEnrollment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `emailsequenceenrollment.Intercept(f(g(h())))`.
func (c *EmailSequenceEnrollmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmailSequenceEnrollment = append(c.inters.EmailSequenceEnrollment, interceptors...)
}

// Create returns a builder for creating a EmailSequenceEnrollment entity.
func (c *EmailSequenceEnrollmentClient) Create() *EmailSequenceEnrollmentCreate {
	mutation := newEmailSequenceEnrollmentMutation(c.config, OpCreate)
	return &EmailSequenceEnrollmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailSequenceEnrollment entities.
func (c *EmailSequenceEnrollmentClient) CreateBulk(builders ...*EmailSequenceEnrollmentCreate) *EmailSequenceEnrollmentCreateBulk {
	return &EmailSequenceEnrollmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmailSequenceEnrollmentClient) MapCreateBulk(slice any, setFunc func(*EmailSequenceEnrollmentCreate, int)) *EmailSequenceEnrollmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmailSequenceEnrollmentCreateBulk{err: fmt.Errorf("calling to EmailSequenceEnrollmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmailSequenceEnrollmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmailSequenceEnrollmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailSequenceEnrollment.
func (c *EmailSequenceEnrollmentClient) Update() *EmailSequenceEnrollmentUpdate {
	mutation := newEmailSequenceEnrollmentMutation(c.config, OpUpdate)
	return &EmailSequenceEnrollmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailSequenceEnrollmentClient) UpdateOne(_m *EmailSequenceEnrollment) *EmailSequenceEnrollmentUpdateOne {
	mutation := newEmailSequenceEnrollmentMutation(c.config, OpUpdateOne, withEmailSequenceEnrollment(_m))
	return &EmailSequenceEnrollmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailSequenceEnrollmentClient) UpdateOneID(id int) *EmailSequenceEnrollmentUpdateOne {
	mutation := newEmailSequenceEnrollmentMutation(c.config, OpUpdateOne, withEmailSequenceEnrollmentID(id))
	return &EmailSequenceEnrollmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailSequenceEnrollment.
func (c *EmailSequenceEnrollmentClient) Delete() *EmailSequenceEnrollmentDelete {
	mutation := newEmailSequenceEnrollmentMutation(c.config, OpDelete)
	return &EmailSequenceEnrollmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmailSequenceEnrollmentClient) DeleteOne(_m *EmailSequenceEnrollment) *EmailSequenceEnrollmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmailSequenceEnrollmentClient) DeleteOneID(id int) *EmailSequenceEnrollmentDeleteOne {
	builder := c.Delete().Where(emailsequenceenrollment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailSequenceEnrollmentDeleteOne{builder}
}

// Query returns a query builder for EmailSequenceEnrollment.
func (c *EmailSequenceEnrollmentClient) Query() *EmailSequenceEnrollmentQuery {
	return &EmailSequenceEnrollmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmailSequenceEnrollment},
		inters: c.Interceptors(),
	}
}

// Get returns a EmailSequenceEnrollment entity by its id.
func (c *EmailSequenceEnrollmentClient) Get(ctx context.Context, id int) (*EmailSequenceEnrollment, error) {
	return c.Query().Where(emailsequenceenrollment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailSequenceEnrollmentClient) GetX(ctx context.Context, id int) *EmailSequenceEnrollment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySequence queries the sequence edge of a EmailSequenceEnrollment.
func (c *EmailSequenceEnrollmentClient) QuerySequence(_m *EmailSequenceEnrollment) *EmailSequenceQuery {
	query := (&EmailSequenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsequenceenrollment.Table, emailsequenceenrollment.FieldID, id),
			sqlgraph.To(emailsequence.Table, emailsequence.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailsequenceenrollment.SequenceTable, emailsequenceenrollment.SequenceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLead queries the lead edge of a EmailSequenceEnrollment.
func (c *EmailSequenceEnrollmentClient) QueryLead(_m *EmailSequenceEnrollment) *LeadQuery {
	query := (&LeadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsequenceenrollment.Table, emailsequenceenrollment.FieldID, id),
			sqlgraph.To(lead.Table, lead.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailsequenceenrollment.LeadTable, emailsequenceenrollment.LeadColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnrolledBy queries the enrolled_by edge of a EmailSequenceEnrollment.
func (c *EmailSequenceEnrollmentClient) QueryEnrolledBy(_m *EmailSequenceEnrollment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsequenceenrollment.Table, emailsequenceenrollment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailsequenceenrollment.EnrolledByTable, emailsequenceenrollment.EnrolledByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySends queries the sends edge of a EmailSequenceEnrollment.
func (c *EmailSequenceEnrollmentClient) QuerySends(_m *EmailSequenceEnrollment) *EmailSequenceSendQuery {
	query := (&EmailSequenceSendClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsequenceenrollment.Table, emailsequenceenrollment.FieldID, id),
			sqlgraph.To(emailsequencesend.Table, emailsequencesend.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, emailsequenceenrollment.SendsTable, emailsequenceenrollment.SendsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailSequenceEnrollmentClient) Hooks() []Hook {
	return c.hooks.EmailSequenceEnrollment
}

// Interceptors returns the client interceptors.
func (c *EmailSequenceEnrollmentClient) Interceptors() []Interceptor {
	return c.inters.EmailSequenceEnrollment
}

func (c *EmailSequenceEnrollmentClient) mutate(ctx context.Context, m *EmailSequenceEnrollmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmailSequenceEnrollmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmailSequenceEnrollmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmailSequenceEnrollmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmailSequenceEnrollmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmailSequenceEnrollment mutation op: %q", m.Op())
	}
}

// EmailSequenceSendClient is a client for the EmailSequenceSend schema.
type EmailSequenceSendClient struct {
	config
}

// NewEmailSequenceSendClient returns a client for the EmailSequenceSend from the given config.
func NewEmailSequenceSendClient(c config) *EmailSequenceSendClient {
	return &EmailSequenceSendClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emailsequencesend.Hooks(f(g(h())))`.
func (c *EmailSequenceSendClient) Use(hooks ...Hook) {
	c.hooks.EmailSequenceSend = append(c.hooks.EmailSequenceSend, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `emailsequencesend.Intercept(f(g(h())))`.
func (c *EmailSequenceSendClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmailSequenceSend = append(c.inters.EmailSequenceSend, interceptors...)
}

// Create returns a builder for creating a EmailSequenceSend entity.
func (c *EmailSequenceSendClient) Create() *EmailSequenceSendCreate {
	mutation := newEmailSequenceSendMutation(c.config, OpCreate)
	return &EmailSequenceSendCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailSequenceSend entities.
func (c *EmailSequenceSendClient) CreateBulk(builders ...*EmailSequenceSendCreate) *EmailSequenceSendCreateBulk {
	return &EmailSequenceSendCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmailSequenceSendClient) MapCreateBulk(slice any, setFunc func(*EmailSequenceSendCreate, int)) *EmailSequenceSendCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmailSequenceSendCreateBulk{err: fmt.Errorf("calling to EmailSequenceSendClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmailSequenceSendCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmailSequenceSendCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailSequenceSend.
func (c *EmailSequenceSendClient) Update() *EmailSequenceSendUpdate {
	mutation := newEmailSequenceSendMutation(c.config, OpUpdate)
	return &EmailSequenceSendUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailSequenceSendClient) UpdateOne(_m *EmailSequenceSend) *EmailSequenceSendUpdateOne {
	mutation := newEmailSequenceSendMutation(c.config, OpUpdateOne, withEmailSequenceSend(_m))
	return &EmailSequenceSendUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailSequenceSendClient) UpdateOneID(id int) *EmailSequenceSendUpdateOne {
	mutation := newEmailSequenceSendMutation(c.config, OpUpdateOne, withEmailSequenceSendID(id))
	return &EmailSequenceSendUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailSequenceSend.
func (c *EmailSequenceSendClient) Delete() *EmailSequenceSendDelete {
	mutation := newEmailSequenceSendMutation(c.config, OpDelete)
	return &EmailSequenceSendDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmailSequenceSendClient) DeleteOne(_m *EmailSequenceSend) *EmailSequenceSendDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmailSequenceSendClient) DeleteOneID(id int) *EmailSequenceSendDeleteOne {
	builder := c.Delete().Where(emailsequencesend.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailSequenceSendDeleteOne{builder}
}

// Query returns a query builder for EmailSequenceSend.
func (c *EmailSequenceSendClient) Query() *EmailSequenceSendQuery {
	return &EmailSequenceSendQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmailSequenceSend},
		inters: c.Interceptors(),
	}
}

// Get returns a EmailSequenceSend entity by its id.
func (c *EmailSequenceSendClient) Get(ctx context.Context, id int) (*EmailSequenceSend, error) {
	return c.Query().Where(emailsequencesend.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailSequenceSendClient) GetX(ctx context.Context, id int) *EmailSequenceSend {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnrollment queries the enrollment edge of a EmailSequenceSend.
func (c *EmailSequenceSendClient) QueryEnrollment(_m *EmailSequenceSend) *EmailSequenceEnrollmentQuery {
	query := (&EmailSequenceEnrollmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsequencesend.Table, emailsequencesend.FieldID, id),
			sqlgraph.To(emailsequenceenrollment.Table, emailsequenceenrollment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailsequencesend.EnrollmentTable, emailsequencesend.EnrollmentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStep queries the step edge of a EmailSequenceSend.
func (c *EmailSequenceSendClient) QueryStep(_m *EmailSequenceSend) *EmailSequenceStepQuery {
	query := (&EmailSequenceStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsequencesend.Table, emailsequencesend.FieldID, id),
			sqlgraph.To(emailsequencestep.Table, emailsequencestep.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailsequencesend.StepTable, emailsequencesend.StepColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLead queries the lead edge of a EmailSequenceSend.
func (c *EmailSequenceSendClient) QueryLead(_m *EmailSequenceSend) *LeadQuery {
	query := (&LeadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsequencesend.Table, emailsequencesend.FieldID, id),
			sqlgraph.To(lead.Table, lead.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailsequencesend.LeadTable, emailsequencesend.LeadColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailSequenceSendClient) Hooks() []Hook {
	return c.hooks.EmailSequenceSend
}

// Interceptors returns the client interceptors.
func (c *EmailSequenceSendClient) Interceptors() []Interceptor {
	return c.inters.EmailSequenceSend
}

func (c *EmailSequenceSendClient) mutate(ctx context.Context, m *EmailSequenceSendMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmailSequenceSendCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmailSequenceSendUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmailSequenceSendUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmailSequenceSendDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmailSequenceSend mutation op: %q", m.Op())
	}
}

// EmailSequenceStepClient is a client for the EmailSequenceStep schema.
type EmailSequenceStepClient struct {
	config
}

// NewEmailSequenceStepClient returns a client for the EmailSequenceStep from the given config.
func NewEmailSequenceStepClient(c config) *EmailSequenceStepClient {
	return &EmailSequenceStepClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emailsequencestep.Hooks(f(g(h())))`.
func (c *EmailSequenceStepClient) Use(hooks ...Hook) {
	c.hooks.EmailSequenceStep = append(c.hooks.EmailSequenceStep, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `emailsequencestep.Intercept(f(g(h())))`.
func (c *EmailSequenceStepClient) Intercept(interceptors ...Interceptor) {
	c.inters.EmailSequenceStep = append(c.inters.EmailSequenceStep, interceptors...)
}

// Create returns a builder for creating a EmailSequenceStep entity.
func (c *EmailSequenceStepClient) Create() *EmailSequenceStepCreate {
	mutation := newEmailSequenceStepMutation(c.config, OpCreate)
	return &EmailSequenceStepCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailSequenceStep entities.
func (c *EmailSequenceStepClient) CreateBulk(builders ...*EmailSequenceStepCreate) *EmailSequenceStepCreateBulk {
	return &EmailSequenceStepCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EmailSequenceStepClient) MapCreateBulk(slice any, setFunc func(*EmailSequenceStepCreate, int)) *EmailSequenceStepCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EmailSequenceStepCreateBulk{err: fmt.Errorf("calling to EmailSequenceStepClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EmailSequenceStepCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EmailSequenceStepCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailSequenceStep.
func (c *EmailSequenceStepClient) Update() *EmailSequenceStepUpdate {
	mutation := newEmailSequenceStepMutation(c.config, OpUpdate)
	return &EmailSequenceStepUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailSequenceStepClient) UpdateOne(_m *EmailSequenceStep) *EmailSequenceStepUpdateOne {
	mutation := newEmailSequenceStepMutation(c.config, OpUpdateOne, withEmailSequenceStep(_m))
	return &EmailSequenceStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailSequenceStepClient) UpdateOneID(id int) *EmailSequenceStepUpdateOne {
	mutation := newEmailSequenceStepMutation(c.config, OpUpdateOne, withEmailSequenceStepID(id))
	return &EmailSequenceStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailSequenceStep.
func (c *EmailSequenceStepClient) Delete() *EmailSequenceStepDelete {
	mutation := newEmailSequenceStepMutation(c.config, OpDelete)
	return &EmailSequenceStepDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EmailSequenceStepClient) DeleteOne(_m *EmailSequenceStep) *EmailSequenceStepDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EmailSequenceStepClient) DeleteOneID(id int) *EmailSequenceStepDeleteOne {
	builder := c.Delete().Where(emailsequencestep.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailSequenceStepDeleteOne{builder}
}

// Query returns a query builder for EmailSequenceStep.
func (c *EmailSequenceStepClient) Query() *EmailSequenceStepQuery {
	return &EmailSequenceStepQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEmailSequenceStep},
		inters: c.Interceptors(),
	}
}

// Get returns a EmailSequenceStep entity by its id.
func (c *EmailSequenceStepClient) Get(ctx context.Context, id int) (*EmailSequenceStep, error) {
	return c.Query().Where(emailsequencestep.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailSequenceStepClient) GetX(ctx context.Context, id int) *EmailSequenceStep {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySequence queries the sequence edge of a EmailSequenceStep.
func (c *EmailSequenceStepClient) QuerySequence(_m *EmailSequenceStep) *EmailSequenceQuery {
	query := (&EmailSequenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsequencestep.Table, emailsequencestep.FieldID, id),
			sqlgraph.To(emailsequence.Table, emailsequence.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, emailsequencestep.SequenceTable, emailsequencestep.SequenceColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySends queries the sends edge of a EmailSequenceStep.
func (c *EmailSequenceStepClient) QuerySends(_m *EmailSequenceStep) *EmailSequenceSendQuery {
	query := (&EmailSequenceSendClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emailsequencestep.Table, emailsequencestep.FieldID, id),
			sqlgraph.To(emailsequencesend.Table, emailsequencesend.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, emailsequencestep.SendsTable, emailsequencestep.SendsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailSequenceStepClient) Hooks() []Hook {
	return c.hooks.EmailSequenceStep
}

// Interceptors returns the client interceptors.
func (c *EmailSequenceStepClient) Interceptors() []Interceptor {
	return c.inters.EmailSequenceStep
}

func (c *EmailSequenceStepClient) mutate(ctx context.Context, m *EmailSequenceStepMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EmailSequenceStepCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EmailSequenceStepUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EmailSequenceStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EmailSequenceStepDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EmailSequenceStep mutation op: %q", m.Op())
	}
}

// ExperimentClient is a client for the Experiment schema.
type ExperimentClient struct {
	config
}

// NewExperimentClient returns a client for the Experiment from the given config.
func NewExperimentClient(c config) *ExperimentClient {
	return &ExperimentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `experiment.Hooks(f(g(h())))`.
func (c *ExperimentClient) Use(hooks ...Hook) {
	c.hooks.Experiment = append(c.hooks.Experiment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `experiment.Intercept(f(g(h())))`.
func (c *ExperimentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Experiment = append(c.inters.Experiment, interceptors...)
}

// Create returns a builder for creating a Experiment entity.
func (c *ExperimentClient) Create() *ExperimentCreate {
	mutation := newExperimentMutation(c.config, OpCreate)
	return &ExperimentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Experiment entities.
func (c *ExperimentClient) CreateBulk(builders ...*ExperimentCreate) *ExperimentCreateBulk {
	return &ExperimentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExperimentClient) MapCreateBulk(slice any, setFunc func(*ExperimentCreate, int)) *ExperimentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExperimentCreateBulk{err: fmt.Errorf("calling to ExperimentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExperimentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExperimentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Experiment.
func (c *ExperimentClient) Update() *ExperimentUpdate {
	mutation := newExperimentMutation(c.config, OpUpdate)
	return &ExperimentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExperimentClient) UpdateOne(_m *Experiment) *ExperimentUpdateOne {
	mutation := newExperimentMutation(c.config, OpUpdateOne, withExperiment(_m))
	return &ExperimentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExperimentClient) UpdateOneID(id int) *ExperimentUpdateOne {
	mutation := newExperimentMutation(c.config, OpUpdateOne, withExperimentID(id))
	return &ExperimentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Experiment.
func (c *ExperimentClient) Delete() *ExperimentDelete {
	mutation := newExperimentMutation(c.config, OpDelete)
	return &ExperimentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExperimentClient) DeleteOne(_m *Experiment) *ExperimentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExperimentClient) DeleteOneID(id int) *ExperimentDeleteOne {
	builder := c.Delete().Where(experiment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExperimentDeleteOne{builder}
}

// Query returns a query builder for Experiment.
func (c *ExperimentClient) Query() *ExperimentQuery {
	return &ExperimentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExperiment},
		inters: c.Interceptors(),
	}
}

// Get returns a Experiment entity by its id.
func (c *ExperimentClient) Get(ctx context.Context, id int) (*Experiment, error) {
	return c.Query().Where(experiment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExperimentClient) GetX(ctx context.Context, id int) *Experiment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAssignments queries the assignments edge of a Experiment.
func (c *ExperimentClient) QueryAssignments(_m *Experiment) *ExperimentAssignmentQuery {
	query := (&ExperimentAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(experiment.Table, experiment.FieldID, id),
			sqlgraph.To(experimentassignment.Table, experimentassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, experiment.AssignmentsTable, experiment.AssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExperimentClient) Hooks() []Hook {
	return c.hooks.Experiment
}

// Interceptors returns the client interceptors.
func (c *ExperimentClient) Interceptors() []Interceptor {
	return c.inters.Experiment
}

func (c *ExperimentClient) mutate(ctx context.Context, m *ExperimentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExperimentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExperimentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExperimentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExperimentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Experiment mutation op: %q", m.Op())
	}
}

// ExperimentAssignmentClient is a client for the ExperimentAssignment schema.
type ExperimentAssignmentClient struct {
	config
}

// NewExperimentAssignmentClient returns a client for the ExperimentAssignment from the given config.
func NewExperimentAssignmentClient(c config) *ExperimentAssignmentClient {
	return &ExperimentAssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `experimentassignment.Hooks(f(g(h())))`.
func (c *ExperimentAssignmentClient) Use(hooks ...Hook) {
	c.hooks.ExperimentAssignment = append(c.hooks.ExperimentAssignment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `experimentassignment.Intercept(f(g(h())))`.
func (c *ExperimentAssignmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExperimentAssignment = append(c.inters.ExperimentAssignment, interceptors...)
}

// Create returns a builder for creating a ExperimentAssignment entity.
func (c *ExperimentAssignmentClient) Create() *ExperimentAssignmentCreate {
	mutation := newExperimentAssignmentMutation(c.config, OpCreate)
	return &ExperimentAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExperimentAssignment entities.
func (c *ExperimentAssignmentClient) CreateBulk(builders ...*ExperimentAssignmentCreate) *ExperimentAssignmentCreateBulk {
	return &ExperimentAssignmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExperimentAssignmentClient) MapCreateBulk(slice any, setFunc func(*ExperimentAssignmentCreate, int)) *ExperimentAssignmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExperimentAssignmentCreateBulk{err: fmt.Errorf("calling to ExperimentAssignmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExperimentAssignmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExperimentAssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExperimentAssignment.
func (c *ExperimentAssignmentClient) Update() *ExperimentAssignmentUpdate {
	mutation := newExperimentAssignmentMutation(c.config, OpUpdate)
	return &ExperimentAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExperimentAssignmentClient) UpdateOne(_m *ExperimentAssignment) *ExperimentAssignmentUpdateOne {
	mutation := newExperimentAssignmentMutation(c.config, OpUpdateOne, withExperimentAssignment(_m))
	return &ExperimentAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExperimentAssignmentClient) UpdateOneID(id int) *ExperimentAssignmentUpdateOne {
	mutation := newExperimentAssignmentMutation(c.config, OpUpdateOne, withExperimentAssignmentID(id))
	return &ExperimentAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExperimentAssignment.
func (c *ExperimentAssignmentClient) Delete() *ExperimentAssignmentDelete {
	mutation := newExperimentAssignmentMutation(c.config, OpDelete)
	return &ExperimentAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExperimentAssignmentClient) DeleteOne(_m *ExperimentAssignment) *ExperimentAssignmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExperimentAssignmentClient) DeleteOneID(id int) *ExperimentAssignmentDeleteOne {
	builder := c.Delete().Where(experimentassignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExperimentAssignmentDeleteOne{builder}
}

// Query returns a query builder for ExperimentAssignment.
func (c *ExperimentAssignmentClient) Query() *ExperimentAssignmentQuery {
	return &ExperimentAssignmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExperimentAssignment},
		inters: c.Interceptors(),
	}
}

// Get returns a ExperimentAssignment entity by its id.
func (c *ExperimentAssignmentClient) Get(ctx context.Context, id int) (*ExperimentAssignment, error) {
	return c.Query().Where(experimentassignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExperimentAssignmentClient) GetX(ctx context.Context, id int) *ExperimentAssignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExperiment queries the experiment edge of a ExperimentAssignment.
func (c *ExperimentAssignmentClient) QueryExperiment(_m *ExperimentAssignment) *ExperimentQuery {
	query := (&ExperimentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(experimentassignment.Table, experimentassignment.FieldID, id),
			sqlgraph.To(experiment.Table, experiment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, experimentassignment.ExperimentTable, experimentassignment.ExperimentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ExperimentAssignment.
func (c *ExperimentAssignmentClient) QueryUser(_m *ExperimentAssignment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(experimentassignment.Table, experimentassignment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, experimentassignment.UserTable, experimentassignment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExperimentAssignmentClient) Hooks() []Hook {
	return c.hooks.ExperimentAssignment
}

// Interceptors returns the client interceptors.
func (c *ExperimentAssignmentClient) Interceptors() []Interceptor {
	return c.inters.ExperimentAssignment
}

func (c *ExperimentAssignmentClient) mutate(ctx context.Context, m *ExperimentAssignmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExperimentAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExperimentAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExperimentAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExperimentAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExperimentAssignment mutation op: %q", m.Op())
	}
}

// ExportClient is a client for the Export schema.
type ExportClient struct {
	config
}

// NewExportClient returns a client for the Export from the given config.
func NewExportClient(c config) *ExportClient {
	return &ExportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `export.Hooks(f(g(h())))`.
func (c *ExportClient) Use(hooks ...Hook) {
	c.hooks.Export = append(c.hooks.Export, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `export.Intercept(f(g(h())))`.
func (c *ExportClient) Intercept(interceptors ...Interceptor) {
	c.inters.Export = append(c.inters.Export, interceptors...)
}

// Create returns a builder for creating a Export entity.
func (c *ExportClient) Create() *ExportCreate {
	mutation := newExportMutation(c.config, OpCreate)
	return &ExportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Export entities.
func (c *ExportClient) CreateBulk(builders ...*ExportCreate) *ExportCreateBulk {
	return &ExportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExportClient) MapCreateBulk(slice any, setFunc func(*ExportCreate, int)) *ExportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExportCreateBulk{err: fmt.Errorf("calling to ExportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Export.
func (c *ExportClient) Update() *ExportUpdate {
	mutation := newExportMutation(c.config, OpUpdate)
	return &ExportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExportClient) UpdateOne(_m *Export) *ExportUpdateOne {
	mutation := newExportMutation(c.config, OpUpdateOne, withExport(_m))
	return &ExportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExportClient) UpdateOneID(id int) *ExportUpdateOne {
	mutation := newExportMutation(c.config, OpUpdateOne, withExportID(id))
	return &ExportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Export.
func (c *ExportClient) Delete() *ExportDelete {
	mutation := newExportMutation(c.config, OpDelete)
	return &ExportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExportClient) DeleteOne(_m *Export) *ExportDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExportClient) DeleteOneID(id int) *ExportDeleteOne {
	builder := c.Delete().Where(export.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExportDeleteOne{builder}
}

// Query returns a query builder for Export.
func (c *ExportClient) Query() *ExportQuery {
	return &ExportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExport},
		inters: c.Interceptors(),
	}
}

// Get returns a Export entity by its id.
func (c *ExportClient) Get(ctx context.Context, id int) (*Export, error) {
	return c.Query().Where(export.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExportClient) GetX(ctx context.Context, id int) *Export {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Export.
func (c *ExportClient) QueryUser(_m *Export) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(export.Table, export.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, export.UserTable, export.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a Export.
func (c *ExportClient) QueryOrganization(_m *Export) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(export.Table, export.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, export.OrganizationTable, export.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExportClient) Hooks() []Hook {
	return c.hooks.Export
}

// Interceptors returns the client interceptors.
func (c *ExportClient) Interceptors() []Interceptor {
	return c.inters.Export
}

func (c *ExportClient) mutate(ctx context.Context, m *ExportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Export mutation op: %q", m.Op())
	}
}

// IndustryClient is a client for the Industry schema.
type IndustryClient struct {
	config
}

// NewIndustryClient returns a client for the Industry from the given config.
func NewIndustryClient(c config) *IndustryClient {
	return &IndustryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `industry.Hooks(f(g(h())))`.
func (c *IndustryClient) Use(hooks ...Hook) {
	c.hooks.Industry = append(c.hooks.Industry, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `industry.Intercept(f(g(h())))`.
func (c *IndustryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Industry = append(c.inters.Industry, interceptors...)
}

// Create returns a builder for creating a Industry entity.
func (c *IndustryClient) Create() *IndustryCreate {
	mutation := newIndustryMutation(c.config, OpCreate)
	return &IndustryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Industry entities.
func (c *IndustryClient) CreateBulk(builders ...*IndustryCreate) *IndustryCreateBulk {
	return &IndustryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IndustryClient) MapCreateBulk(slice any, setFunc func(*IndustryCreate, int)) *IndustryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IndustryCreateBulk{err: fmt.Errorf("calling to IndustryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IndustryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IndustryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Industry.
func (c *IndustryClient) Update() *IndustryUpdate {
	mutation := newIndustryMutation(c.config, OpUpdate)
	return &IndustryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IndustryClient) UpdateOne(_m *Industry) *IndustryUpdateOne {
	mutation := newIndustryMutation(c.config, OpUpdateOne, withIndustry(_m))
	return &IndustryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IndustryClient) UpdateOneID(id string) *IndustryUpdateOne {
	mutation := newIndustryMutation(c.config, OpUpdateOne, withIndustryID(id))
	return &IndustryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Industry.
func (c *IndustryClient) Delete() *IndustryDelete {
	mutation := newIndustryMutation(c.config, OpDelete)
	return &IndustryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IndustryClient) DeleteOne(_m *Industry) *IndustryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IndustryClient) DeleteOneID(id string) *IndustryDeleteOne {
	builder := c.Delete().Where(industry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IndustryDeleteOne{builder}
}

// Query returns a query builder for Industry.
func (c *IndustryClient) Query() *IndustryQuery {
	return &IndustryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIndustry},
		inters: c.Interceptors(),
	}
}

// Get returns a Industry entity by its id.
func (c *IndustryClient) Get(ctx context.Context, id string) (*Industry, error) {
	return c.Query().Where(industry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IndustryClient) GetX(ctx context.Context, id string) *Industry {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *IndustryClient) Hooks() []Hook {
	return c.hooks.Industry
}

// Interceptors returns the client interceptors.
func (c *IndustryClient) Interceptors() []Interceptor {
	return c.inters.Industry
}

func (c *IndustryClient) mutate(ctx context.Context, m *IndustryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IndustryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IndustryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IndustryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IndustryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Industry mutation op: %q", m.Op())
	}
}

// LeadClient is a client for the Lead schema.
type LeadClient struct {
	config
}

// NewLeadClient returns a client for the Lead from the given config.
func NewLeadClient(c config) *LeadClient {
	return &LeadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `lead.Hooks(f(g(h())))`.
func (c *LeadClient) Use(hooks ...Hook) {
	c.hooks.Lead = append(c.hooks.Lead, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `lead.Intercept(f(g(h())))`.
func (c *LeadClient) Intercept(interceptors ...Interceptor) {
	c.inters.Lead = append(c.inters.Lead, interceptors...)
}

// Create returns a builder for creating a Lead entity.
func (c *LeadClient) Create() *LeadCreate {
	mutation := newLeadMutation(c.config, OpCreate)
	return &LeadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Lead entities.
func (c *LeadClient) CreateBulk(builders ...*LeadCreate) *LeadCreateBulk {
	return &LeadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LeadClient) MapCreateBulk(slice any, setFunc func(*LeadCreate, int)) *LeadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LeadCreateBulk{err: fmt.Errorf("calling to LeadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LeadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LeadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Lead.
func (c *LeadClient) Update() *LeadUpdate {
	mutation := newLeadMutation(c.config, OpUpdate)
	return &LeadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LeadClient) UpdateOne(_m *Lead) *LeadUpdateOne {
	mutation := newLeadMutation(c.config, OpUpdateOne, withLead(_m))
	return &LeadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LeadClient) UpdateOneID(id int) *LeadUpdateOne {
	mutation := newLeadMutation(c.config, OpUpdateOne, withLeadID(id))
	return &LeadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Lead.
func (c *LeadClient) Delete() *LeadDelete {
	mutation := newLeadMutation(c.config, OpDelete)
	return &LeadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LeadClient) DeleteOne(_m *Lead) *LeadDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LeadClient) DeleteOneID(id int) *LeadDeleteOne {
	builder := c.Delete().Where(lead.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LeadDeleteOne{builder}
}

// Query returns a query builder for Lead.
func (c *LeadClient) Query() *LeadQuery {
	return &LeadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLead},
		inters: c.Interceptors(),
	}
}

// Get returns a Lead entity by its id.
func (c *LeadClient) Get(ctx context.Context, id int) (*Lead, error) {
	return c.Query().Where(lead.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LeadClient) GetX(ctx context.Context, id int) *Lead {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNotes queries the notes edge of a Lead.
func (c *LeadClient) QueryNotes(_m *Lead) *LeadNoteQuery {
	query := (&LeadNoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lead.Table, lead.FieldID, id),
			sqlgraph.To(leadnote.Table, leadnote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lead.NotesTable, lead.NotesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatusHistory queries the status_history edge of a Lead.
func (c *LeadClient) QueryStatusHistory(_m *Lead) *LeadStatusHistoryQuery {
	query := (&LeadStatusHistoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lead.Table, lead.FieldID, id),
			sqlgraph.To(leadstatushistory.Table, leadstatushistory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lead.StatusHistoryTable, lead.StatusHistoryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignments queries the assignments edge of a Lead.
func (c *LeadClient) QueryAssignments(_m *Lead) *LeadAssignmentQuery {
	query := (&LeadAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lead.Table, lead.FieldID, id),
			sqlgraph.To(leadassignment.Table, leadassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lead.AssignmentsTable, lead.AssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmailSequenceEnrollments queries the email_sequence_enrollments edge of a Lead.
func (c *LeadClient) QueryEmailSequenceEnrollments(_m *Lead) *EmailSequenceEnrollmentQuery {
	query := (&EmailSequenceEnrollmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lead.Table, lead.FieldID, id),
			sqlgraph.To(emailsequenceenrollment.Table, emailsequenceenrollment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lead.EmailSequenceEnrollmentsTable, lead.EmailSequenceEnrollmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmailSequenceSends queries the email_sequence_sends edge of a Lead.
func (c *LeadClient) QueryEmailSequenceSends(_m *Lead) *EmailSequenceSendQuery {
	query := (&EmailSequenceSendClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lead.Table, lead.FieldID, id),
			sqlgraph.To(emailsequencesend.Table, emailsequencesend.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lead.EmailSequenceSendsTable, lead.EmailSequenceSendsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTerritory queries the territory edge of a Lead.
func (c *LeadClient) QueryTerritory(_m *Lead) *TerritoryQuery {
	query := (&TerritoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lead.Table, lead.FieldID, id),
			sqlgraph.To(territory.Table, territory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, lead.TerritoryTable, lead.TerritoryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySmsMessages queries the sms_messages edge of a Lead.
func (c *LeadClient) QuerySmsMessages(_m *Lead) *SMSMessageQuery {
	query := (&SMSMessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lead.Table, lead.FieldID, id),
			sqlgraph.To(smsmessage.Table, smsmessage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lead.SmsMessagesTable, lead.SmsMessagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCallLogs queries the call_logs edge of a Lead.
func (c *LeadClient) QueryCallLogs(_m *Lead) *CallLogQuery {
	query := (&CallLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lead.Table, lead.FieldID, id),
			sqlgraph.To(calllog.Table, calllog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lead.CallLogsTable, lead.CallLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecommendations queries the recommendations edge of a Lead.
func (c *LeadClient) QueryRecommendations(_m *Lead) *LeadRecommendationQuery {
	query := (&LeadRecommendationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(lead.Table, lead.FieldID, id),
			sqlgraph.To(leadrecommendation.Table, leadrecommendation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, lead.RecommendationsTable, lead.RecommendationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LeadClient) Hooks() []Hook {
	return c.hooks.Lead
}

// Interceptors returns the client interceptors.
func (c *LeadClient) Interceptors() []Interceptor {
	return c.inters.Lead
}

func (c *LeadClient) mutate(ctx context.Context, m *LeadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LeadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LeadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LeadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LeadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Lead mutation op: %q", m.Op())
	}
}

// LeadAssignmentClient is a client for the LeadAssignment schema.
type LeadAssignmentClient struct {
	config
}

// NewLeadAssignmentClient returns a client for the LeadAssignment from the given config.
func NewLeadAssignmentClient(c config) *LeadAssignmentClient {
	return &LeadAssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `leadassignment.Hooks(f(g(h())))`.
func (c *LeadAssignmentClient) Use(hooks ...Hook) {
	c.hooks.LeadAssignment = append(c.hooks.LeadAssignment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `leadassignment.Intercept(f(g(h())))`.
func (c *LeadAssignmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.LeadAssignment = append(c.inters.LeadAssignment, interceptors...)
}

// Create returns a builder for creating a LeadAssignment entity.
func (c *LeadAssignmentClient) Create() *LeadAssignmentCreate {
	mutation := newLeadAssignmentMutation(c.config, OpCreate)
	return &LeadAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LeadAssignment entities.
func (c *LeadAssignmentClient) CreateBulk(builders ...*LeadAssignmentCreate) *LeadAssignmentCreateBulk {
	return &LeadAssignmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LeadAssignmentClient) MapCreateBulk(slice any, setFunc func(*LeadAssignmentCreate, int)) *LeadAssignmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LeadAssignmentCreateBulk{err: fmt.Errorf("calling to LeadAssignmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LeadAssignmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LeadAssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LeadAssignment.
func (c *LeadAssignmentClient) Update() *LeadAssignmentUpdate {
	mutation := newLeadAssignmentMutation(c.config, OpUpdate)
	return &LeadAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LeadAssignmentClient) UpdateOne(_m *LeadAssignment) *LeadAssignmentUpdateOne {
	mutation := newLeadAssignmentMutation(c.config, OpUpdateOne, withLeadAssignment(_m))
	return &LeadAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LeadAssignmentClient) UpdateOneID(id int) *LeadAssignmentUpdateOne {
	mutation := newLeadAssignmentMutation(c.config, OpUpdateOne, withLeadAssignmentID(id))
	return &LeadAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LeadAssignment.
func (c *LeadAssignmentClient) Delete() *LeadAssignmentDelete {
	mutation := newLeadAssignmentMutation(c.config, OpDelete)
	return &LeadAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LeadAssignmentClient) DeleteOne(_m *LeadAssignment) *LeadAssignmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LeadAssignmentClient) DeleteOneID(id int) *LeadAssignmentDeleteOne {
	builder := c.Delete().Where(leadassignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LeadAssignmentDeleteOne{builder}
}

// Query returns a query builder for LeadAssignment.
func (c *LeadAssignmentClient) Query() *LeadAssignmentQuery {
	return &LeadAssignmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLeadAssignment},
		inters: c.Interceptors(),
	}
}

// Get returns a LeadAssignment entity by its id.
func (c *LeadAssignmentClient) Get(ctx context.Context, id int) (*LeadAssignment, error) {
	return c.Query().Where(leadassignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LeadAssignmentClient) GetX(ctx context.Context, id int) *LeadAssignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLead queries the lead edge of a LeadAssignment.
func (c *LeadAssignmentClient) QueryLead(_m *LeadAssignment) *LeadQuery {
	query := (&LeadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(leadassignment.Table, leadassignment.FieldID, id),
			sqlgraph.To(lead.Table, lead.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, leadassignment.LeadTable, leadassignment.LeadColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a LeadAssignment.
func (c *LeadAssignmentClient) QueryUser(_m *LeadAssignment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(leadassignment.Table, leadassignment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, leadassignment.UserTable, leadassignment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedBy queries the assigned_by edge of a LeadAssignment.
func (c *LeadAssignmentClient) QueryAssignedBy(_m *LeadAssignment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(leadassignment.Table, leadassignment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, leadassignment.AssignedByTable, leadassignment.AssignedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LeadAssignmentClient) Hooks() []Hook {
	return c.hooks.LeadAssignment
}

// Interceptors returns the client interceptors.
func (c *LeadAssignmentClient) Interceptors() []Interceptor {
	return c.inters.LeadAssignment
}

func (c *LeadAssignmentClient) mutate(ctx context.Context, m *LeadAssignmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LeadAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LeadAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LeadAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LeadAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LeadAssignment mutation op: %q", m.Op())
	}
}

// LeadNoteClient is a client for the LeadNote schema.
type LeadNoteClient struct {
	config
}

// NewLeadNoteClient returns a client for the LeadNote from the given config.
func NewLeadNoteClient(c config) *LeadNoteClient {
	return &LeadNoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `leadnote.Hooks(f(g(h())))`.
func (c *LeadNoteClient) Use(hooks ...Hook) {
	c.hooks.LeadNote = append(c.hooks.LeadNote, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `leadnote.Intercept(f(g(h())))`.
func (c *LeadNoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.LeadNote = append(c.inters.LeadNote, interceptors...)
}

// Create returns a builder for creating a LeadNote entity.
func (c *LeadNoteClient) Create() *LeadNoteCreate {
	mutation := newLeadNoteMutation(c.config, OpCreate)
	return &LeadNoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LeadNote entities.
func (c *LeadNoteClient) CreateBulk(builders ...*LeadNoteCreate) *LeadNoteCreateBulk {
	return &LeadNoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LeadNoteClient) MapCreateBulk(slice any, setFunc func(*LeadNoteCreate, int)) *LeadNoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LeadNoteCreateBulk{err: fmt.Errorf("calling to LeadNoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LeadNoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LeadNoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LeadNote.
func (c *LeadNoteClient) Update() *LeadNoteUpdate {
	mutation := newLeadNoteMutation(c.config, OpUpdate)
	return &LeadNoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LeadNoteClient) UpdateOne(_m *LeadNote) *LeadNoteUpdateOne {
	mutation := newLeadNoteMutation(c.config, OpUpdateOne, withLeadNote(_m))
	return &LeadNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LeadNoteClient) UpdateOneID(id int) *LeadNoteUpdateOne {
	mutation := newLeadNoteMutation(c.config, OpUpdateOne, withLeadNoteID(id))
	return &LeadNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LeadNote.
func (c *LeadNoteClient) Delete() *LeadNoteDelete {
	mutation := newLeadNoteMutation(c.config, OpDelete)
	return &LeadNoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LeadNoteClient) DeleteOne(_m *LeadNote) *LeadNoteDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LeadNoteClient) DeleteOneID(id int) *LeadNoteDeleteOne {
	builder := c.Delete().Where(leadnote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LeadNoteDeleteOne{builder}
}

// Query returns a query builder for LeadNote.
func (c *LeadNoteClient) Query() *LeadNoteQuery {
	return &LeadNoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLeadNote},
		inters: c.Interceptors(),
	}
}

// Get returns a LeadNote entity by its id.
func (c *LeadNoteClient) Get(ctx context.Context, id int) (*LeadNote, error) {
	return c.Query().Where(leadnote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LeadNoteClient) GetX(ctx context.Context, id int) *LeadNote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLead queries the lead edge of a LeadNote.
func (c *LeadNoteClient) QueryLead(_m *LeadNote) *LeadQuery {
	query := (&LeadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(leadnote.Table, leadnote.FieldID, id),
			sqlgraph.To(lead.Table, lead.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, leadnote.LeadTable, leadnote.LeadColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a LeadNote.
func (c *LeadNoteClient) QueryUser(_m *LeadNote) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(leadnote.Table, leadnote.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, leadnote.UserTable, leadnote.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LeadNoteClient) Hooks() []Hook {
	return c.hooks.LeadNote
}

// Interceptors returns the client interceptors.
func (c *LeadNoteClient) Interceptors() []Interceptor {
	return c.inters.LeadNote
}

func (c *LeadNoteClient) mutate(ctx context.Context, m *LeadNoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LeadNoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LeadNoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LeadNoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LeadNoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LeadNote mutation op: %q", m.Op())
	}
}

// LeadRecommendationClient is a client for the LeadRecommendation schema.
type LeadRecommendationClient struct {
	config
}

// NewLeadRecommendationClient returns a client for the LeadRecommendation from the given config.
func NewLeadRecommendationClient(c config) *LeadRecommendationClient {
	return &LeadRecommendationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `leadrecommendation.Hooks(f(g(h())))`.
func (c *LeadRecommendationClient) Use(hooks ...Hook) {
	c.hooks.LeadRecommendation = append(c.hooks.LeadRecommendation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `leadrecommendation.Intercept(f(g(h())))`.
func (c *LeadRecommendationClient) Intercept(interceptors ...Interceptor) {
	c.inters.LeadRecommendation = append(c.inters.LeadRecommendation, interceptors...)
}

// Create returns a builder for creating a LeadRecommendation entity.
func (c *LeadRecommendationClient) Create() *LeadRecommendationCreate {
	mutation := newLeadRecommendationMutation(c.config, OpCreate)
	return &LeadRecommendationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LeadRecommendation entities.
func (c *LeadRecommendationClient) CreateBulk(builders ...*LeadRecommendationCreate) *LeadRecommendationCreateBulk {
	return &LeadRecommendationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LeadRecommendationClient) MapCreateBulk(slice any, setFunc func(*LeadRecommendationCreate, int)) *LeadRecommendationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LeadRecommendationCreateBulk{err: fmt.Errorf("calling to LeadRecommendationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LeadRecommendationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LeadRecommendationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LeadRecommendation.
func (c *LeadRecommendationClient) Update() *LeadRecommendationUpdate {
	mutation := newLeadRecommendationMutation(c.config, OpUpdate)
	return &LeadRecommendationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LeadRecommendationClient) UpdateOne(_m *LeadRecommendation) *LeadRecommendationUpdateOne {
	mutation := newLeadRecommendationMutation(c.config, OpUpdateOne, withLeadRecommendation(_m))
	return &LeadRecommendationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LeadRecommendationClient) UpdateOneID(id int) *LeadRecommendationUpdateOne {
	mutation := newLeadRecommendationMutation(c.config, OpUpdateOne, withLeadRecommendationID(id))
	return &LeadRecommendationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LeadRecommendation.
func (c *LeadRecommendationClient) Delete() *LeadRecommendationDelete {
	mutation := newLeadRecommendationMutation(c.config, OpDelete)
	return &LeadRecommendationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LeadRecommendationClient) DeleteOne(_m *LeadRecommendation) *LeadRecommendationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LeadRecommendationClient) DeleteOneID(id int) *LeadRecommendationDeleteOne {
	builder := c.Delete().Where(leadrecommendation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LeadRecommendationDeleteOne{builder}
}

// Query returns a query builder for LeadRecommendation.
func (c *LeadRecommendationClient) Query() *LeadRecommendationQuery {
	return &LeadRecommendationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLeadRecommendation},
		inters: c.Interceptors(),
	}
}

// Get returns a LeadRecommendation entity by its id.
func (c *LeadRecommendationClient) Get(ctx context.Context, id int) (*LeadRecommendation, error) {
	return c.Query().Where(leadrecommendation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LeadRecommendationClient) GetX(ctx context.Context, id int) *LeadRecommendation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a LeadRecommendation.
func (c *LeadRecommendationClient) QueryUser(_m *LeadRecommendation) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(leadrecommendation.Table, leadrecommendation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, leadrecommendation.UserTable, leadrecommendation.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLead queries the lead edge of a LeadRecommendation.
func (c *LeadRecommendationClient) QueryLead(_m *LeadRecommendation) *LeadQuery {
	query := (&LeadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(leadrecommendation.Table, leadrecommendation.FieldID, id),
			sqlgraph.To(lead.Table, lead.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, leadrecommendation.LeadTable, leadrecommendation.LeadColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LeadRecommendationClient) Hooks() []Hook {
	return c.hooks.LeadRecommendation
}

// Interceptors returns the client interceptors.
func (c *LeadRecommendationClient) Interceptors() []Interceptor {
	return c.inters.LeadRecommendation
}

func (c *LeadRecommendationClient) mutate(ctx context.Context, m *LeadRecommendationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LeadRecommendationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LeadRecommendationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LeadRecommendationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LeadRecommendationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LeadRecommendation mutation op: %q", m.Op())
	}
}

// LeadStatusHistoryClient is a client for the LeadStatusHistory schema.
type LeadStatusHistoryClient struct {
	config
}

// NewLeadStatusHistoryClient returns a client for the LeadStatusHistory from the given config.
func NewLeadStatusHistoryClient(c config) *LeadStatusHistoryClient {
	return &LeadStatusHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `leadstatushistory.Hooks(f(g(h())))`.
func (c *LeadStatusHistoryClient) Use(hooks ...Hook) {
	c.hooks.LeadStatusHistory = append(c.hooks.LeadStatusHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `leadstatushistory.Intercept(f(g(h())))`.
func (c *LeadStatusHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.LeadStatusHistory = append(c.inters.LeadStatusHistory, interceptors...)
}

// Create returns a builder for creating a LeadStatusHistory entity.
func (c *LeadStatusHistoryClient) Create() *LeadStatusHistoryCreate {
	mutation := newLeadStatusHistoryMutation(c.config, OpCreate)
	return &LeadStatusHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LeadStatusHistory entities.
func (c *LeadStatusHistoryClient) CreateBulk(builders ...*LeadStatusHistoryCreate) *LeadStatusHistoryCreateBulk {
	return &LeadStatusHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LeadStatusHistoryClient) MapCreateBulk(slice any, setFunc func(*LeadStatusHistoryCreate, int)) *LeadStatusHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LeadStatusHistoryCreateBulk{err: fmt.Errorf("calling to LeadStatusHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LeadStatusHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LeadStatusHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LeadStatusHistory.
func (c *LeadStatusHistoryClient) Update() *LeadStatusHistoryUpdate {
	mutation := newLeadStatusHistoryMutation(c.config, OpUpdate)
	return &LeadStatusHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LeadStatusHistoryClient) UpdateOne(_m *LeadStatusHistory) *LeadStatusHistoryUpdateOne {
	mutation := newLeadStatusHistoryMutation(c.config, OpUpdateOne, withLeadStatusHistory(_m))
	return &LeadStatusHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LeadStatusHistoryClient) UpdateOneID(id int) *LeadStatusHistoryUpdateOne {
	mutation := newLeadStatusHistoryMutation(c.config, OpUpdateOne, withLeadStatusHistoryID(id))
	return &LeadStatusHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LeadStatusHistory.
func (c *LeadStatusHistoryClient) Delete() *LeadStatusHistoryDelete {
	mutation := newLeadStatusHistoryMutation(c.config, OpDelete)
	return &LeadStatusHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LeadStatusHistoryClient) DeleteOne(_m *LeadStatusHistory) *LeadStatusHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LeadStatusHistoryClient) DeleteOneID(id int) *LeadStatusHistoryDeleteOne {
	builder := c.Delete().Where(leadstatushistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LeadStatusHistoryDeleteOne{builder}
}

// Query returns a query builder for LeadStatusHistory.
func (c *LeadStatusHistoryClient) Query() *LeadStatusHistoryQuery {
	return &LeadStatusHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLeadStatusHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a LeadStatusHistory entity by its id.
func (c *LeadStatusHistoryClient) Get(ctx context.Context, id int) (*LeadStatusHistory, error) {
	return c.Query().Where(leadstatushistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LeadStatusHistoryClient) GetX(ctx context.Context, id int) *LeadStatusHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLead queries the lead edge of a LeadStatusHistory.
func (c *LeadStatusHistoryClient) QueryLead(_m *LeadStatusHistory) *LeadQuery {
	query := (&LeadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(leadstatushistory.Table, leadstatushistory.FieldID, id),
			sqlgraph.To(lead.Table, lead.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, leadstatushistory.LeadTable, leadstatushistory.LeadColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a LeadStatusHistory.
func (c *LeadStatusHistoryClient) QueryUser(_m *LeadStatusHistory) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(leadstatushistory.Table, leadstatushistory.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, leadstatushistory.UserTable, leadstatushistory.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LeadStatusHistoryClient) Hooks() []Hook {
	return c.hooks.LeadStatusHistory
}

// Interceptors returns the client interceptors.
func (c *LeadStatusHistoryClient) Interceptors() []Interceptor {
	return c.inters.LeadStatusHistory
}

func (c *LeadStatusHistoryClient) mutate(ctx context.Context, m *LeadStatusHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LeadStatusHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LeadStatusHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LeadStatusHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LeadStatusHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LeadStatusHistory mutation op: %q", m.Op())
	}
}

// MarketReportClient is a client for the MarketReport schema.
type MarketReportClient struct {
	config
}

// NewMarketReportClient returns a client for the MarketReport from the given config.
func NewMarketReportClient(c config) *MarketReportClient {
	return &MarketReportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `marketreport.Hooks(f(g(h())))`.
func (c *MarketReportClient) Use(hooks ...Hook) {
	c.hooks.MarketReport = append(c.hooks.MarketReport, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `marketreport.Intercept(f(g(h())))`.
func (c *MarketReportClient) Intercept(interceptors ...Interceptor) {
	c.inters.MarketReport = append(c.inters.MarketReport, interceptors...)
}

// Create returns a builder for creating a MarketReport entity.
func (c *MarketReportClient) Create() *MarketReportCreate {
	mutation := newMarketReportMutation(c.config, OpCreate)
	return &MarketReportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MarketReport entities.
func (c *MarketReportClient) CreateBulk(builders ...*MarketReportCreate) *MarketReportCreateBulk {
	return &MarketReportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MarketReportClient) MapCreateBulk(slice any, setFunc func(*MarketReportCreate, int)) *MarketReportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MarketReportCreateBulk{err: fmt.Errorf("calling to MarketReportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MarketReportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MarketReportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MarketReport.
func (c *MarketReportClient) Update() *MarketReportUpdate {
	mutation := newMarketReportMutation(c.config, OpUpdate)
	return &MarketReportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MarketReportClient) UpdateOne(_m *MarketReport) *MarketReportUpdateOne {
	mutation := newMarketReportMutation(c.config, OpUpdateOne, withMarketReport(_m))
	return &MarketReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MarketReportClient) UpdateOneID(id int) *MarketReportUpdateOne {
	mutation := newMarketReportMutation(c.config, OpUpdateOne, withMarketReportID(id))
	return &MarketReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MarketReport.
func (c *MarketReportClient) Delete() *MarketReportDelete {
	mutation := newMarketReportMutation(c.config, OpDelete)
	return &MarketReportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MarketReportClient) DeleteOne(_m *MarketReport) *MarketReportDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MarketReportClient) DeleteOneID(id int) *MarketReportDeleteOne {
	builder := c.Delete().Where(marketreport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MarketReportDeleteOne{builder}
}

// Query returns a query builder for MarketReport.
func (c *MarketReportClient) Query() *MarketReportQuery {
	return &MarketReportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMarketReport},
		inters: c.Interceptors(),
	}
}

// Get returns a MarketReport entity by its id.
func (c *MarketReportClient) Get(ctx context.Context, id int) (*MarketReport, error) {
	return c.Query().Where(marketreport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MarketReportClient) GetX(ctx context.Context, id int) *MarketReport {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a MarketReport.
func (c *MarketReportClient) QueryUser(_m *MarketReport) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(marketreport.Table, marketreport.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, marketreport.UserTable, marketreport.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MarketReportClient) Hooks() []Hook {
	return c.hooks.MarketReport
}

// Interceptors returns the client interceptors.
func (c *MarketReportClient) Interceptors() []Interceptor {
	return c.inters.MarketReport
}

func (c *MarketReportClient) mutate(ctx context.Context, m *MarketReportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MarketReportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MarketReportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MarketReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MarketReportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MarketReport mutation op: %q", m.Op())
	}
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organization.Intercept(f(g(h())))`.
func (c *OrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organization = append(c.inters.Organization, interceptors...)
}

// Create returns a builder for creating a Organization entity.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationClient) MapCreateBulk(slice any, setFunc func(*OrganizationCreate, int)) *OrganizationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationCreateBulk{err: fmt.Errorf("calling to OrganizationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(_m *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(_m))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id int) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationClient) DeleteOne(_m *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationClient) DeleteOneID(id int) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id int) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id int) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Organization.
func (c *OrganizationClient) QueryOwner(_m *Organization) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organization.OwnerTable, organization.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Organization.
func (c *OrganizationClient) QueryMembers(_m *Organization) *OrganizationMemberQuery {
	query := (&OrganizationMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organizationmember.Table, organizationmember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.MembersTable, organization.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExports queries the exports edge of a Organization.
func (c *OrganizationClient) QueryExports(_m *Organization) *ExportQuery {
	query := (&ExportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(export.Table, export.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ExportsTable, organization.ExportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	return c.hooks.Organization
}

// Interceptors returns the client interceptors.
func (c *OrganizationClient) Interceptors() []Interceptor {
	return c.inters.Organization
}

func (c *OrganizationClient) mutate(ctx context.Context, m *OrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Organization mutation op: %q", m.Op())
	}
}

// OrganizationMemberClient is a client for the OrganizationMember schema.
type OrganizationMemberClient struct {
	config
}

// NewOrganizationMemberClient returns a client for the OrganizationMember from the given config.
func NewOrganizationMemberClient(c config) *OrganizationMemberClient {
	return &OrganizationMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organizationmember.Hooks(f(g(h())))`.
func (c *OrganizationMemberClient) Use(hooks ...Hook) {
	c.hooks.OrganizationMember = append(c.hooks.OrganizationMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organizationmember.Intercept(f(g(h())))`.
func (c *OrganizationMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrganizationMember = append(c.inters.OrganizationMember, interceptors...)
}

// Create returns a builder for creating a OrganizationMember entity.
func (c *OrganizationMemberClient) Create() *OrganizationMemberCreate {
	mutation := newOrganizationMemberMutation(c.config, OpCreate)
	return &OrganizationMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrganizationMember entities.
func (c *OrganizationMemberClient) CreateBulk(builders ...*OrganizationMemberCreate) *OrganizationMemberCreateBulk {
	return &OrganizationMemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationMemberClient) MapCreateBulk(slice any, setFunc func(*OrganizationMemberCreate, int)) *OrganizationMemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationMemberCreateBulk{err: fmt.Errorf("calling to OrganizationMemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationMemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrganizationMember.
func (c *OrganizationMemberClient) Update() *OrganizationMemberUpdate {
	mutation := newOrganizationMemberMutation(c.config, OpUpdate)
	return &OrganizationMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationMemberClient) UpdateOne(_m *OrganizationMember) *OrganizationMemberUpdateOne {
	mutation := newOrganizationMemberMutation(c.config, OpUpdateOne, withOrganizationMember(_m))
	return &OrganizationMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationMemberClient) UpdateOneID(id int) *OrganizationMemberUpdateOne {
	mutation := newOrganizationMemberMutation(c.config, OpUpdateOne, withOrganizationMemberID(id))
	return &OrganizationMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrganizationMember.
func (c *OrganizationMemberClient) Delete() *OrganizationMemberDelete {
	mutation := newOrganizationMemberMutation(c.config, OpDelete)
	return &OrganizationMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationMemberClient) DeleteOne(_m *OrganizationMember) *OrganizationMemberDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationMemberClient) DeleteOneID(id int) *OrganizationMemberDeleteOne {
	builder := c.Delete().Where(organizationmember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationMemberDeleteOne{builder}
}

// Query returns a query builder for OrganizationMember.
func (c *OrganizationMemberClient) Query() *OrganizationMemberQuery {
	return &OrganizationMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganizationMember},
		inters: c.Interceptors(),
	}
}

// Get returns a OrganizationMember entity by its id.
func (c *OrganizationMemberClient) Get(ctx context.Context, id int) (*OrganizationMember, error) {
	return c.Query().Where(organizationmember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationMemberClient) GetX(ctx context.Context, id int) *OrganizationMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a OrganizationMember.
func (c *OrganizationMemberClient) QueryOrganization(_m *OrganizationMember) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationmember.Table, organizationmember.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organizationmember.OrganizationTable, organizationmember.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a OrganizationMember.
func (c *OrganizationMemberClient) QueryUser(_m *OrganizationMember) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organizationmember.Table, organizationmember.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organizationmember.UserTable, organizationmember.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationMemberClient) Hooks() []Hook {
	return c.hooks.OrganizationMember
}

// Interceptors returns the client interceptors.
func (c *OrganizationMemberClient) Interceptors() []Interceptor {
	return c.inters.OrganizationMember
}

func (c *OrganizationMemberClient) mutate(ctx context.Context, m *OrganizationMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrganizationMember mutation op: %q", m.Op())
	}
}

// ReferralClient is a client for the Referral schema.
type ReferralClient struct {
	config
}

// NewReferralClient returns a client for the Referral from the given config.
func NewReferralClient(c config) *ReferralClient {
	return &ReferralClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `referral.Hooks(f(g(h())))`.
func (c *ReferralClient) Use(hooks ...Hook) {
	c.hooks.Referral = append(c.hooks.Referral, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `referral.Intercept(f(g(h())))`.
func (c *ReferralClient) Intercept(interceptors ...Interceptor) {
	c.inters.Referral = append(c.inters.Referral, interceptors...)
}

// Create returns a builder for creating a Referral entity.
func (c *ReferralClient) Create() *ReferralCreate {
	mutation := newReferralMutation(c.config, OpCreate)
	return &ReferralCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Referral entities.
func (c *ReferralClient) CreateBulk(builders ...*ReferralCreate) *ReferralCreateBulk {
	return &ReferralCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReferralClient) MapCreateBulk(slice any, setFunc func(*ReferralCreate, int)) *ReferralCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReferralCreateBulk{err: fmt.Errorf("calling to ReferralClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReferralCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReferralCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Referral.
func (c *ReferralClient) Update() *ReferralUpdate {
	mutation := newReferralMutation(c.config, OpUpdate)
	return &ReferralUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReferralClient) UpdateOne(_m *Referral) *ReferralUpdateOne {
	mutation := newReferralMutation(c.config, OpUpdateOne, withReferral(_m))
	return &ReferralUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReferralClient) UpdateOneID(id int) *ReferralUpdateOne {
	mutation := newReferralMutation(c.config, OpUpdateOne, withReferralID(id))
	return &ReferralUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Referral.
func (c *ReferralClient) Delete() *ReferralDelete {
	mutation := newReferralMutation(c.config, OpDelete)
	return &ReferralDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReferralClient) DeleteOne(_m *Referral) *ReferralDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReferralClient) DeleteOneID(id int) *ReferralDeleteOne {
	builder := c.Delete().Where(referral.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReferralDeleteOne{builder}
}

// Query returns a query builder for Referral.
func (c *ReferralClient) Query() *ReferralQuery {
	return &ReferralQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReferral},
		inters: c.Interceptors(),
	}
}

// Get returns a Referral entity by its id.
func (c *ReferralClient) Get(ctx context.Context, id int) (*Referral, error) {
	return c.Query().Where(referral.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReferralClient) GetX(ctx context.Context, id int) *Referral {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReferrer queries the referrer edge of a Referral.
func (c *ReferralClient) QueryReferrer(_m *Referral) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(referral.Table, referral.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, referral.ReferrerTable, referral.ReferrerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReferred queries the referred edge of a Referral.
func (c *ReferralClient) QueryReferred(_m *Referral) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(referral.Table, referral.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, referral.ReferredTable, referral.ReferredColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReferralClient) Hooks() []Hook {
	return c.hooks.Referral
}

// Interceptors returns the client interceptors.
func (c *ReferralClient) Interceptors() []Interceptor {
	return c.inters.Referral
}

func (c *ReferralClient) mutate(ctx context.Context, m *ReferralMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReferralCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReferralUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReferralUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReferralDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Referral mutation op: %q", m.Op())
	}
}

// SMSCampaignClient is a client for the SMSCampaign schema.
type SMSCampaignClient struct {
	config
}

// NewSMSCampaignClient returns a client for the SMSCampaign from the given config.
func NewSMSCampaignClient(c config) *SMSCampaignClient {
	return &SMSCampaignClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `smscampaign.Hooks(f(g(h())))`.
func (c *SMSCampaignClient) Use(hooks ...Hook) {
	c.hooks.SMSCampaign = append(c.hooks.SMSCampaign, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `smscampaign.Intercept(f(g(h())))`.
func (c *SMSCampaignClient) Intercept(interceptors ...Interceptor) {
	c.inters.SMSCampaign = append(c.inters.SMSCampaign, interceptors...)
}

// Create returns a builder for creating a SMSCampaign entity.
func (c *SMSCampaignClient) Create() *SMSCampaignCreate {
	mutation := newSMSCampaignMutation(c.config, OpCreate)
	return &SMSCampaignCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SMSCampaign entities.
func (c *SMSCampaignClient) CreateBulk(builders ...*SMSCampaignCreate) *SMSCampaignCreateBulk {
	return &SMSCampaignCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SMSCampaignClient) MapCreateBulk(slice any, setFunc func(*SMSCampaignCreate, int)) *SMSCampaignCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SMSCampaignCreateBulk{err: fmt.Errorf("calling to SMSCampaignClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SMSCampaignCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SMSCampaignCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SMSCampaign.
func (c *SMSCampaignClient) Update() *SMSCampaignUpdate {
	mutation := newSMSCampaignMutation(c.config, OpUpdate)
	return &SMSCampaignUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SMSCampaignClient) UpdateOne(_m *SMSCampaign) *SMSCampaignUpdateOne {
	mutation := newSMSCampaignMutation(c.config, OpUpdateOne, withSMSCampaign(_m))
	return &SMSCampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SMSCampaignClient) UpdateOneID(id int) *SMSCampaignUpdateOne {
	mutation := newSMSCampaignMutation(c.config, OpUpdateOne, withSMSCampaignID(id))
	return &SMSCampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SMSCampaign.
func (c *SMSCampaignClient) Delete() *SMSCampaignDelete {
	mutation := newSMSCampaignMutation(c.config, OpDelete)
	return &SMSCampaignDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SMSCampaignClient) DeleteOne(_m *SMSCampaign) *SMSCampaignDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SMSCampaignClient) DeleteOneID(id int) *SMSCampaignDeleteOne {
	builder := c.Delete().Where(smscampaign.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SMSCampaignDeleteOne{builder}
}

// Query returns a query builder for SMSCampaign.
func (c *SMSCampaignClient) Query() *SMSCampaignQuery {
	return &SMSCampaignQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSMSCampaign},
		inters: c.Interceptors(),
	}
}

// Get returns a SMSCampaign entity by its id.
func (c *SMSCampaignClient) Get(ctx context.Context, id int) (*SMSCampaign, error) {
	return c.Query().Where(smscampaign.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SMSCampaignClient) GetX(ctx context.Context, id int) *SMSCampaign {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a SMSCampaign.
func (c *SMSCampaignClient) QueryUser(_m *SMSCampaign) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(smscampaign.Table, smscampaign.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, smscampaign.UserTable, smscampaign.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a SMSCampaign.
func (c *SMSCampaignClient) QueryMessages(_m *SMSCampaign) *SMSMessageQuery {
	query := (&SMSMessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(smscampaign.Table, smscampaign.FieldID, id),
			sqlgraph.To(smsmessage.Table, smsmessage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, smscampaign.MessagesTable, smscampaign.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SMSCampaignClient) Hooks() []Hook {
	return c.hooks.SMSCampaign
}

// Interceptors returns the client interceptors.
func (c *SMSCampaignClient) Interceptors() []Interceptor {
	return c.inters.SMSCampaign
}

func (c *SMSCampaignClient) mutate(ctx context.Context, m *SMSCampaignMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SMSCampaignCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SMSCampaignUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SMSCampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SMSCampaignDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SMSCampaign mutation op: %q", m.Op())
	}
}

// SMSMessageClient is a client for the SMSMessage schema.
type SMSMessageClient struct {
	config
}

// NewSMSMessageClient returns a client for the SMSMessage from the given config.
func NewSMSMessageClient(c config) *SMSMessageClient {
	return &SMSMessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `smsmessage.Hooks(f(g(h())))`.
func (c *SMSMessageClient) Use(hooks ...Hook) {
	c.hooks.SMSMessage = append(c.hooks.SMSMessage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `smsmessage.Intercept(f(g(h())))`.
func (c *SMSMessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.SMSMessage = append(c.inters.SMSMessage, interceptors...)
}

// Create returns a builder for creating a SMSMessage entity.
func (c *SMSMessageClient) Create() *SMSMessageCreate {
	mutation := newSMSMessageMutation(c.config, OpCreate)
	return &SMSMessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SMSMessage entities.
func (c *SMSMessageClient) CreateBulk(builders ...*SMSMessageCreate) *SMSMessageCreateBulk {
	return &SMSMessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SMSMessageClient) MapCreateBulk(slice any, setFunc func(*SMSMessageCreate, int)) *SMSMessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SMSMessageCreateBulk{err: fmt.Errorf("calling to SMSMessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SMSMessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SMSMessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SMSMessage.
func (c *SMSMessageClient) Update() *SMSMessageUpdate {
	mutation := newSMSMessageMutation(c.config, OpUpdate)
	return &SMSMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SMSMessageClient) UpdateOne(_m *SMSMessage) *SMSMessageUpdateOne {
	mutation := newSMSMessageMutation(c.config, OpUpdateOne, withSMSMessage(_m))
	return &SMSMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SMSMessageClient) UpdateOneID(id int) *SMSMessageUpdateOne {
	mutation := newSMSMessageMutation(c.config, OpUpdateOne, withSMSMessageID(id))
	return &SMSMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SMSMessage.
func (c *SMSMessageClient) Delete() *SMSMessageDelete {
	mutation := newSMSMessageMutation(c.config, OpDelete)
	return &SMSMessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SMSMessageClient) DeleteOne(_m *SMSMessage) *SMSMessageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SMSMessageClient) DeleteOneID(id int) *SMSMessageDeleteOne {
	builder := c.Delete().Where(smsmessage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SMSMessageDeleteOne{builder}
}

// Query returns a query builder for SMSMessage.
func (c *SMSMessageClient) Query() *SMSMessageQuery {
	return &SMSMessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSMSMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a SMSMessage entity by its id.
func (c *SMSMessageClient) Get(ctx context.Context, id int) (*SMSMessage, error) {
	return c.Query().Where(smsmessage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SMSMessageClient) GetX(ctx context.Context, id int) *SMSMessage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCampaign queries the campaign edge of a SMSMessage.
func (c *SMSMessageClient) QueryCampaign(_m *SMSMessage) *SMSCampaignQuery {
	query := (&SMSCampaignClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(smsmessage.Table, smsmessage.FieldID, id),
			sqlgraph.To(smscampaign.Table, smscampaign.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, smsmessage.CampaignTable, smsmessage.CampaignColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLead queries the lead edge of a SMSMessage.
func (c *SMSMessageClient) QueryLead(_m *SMSMessage) *LeadQuery {
	query := (&LeadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(smsmessage.Table, smsmessage.FieldID, id),
			sqlgraph.To(lead.Table, lead.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, smsmessage.LeadTable, smsmessage.LeadColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SMSMessageClient) Hooks() []Hook {
	return c.hooks.SMSMessage
}

// Interceptors returns the client interceptors.
func (c *SMSMessageClient) Interceptors() []Interceptor {
	return c.inters.SMSMessage
}

func (c *SMSMessageClient) mutate(ctx context.Context, m *SMSMessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SMSMessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SMSMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SMSMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SMSMessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SMSMessage mutation op: %q", m.Op())
	}
}

// SavedSearchClient is a client for the SavedSearch schema.
type SavedSearchClient struct {
	config
}

// NewSavedSearchClient returns a client for the SavedSearch from the given config.
func NewSavedSearchClient(c config) *SavedSearchClient {
	return &SavedSearchClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `savedsearch.Hooks(f(g(h())))`.
func (c *SavedSearchClient) Use(hooks ...Hook) {
	c.hooks.SavedSearch = append(c.hooks.SavedSearch, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `savedsearch.Intercept(f(g(h())))`.
func (c *SavedSearchClient) Intercept(interceptors ...Interceptor) {
	c.inters.SavedSearch = append(c.inters.SavedSearch, interceptors...)
}

// Create returns a builder for creating a SavedSearch entity.
func (c *SavedSearchClient) Create() *SavedSearchCreate {
	mutation := newSavedSearchMutation(c.config, OpCreate)
	return &SavedSearchCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SavedSearch entities.
func (c *SavedSearchClient) CreateBulk(builders ...*SavedSearchCreate) *SavedSearchCreateBulk {
	return &SavedSearchCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SavedSearchClient) MapCreateBulk(slice any, setFunc func(*SavedSearchCreate, int)) *SavedSearchCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SavedSearchCreateBulk{err: fmt.Errorf("calling to SavedSearchClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SavedSearchCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SavedSearchCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SavedSearch.
func (c *SavedSearchClient) Update() *SavedSearchUpdate {
	mutation := newSavedSearchMutation(c.config, OpUpdate)
	return &SavedSearchUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SavedSearchClient) UpdateOne(_m *SavedSearch) *SavedSearchUpdateOne {
	mutation := newSavedSearchMutation(c.config, OpUpdateOne, withSavedSearch(_m))
	return &SavedSearchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SavedSearchClient) UpdateOneID(id int) *SavedSearchUpdateOne {
	mutation := newSavedSearchMutation(c.config, OpUpdateOne, withSavedSearchID(id))
	return &SavedSearchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SavedSearch.
func (c *SavedSearchClient) Delete() *SavedSearchDelete {
	mutation := newSavedSearchMutation(c.config, OpDelete)
	return &SavedSearchDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SavedSearchClient) DeleteOne(_m *SavedSearch) *SavedSearchDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SavedSearchClient) DeleteOneID(id int) *SavedSearchDeleteOne {
	builder := c.Delete().Where(savedsearch.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SavedSearchDeleteOne{builder}
}

// Query returns a query builder for SavedSearch.
func (c *SavedSearchClient) Query() *SavedSearchQuery {
	return &SavedSearchQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSavedSearch},
		inters: c.Interceptors(),
	}
}

// Get returns a SavedSearch entity by its id.
func (c *SavedSearchClient) Get(ctx context.Context, id int) (*SavedSearch, error) {
	return c.Query().Where(savedsearch.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SavedSearchClient) GetX(ctx context.Context, id int) *SavedSearch {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a SavedSearch.
func (c *SavedSearchClient) QueryUser(_m *SavedSearch) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(savedsearch.Table, savedsearch.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, savedsearch.UserTable, savedsearch.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SavedSearchClient) Hooks() []Hook {
	return c.hooks.SavedSearch
}

// Interceptors returns the client interceptors.
func (c *SavedSearchClient) Interceptors() []Interceptor {
	return c.inters.SavedSearch
}

func (c *SavedSearchClient) mutate(ctx context.Context, m *SavedSearchMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SavedSearchCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SavedSearchUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SavedSearchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SavedSearchDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SavedSearch mutation op: %q", m.Op())
	}
}

// SubscriptionClient is a client for the Subscription schema.
type SubscriptionClient struct {
	config
}

// NewSubscriptionClient returns a client for the Subscription from the given config.
func NewSubscriptionClient(c config) *SubscriptionClient {
	return &SubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscription.Hooks(f(g(h())))`.
func (c *SubscriptionClient) Use(hooks ...Hook) {
	c.hooks.Subscription = append(c.hooks.Subscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscription.Intercept(f(g(h())))`.
func (c *SubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subscription = append(c.inters.Subscription, interceptors...)
}

// Create returns a builder for creating a Subscription entity.
func (c *SubscriptionClient) Create() *SubscriptionCreate {
	mutation := newSubscriptionMutation(c.config, OpCreate)
	return &SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subscription entities.
func (c *SubscriptionClient) CreateBulk(builders ...*SubscriptionCreate) *SubscriptionCreateBulk {
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriptionClient) MapCreateBulk(slice any, setFunc func(*SubscriptionCreate, int)) *SubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriptionCreateBulk{err: fmt.Errorf("calling to SubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subscription.
func (c *SubscriptionClient) Update() *SubscriptionUpdate {
	mutation := newSubscriptionMutation(c.config, OpUpdate)
	return &SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriptionClient) UpdateOne(_m *Subscription) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscription(_m))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriptionClient) UpdateOneID(id int) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscriptionID(id))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subscription.
func (c *SubscriptionClient) Delete() *SubscriptionDelete {
	mutation := newSubscriptionMutation(c.config, OpDelete)
	return &SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriptionClient) DeleteOne(_m *Subscription) *SubscriptionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriptionClient) DeleteOneID(id int) *SubscriptionDeleteOne {
	builder := c.Delete().Where(subscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriptionDeleteOne{builder}
}

// Query returns a query builder for Subscription.
func (c *SubscriptionClient) Query() *SubscriptionQuery {
	return &SubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a Subscription entity by its id.
func (c *SubscriptionClient) Get(ctx context.Context, id int) (*Subscription, error) {
	return c.Query().Where(subscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriptionClient) GetX(ctx context.Context, id int) *Subscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Subscription.
func (c *SubscriptionClient) QueryUser(_m *Subscription) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscription.UserTable, subscription.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubscriptionClient) Hooks() []Hook {
	return c.hooks.Subscription
}

// Interceptors returns the client interceptors.
func (c *SubscriptionClient) Interceptors() []Interceptor {
	return c.inters.Subscription
}

func (c *SubscriptionClient) mutate(ctx context.Context, m *SubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Subscription mutation op: %q", m.Op())
	}
}

// TerritoryClient is a client for the Territory schema.
type TerritoryClient struct {
	config
}

// NewTerritoryClient returns a client for the Territory from the given config.
func NewTerritoryClient(c config) *TerritoryClient {
	return &TerritoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `territory.Hooks(f(g(h())))`.
func (c *TerritoryClient) Use(hooks ...Hook) {
	c.hooks.Territory = append(c.hooks.Territory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `territory.Intercept(f(g(h())))`.
func (c *TerritoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Territory = append(c.inters.Territory, interceptors...)
}

// Create returns a builder for creating a Territory entity.
func (c *TerritoryClient) Create() *TerritoryCreate {
	mutation := newTerritoryMutation(c.config, OpCreate)
	return &TerritoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Territory entities.
func (c *TerritoryClient) CreateBulk(builders ...*TerritoryCreate) *TerritoryCreateBulk {
	return &TerritoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TerritoryClient) MapCreateBulk(slice any, setFunc func(*TerritoryCreate, int)) *TerritoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TerritoryCreateBulk{err: fmt.Errorf("calling to TerritoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TerritoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TerritoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Territory.
func (c *TerritoryClient) Update() *TerritoryUpdate {
	mutation := newTerritoryMutation(c.config, OpUpdate)
	return &TerritoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TerritoryClient) UpdateOne(_m *Territory) *TerritoryUpdateOne {
	mutation := newTerritoryMutation(c.config, OpUpdateOne, withTerritory(_m))
	return &TerritoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TerritoryClient) UpdateOneID(id int) *TerritoryUpdateOne {
	mutation := newTerritoryMutation(c.config, OpUpdateOne, withTerritoryID(id))
	return &TerritoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Territory.
func (c *TerritoryClient) Delete() *TerritoryDelete {
	mutation := newTerritoryMutation(c.config, OpDelete)
	return &TerritoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TerritoryClient) DeleteOne(_m *Territory) *TerritoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TerritoryClient) DeleteOneID(id int) *TerritoryDeleteOne {
	builder := c.Delete().Where(territory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TerritoryDeleteOne{builder}
}

// Query returns a query builder for Territory.
func (c *TerritoryClient) Query() *TerritoryQuery {
	return &TerritoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTerritory},
		inters: c.Interceptors(),
	}
}

// Get returns a Territory entity by its id.
func (c *TerritoryClient) Get(ctx context.Context, id int) (*Territory, error) {
	return c.Query().Where(territory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TerritoryClient) GetX(ctx context.Context, id int) *Territory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCreatedBy queries the created_by edge of a Territory.
func (c *TerritoryClient) QueryCreatedBy(_m *Territory) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(territory.Table, territory.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, territory.CreatedByTable, territory.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Territory.
func (c *TerritoryClient) QueryMembers(_m *Territory) *TerritoryMemberQuery {
	query := (&TerritoryMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(territory.Table, territory.FieldID, id),
			sqlgraph.To(territorymember.Table, territorymember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, territory.MembersTable, territory.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLeads queries the leads edge of a Territory.
func (c *TerritoryClient) QueryLeads(_m *Territory) *LeadQuery {
	query := (&LeadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(territory.Table, territory.FieldID, id),
			sqlgraph.To(lead.Table, lead.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, territory.LeadsTable, territory.LeadsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TerritoryClient) Hooks() []Hook {
	return c.hooks.Territory
}

// Interceptors returns the client interceptors.
func (c *TerritoryClient) Interceptors() []Interceptor {
	return c.inters.Territory
}

func (c *TerritoryClient) mutate(ctx context.Context, m *TerritoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TerritoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TerritoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TerritoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TerritoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Territory mutation op: %q", m.Op())
	}
}

// TerritoryMemberClient is a client for the TerritoryMember schema.
type TerritoryMemberClient struct {
	config
}

// NewTerritoryMemberClient returns a client for the TerritoryMember from the given config.
func NewTerritoryMemberClient(c config) *TerritoryMemberClient {
	return &TerritoryMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `territorymember.Hooks(f(g(h())))`.
func (c *TerritoryMemberClient) Use(hooks ...Hook) {
	c.hooks.TerritoryMember = append(c.hooks.TerritoryMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `territorymember.Intercept(f(g(h())))`.
func (c *TerritoryMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.TerritoryMember = append(c.inters.TerritoryMember, interceptors...)
}

// Create returns a builder for creating a TerritoryMember entity.
func (c *TerritoryMemberClient) Create() *TerritoryMemberCreate {
	mutation := newTerritoryMemberMutation(c.config, OpCreate)
	return &TerritoryMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TerritoryMember entities.
func (c *TerritoryMemberClient) CreateBulk(builders ...*TerritoryMemberCreate) *TerritoryMemberCreateBulk {
	return &TerritoryMemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TerritoryMemberClient) MapCreateBulk(slice any, setFunc func(*TerritoryMemberCreate, int)) *TerritoryMemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TerritoryMemberCreateBulk{err: fmt.Errorf("calling to TerritoryMemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TerritoryMemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TerritoryMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TerritoryMember.
func (c *TerritoryMemberClient) Update() *TerritoryMemberUpdate {
	mutation := newTerritoryMemberMutation(c.config, OpUpdate)
	return &TerritoryMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TerritoryMemberClient) UpdateOne(_m *TerritoryMember) *TerritoryMemberUpdateOne {
	mutation := newTerritoryMemberMutation(c.config, OpUpdateOne, withTerritoryMember(_m))
	return &TerritoryMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TerritoryMemberClient) UpdateOneID(id int) *TerritoryMemberUpdateOne {
	mutation := newTerritoryMemberMutation(c.config, OpUpdateOne, withTerritoryMemberID(id))
	return &TerritoryMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TerritoryMember.
func (c *TerritoryMemberClient) Delete() *TerritoryMemberDelete {
	mutation := newTerritoryMemberMutation(c.config, OpDelete)
	return &TerritoryMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TerritoryMemberClient) DeleteOne(_m *TerritoryMember) *TerritoryMemberDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TerritoryMemberClient) DeleteOneID(id int) *TerritoryMemberDeleteOne {
	builder := c.Delete().Where(territorymember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TerritoryMemberDeleteOne{builder}
}

// Query returns a query builder for TerritoryMember.
func (c *TerritoryMemberClient) Query() *TerritoryMemberQuery {
	return &TerritoryMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTerritoryMember},
		inters: c.Interceptors(),
	}
}

// Get returns a TerritoryMember entity by its id.
func (c *TerritoryMemberClient) Get(ctx context.Context, id int) (*TerritoryMember, error) {
	return c.Query().Where(territorymember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TerritoryMemberClient) GetX(ctx context.Context, id int) *TerritoryMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTerritory queries the territory edge of a TerritoryMember.
func (c *TerritoryMemberClient) QueryTerritory(_m *TerritoryMember) *TerritoryQuery {
	query := (&TerritoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(territorymember.Table, territorymember.FieldID, id),
			sqlgraph.To(territory.Table, territory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, territorymember.TerritoryTable, territorymember.TerritoryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a TerritoryMember.
func (c *TerritoryMemberClient) QueryUser(_m *TerritoryMember) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(territorymember.Table, territorymember.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, territorymember.UserTable, territorymember.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAddedBy queries the added_by edge of a TerritoryMember.
func (c *TerritoryMemberClient) QueryAddedBy(_m *TerritoryMember) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(territorymember.Table, territorymember.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, territorymember.AddedByTable, territorymember.AddedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TerritoryMemberClient) Hooks() []Hook {
	return c.hooks.TerritoryMember
}

// Interceptors returns the client interceptors.
func (c *TerritoryMemberClient) Interceptors() []Interceptor {
	return c.inters.TerritoryMember
}

func (c *TerritoryMemberClient) mutate(ctx context.Context, m *TerritoryMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TerritoryMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TerritoryMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TerritoryMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TerritoryMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TerritoryMember mutation op: %q", m.Op())
	}
}

// UsageLogClient is a client for the UsageLog schema.
type UsageLogClient struct {
	config
}

// NewUsageLogClient returns a client for the UsageLog from the given config.
func NewUsageLogClient(c config) *UsageLogClient {
	return &UsageLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usagelog.Hooks(f(g(h())))`.
func (c *UsageLogClient) Use(hooks ...Hook) {
	c.hooks.UsageLog = append(c.hooks.UsageLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usagelog.Intercept(f(g(h())))`.
func (c *UsageLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.UsageLog = append(c.inters.UsageLog, interceptors...)
}

// Create returns a builder for creating a UsageLog entity.
func (c *UsageLogClient) Create() *UsageLogCreate {
	mutation := newUsageLogMutation(c.config, OpCreate)
	return &UsageLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UsageLog entities.
func (c *UsageLogClient) CreateBulk(builders ...*UsageLogCreate) *UsageLogCreateBulk {
	return &UsageLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UsageLogClient) MapCreateBulk(slice any, setFunc func(*UsageLogCreate, int)) *UsageLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UsageLogCreateBulk{err: fmt.Errorf("calling to UsageLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UsageLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UsageLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UsageLog.
func (c *UsageLogClient) Update() *UsageLogUpdate {
	mutation := newUsageLogMutation(c.config, OpUpdate)
	return &UsageLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UsageLogClient) UpdateOne(_m *UsageLog) *UsageLogUpdateOne {
	mutation := newUsageLogMutation(c.config, OpUpdateOne, withUsageLog(_m))
	return &UsageLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UsageLogClient) UpdateOneID(id int) *UsageLogUpdateOne {
	mutation := newUsageLogMutation(c.config, OpUpdateOne, withUsageLogID(id))
	return &UsageLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UsageLog.
func (c *UsageLogClient) Delete() *UsageLogDelete {
	mutation := newUsageLogMutation(c.config, OpDelete)
	return &UsageLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UsageLogClient) DeleteOne(_m *UsageLog) *UsageLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UsageLogClient) DeleteOneID(id int) *UsageLogDeleteOne {
	builder := c.Delete().Where(usagelog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UsageLogDeleteOne{builder}
}

// Query returns a query builder for UsageLog.
func (c *UsageLogClient) Query() *UsageLogQuery {
	return &UsageLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUsageLog},
		inters: c.Interceptors(),
	}
}

// Get returns a UsageLog entity by its id.
func (c *UsageLogClient) Get(ctx context.Context, id int) (*UsageLog, error) {
	return c.Query().Where(usagelog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UsageLogClient) GetX(ctx context.Context, id int) *UsageLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UsageLog.
func (c *UsageLogClient) QueryUser(_m *UsageLog) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usagelog.Table, usagelog.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usagelog.UserTable, usagelog.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UsageLogClient) Hooks() []Hook {
	return c.hooks.UsageLog
}

// Interceptors returns the client interceptors.
func (c *UsageLogClient) Interceptors() []Interceptor {
	return c.inters.UsageLog
}

func (c *UsageLogClient) mutate(ctx context.Context, m *UsageLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UsageLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UsageLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UsageLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UsageLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UsageLog mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubscriptions queries the subscriptions edge of a User.
func (c *UserClient) QuerySubscriptions(_m *User) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SubscriptionsTable, user.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExports queries the exports edge of a User.
func (c *UserClient) QueryExports(_m *User) *ExportQuery {
	query := (&ExportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(export.Table, export.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ExportsTable, user.ExportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAPIKeys queries the api_keys edge of a User.
func (c *UserClient) QueryAPIKeys(_m *User) *APIKeyQuery {
	query := (&APIKeyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(apikey.Table, apikey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.APIKeysTable, user.APIKeysColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuditLogs queries the audit_logs edge of a User.
func (c *UserClient) QueryAuditLogs(_m *User) *AuditLogQuery {
	query := (&AuditLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(auditlog.Table, auditlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AuditLogsTable, user.AuditLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsageLogs queries the usage_logs edge of a User.
func (c *UserClient) QueryUsageLogs(_m *User) *UsageLogQuery {
	query := (&UsageLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usagelog.Table, usagelog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UsageLogsTable, user.UsageLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwnedOrganizations queries the owned_organizations edge of a User.
func (c *UserClient) QueryOwnedOrganizations(_m *User) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OwnedOrganizationsTable, user.OwnedOrganizationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizationMemberships queries the organization_memberships edge of a User.
func (c *UserClient) QueryOrganizationMemberships(_m *User) *OrganizationMemberQuery {
	query := (&OrganizationMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(organizationmember.Table, organizationmember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OrganizationMembershipsTable, user.OrganizationMembershipsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySavedSearches queries the saved_searches edge of a User.
func (c *UserClient) QuerySavedSearches(_m *User) *SavedSearchQuery {
	query := (&SavedSearchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(savedsearch.Table, savedsearch.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SavedSearchesTable, user.SavedSearchesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWebhooks queries the webhooks edge of a User.
func (c *UserClient) QueryWebhooks(_m *User) *WebhookQuery {
	query := (&WebhookClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(webhook.Table, webhook.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.WebhooksTable, user.WebhooksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLeadNotes queries the lead_notes edge of a User.
func (c *UserClient) QueryLeadNotes(_m *User) *LeadNoteQuery {
	query := (&LeadNoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(leadnote.Table, leadnote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LeadNotesTable, user.LeadNotesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLeadStatusChanges queries the lead_status_changes edge of a User.
func (c *UserClient) QueryLeadStatusChanges(_m *User) *LeadStatusHistoryQuery {
	query := (&LeadStatusHistoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(leadstatushistory.Table, leadstatushistory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LeadStatusChangesTable, user.LeadStatusChangesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedLeads queries the assigned_leads edge of a User.
func (c *UserClient) QueryAssignedLeads(_m *User) *LeadAssignmentQuery {
	query := (&LeadAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(leadassignment.Table, leadassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AssignedLeadsTable, user.AssignedLeadsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLeadAssignmentsMade queries the lead_assignments_made edge of a User.
func (c *UserClient) QueryLeadAssignmentsMade(_m *User) *LeadAssignmentQuery {
	query := (&LeadAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(leadassignment.Table, leadassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LeadAssignmentsMadeTable, user.LeadAssignmentsMadeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmailSequencesCreated queries the email_sequences_created edge of a User.
func (c *UserClient) QueryEmailSequencesCreated(_m *User) *EmailSequenceQuery {
	query := (&EmailSequenceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(emailsequence.Table, emailsequence.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.EmailSequencesCreatedTable, user.EmailSequencesCreatedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmailSequenceEnrollmentsMade queries the email_sequence_enrollments_made edge of a User.
func (c *UserClient) QueryEmailSequenceEnrollmentsMade(_m *User) *EmailSequenceEnrollmentQuery {
	query := (&EmailSequenceEnrollmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(emailsequenceenrollment.Table, emailsequenceenrollment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.EmailSequenceEnrollmentsMadeTable, user.EmailSequenceEnrollmentsMadeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTerritoriesCreated queries the territories_created edge of a User.
func (c *UserClient) QueryTerritoriesCreated(_m *User) *TerritoryQuery {
	query := (&TerritoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(territory.Table, territory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TerritoriesCreatedTable, user.TerritoriesCreatedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTerritoryMemberships queries the territory_memberships edge of a User.
func (c *UserClient) QueryTerritoryMemberships(_m *User) *TerritoryMemberQuery {
	query := (&TerritoryMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(territorymember.Table, territorymember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TerritoryMembershipsTable, user.TerritoryMembershipsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTerritoryMembersAdded queries the territory_members_added edge of a User.
func (c *UserClient) QueryTerritoryMembersAdded(_m *User) *TerritoryMemberQuery {
	query := (&TerritoryMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(territorymember.Table, territorymember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TerritoryMembersAddedTable, user.TerritoryMembersAddedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySentReferrals queries the sent_referrals edge of a User.
func (c *UserClient) QuerySentReferrals(_m *User) *ReferralQuery {
	query := (&ReferralClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(referral.Table, referral.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SentReferralsTable, user.SentReferralsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReceivedReferrals queries the received_referrals edge of a User.
func (c *UserClient) QueryReceivedReferrals(_m *User) *ReferralQuery {
	query := (&ReferralClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(referral.Table, referral.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReceivedReferralsTable, user.ReceivedReferralsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExperimentAssignments queries the experiment_assignments edge of a User.
func (c *UserClient) QueryExperimentAssignments(_m *User) *ExperimentAssignmentQuery {
	query := (&ExperimentAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(experimentassignment.Table, experimentassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ExperimentAssignmentsTable, user.ExperimentAssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAffiliate queries the affiliate edge of a User.
func (c *UserClient) QueryAffiliate(_m *User) *AffiliateQuery {
	query := (&AffiliateClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(affiliate.Table, affiliate.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.AffiliateTable, user.AffiliateColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAffiliateConversions queries the affiliate_conversions edge of a User.
func (c *UserClient) QueryAffiliateConversions(_m *User) *AffiliateConversionQuery {
	query := (&AffiliateConversionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(affiliateconversion.Table, affiliateconversion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AffiliateConversionsTable, user.AffiliateConversionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySmsCampaigns queries the sms_campaigns edge of a User.
func (c *UserClient) QuerySmsCampaigns(_m *User) *SMSCampaignQuery {
	query := (&SMSCampaignClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(smscampaign.Table, smscampaign.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SmsCampaignsTable, user.SmsCampaignsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCallLogs queries the call_logs edge of a User.
func (c *UserClient) QueryCallLogs(_m *User) *CallLogQuery {
	query := (&CallLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(calllog.Table, calllog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CallLogsTable, user.CallLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompetitorProfiles queries the competitor_profiles edge of a User.
func (c *UserClient) QueryCompetitorProfiles(_m *User) *CompetitorProfileQuery {
	query := (&CompetitorProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(competitorprofile.Table, competitorprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CompetitorProfilesTable, user.CompetitorProfilesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLeadRecommendations queries the lead_recommendations edge of a User.
func (c *UserClient) QueryLeadRecommendations(_m *User) *LeadRecommendationQuery {
	query := (&LeadRecommendationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(leadrecommendation.Table, leadrecommendation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.LeadRecommendationsTable, user.LeadRecommendationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBehaviors queries the behaviors edge of a User.
func (c *UserClient) QueryBehaviors(_m *User) *UserBehaviorQuery {
	query := (&UserBehaviorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userbehavior.Table, userbehavior.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BehaviorsTable, user.BehaviorsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMarketReports queries the market_reports edge of a User.
func (c *UserClient) QueryMarketReports(_m *User) *MarketReportQuery {
	query := (&MarketReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(marketreport.Table, marketreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MarketReportsTable, user.MarketReportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEmailCampaigns queries the email_campaigns edge of a User.
func (c *UserClient) QueryEmailCampaigns(_m *User) *EmailCampaignQuery {
	query := (&EmailCampaignClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(emailcampaign.Table, emailcampaign.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.EmailCampaignsTable, user.EmailCampaignsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCrmIntegrations queries the crm_integrations edge of a User.
func (c *UserClient) QueryCrmIntegrations(_m *User) *CRMIntegrationQuery {
	query := (&CRMIntegrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(crmintegration.Table, crmintegration.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CrmIntegrationsTable, user.CrmIntegrationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserBehaviorClient is a client for the UserBehavior schema.
type UserBehaviorClient struct {
	config
}

// NewUserBehaviorClient returns a client for the UserBehavior from the given config.
func NewUserBehaviorClient(c config) *UserBehaviorClient {
	return &UserBehaviorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userbehavior.Hooks(f(g(h())))`.
func (c *UserBehaviorClient) Use(hooks ...Hook) {
	c.hooks.UserBehavior = append(c.hooks.UserBehavior, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userbehavior.Intercept(f(g(h())))`.
func (c *UserBehaviorClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserBehavior = append(c.inters.UserBehavior, interceptors...)
}

// Create returns a builder for creating a UserBehavior entity.
func (c *UserBehaviorClient) Create() *UserBehaviorCreate {
	mutation := newUserBehaviorMutation(c.config, OpCreate)
	return &UserBehaviorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserBehavior entities.
func (c *UserBehaviorClient) CreateBulk(builders ...*UserBehaviorCreate) *UserBehaviorCreateBulk {
	return &UserBehaviorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserBehaviorClient) MapCreateBulk(slice any, setFunc func(*UserBehaviorCreate, int)) *UserBehaviorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserBehaviorCreateBulk{err: fmt.Errorf("calling to UserBehaviorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserBehaviorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserBehaviorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserBehavior.
func (c *UserBehaviorClient) Update() *UserBehaviorUpdate {
	mutation := newUserBehaviorMutation(c.config, OpUpdate)
	return &UserBehaviorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserBehaviorClient) UpdateOne(_m *UserBehavior) *UserBehaviorUpdateOne {
	mutation := newUserBehaviorMutation(c.config, OpUpdateOne, withUserBehavior(_m))
	return &UserBehaviorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserBehaviorClient) UpdateOneID(id int) *UserBehaviorUpdateOne {
	mutation := newUserBehaviorMutation(c.config, OpUpdateOne, withUserBehaviorID(id))
	return &UserBehaviorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserBehavior.
func (c *UserBehaviorClient) Delete() *UserBehaviorDelete {
	mutation := newUserBehaviorMutation(c.config, OpDelete)
	return &UserBehaviorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserBehaviorClient) DeleteOne(_m *UserBehavior) *UserBehaviorDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserBehaviorClient) DeleteOneID(id int) *UserBehaviorDeleteOne {
	builder := c.Delete().Where(userbehavior.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserBehaviorDeleteOne{builder}
}

// Query returns a query builder for UserBehavior.
func (c *UserBehaviorClient) Query() *UserBehaviorQuery {
	return &UserBehaviorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserBehavior},
		inters: c.Interceptors(),
	}
}

// Get returns a UserBehavior entity by its id.
func (c *UserBehaviorClient) Get(ctx context.Context, id int) (*UserBehavior, error) {
	return c.Query().Where(userbehavior.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserBehaviorClient) GetX(ctx context.Context, id int) *UserBehavior {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserBehavior.
func (c *UserBehaviorClient) QueryUser(_m *UserBehavior) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userbehavior.Table, userbehavior.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userbehavior.UserTable, userbehavior.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserBehaviorClient) Hooks() []Hook {
	return c.hooks.UserBehavior
}

// Interceptors returns the client interceptors.
func (c *UserBehaviorClient) Interceptors() []Interceptor {
	return c.inters.UserBehavior
}

func (c *UserBehaviorClient) mutate(ctx context.Context, m *UserBehaviorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserBehaviorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserBehaviorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserBehaviorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserBehaviorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserBehavior mutation op: %q", m.Op())
	}
}

// WebhookClient is a client for the Webhook schema.
type WebhookClient struct {
	config
}

// NewWebhookClient returns a client for the Webhook from the given config.
func NewWebhookClient(c config) *WebhookClient {
	return &WebhookClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `webhook.Hooks(f(g(h())))`.
func (c *WebhookClient) Use(hooks ...Hook) {
	c.hooks.Webhook = append(c.hooks.Webhook, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `webhook.Intercept(f(g(h())))`.
func (c *WebhookClient) Intercept(interceptors ...Interceptor) {
	c.inters.Webhook = append(c.inters.Webhook, interceptors...)
}

// Create returns a builder for creating a Webhook entity.
func (c *WebhookClient) Create() *WebhookCreate {
	mutation := newWebhookMutation(c.config, OpCreate)
	return &WebhookCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Webhook entities.
func (c *WebhookClient) CreateBulk(builders ...*WebhookCreate) *WebhookCreateBulk {
	return &WebhookCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WebhookClient) MapCreateBulk(slice any, setFunc func(*WebhookCreate, int)) *WebhookCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WebhookCreateBulk{err: fmt.Errorf("calling to WebhookClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WebhookCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WebhookCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Webhook.
func (c *WebhookClient) Update() *WebhookUpdate {
	mutation := newWebhookMutation(c.config, OpUpdate)
	return &WebhookUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WebhookClient) UpdateOne(_m *Webhook) *WebhookUpdateOne {
	mutation := newWebhookMutation(c.config, OpUpdateOne, withWebhook(_m))
	return &WebhookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WebhookClient) UpdateOneID(id int) *WebhookUpdateOne {
	mutation := newWebhookMutation(c.config, OpUpdateOne, withWebhookID(id))
	return &WebhookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Webhook.
func (c *WebhookClient) Delete() *WebhookDelete {
	mutation := newWebhookMutation(c.config, OpDelete)
	return &WebhookDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WebhookClient) DeleteOne(_m *Webhook) *WebhookDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WebhookClient) DeleteOneID(id int) *WebhookDeleteOne {
	builder := c.Delete().Where(webhook.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WebhookDeleteOne{builder}
}

// Query returns a query builder for Webhook.
func (c *WebhookClient) Query() *WebhookQuery {
	return &WebhookQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWebhook},
		inters: c.Interceptors(),
	}
}

// Get returns a Webhook entity by its id.
func (c *WebhookClient) Get(ctx context.Context, id int) (*Webhook, error) {
	return c.Query().Where(webhook.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WebhookClient) GetX(ctx context.Context, id int) *Webhook {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Webhook.
func (c *WebhookClient) QueryUser(_m *Webhook) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(webhook.Table, webhook.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, webhook.UserTable, webhook.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WebhookClient) Hooks() []Hook {
	return c.hooks.Webhook
}

// Interceptors returns the client interceptors.
func (c *WebhookClient) Interceptors() []Interceptor {
	return c.inters.Webhook
}

func (c *WebhookClient) mutate(ctx context.Context, m *WebhookMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WebhookCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WebhookUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WebhookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WebhookDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Webhook mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		APIKey, Affiliate, AffiliateClick, AffiliateConversion, AuditLog,
		CRMIntegration, CRMLeadSync, CallLog, CompetitorMetric, CompetitorProfile,
		EmailCampaign, EmailCampaignRecipient, EmailSequence, EmailSequenceEnrollment,
		EmailSequenceSend, EmailSequenceStep, Experiment, ExperimentAssignment, Export,
		Industry, Lead, LeadAssignment, LeadNote, LeadRecommendation,
		LeadStatusHistory, MarketReport, Organization, OrganizationMember, Referral,
		SMSCampaign, SMSMessage, SavedSearch, Subscription, Territory, TerritoryMember,
		UsageLog, User, UserBehavior, Webhook []ent.Hook
	}
	inters struct {
		APIKey, Affiliate, AffiliateClick, AffiliateConversion, AuditLog,
		CRMIntegration, CRMLeadSync, CallLog, CompetitorMetric, CompetitorProfile,
		EmailCampaign, EmailCampaignRecipient, EmailSequence, EmailSequenceEnrollment,
		EmailSequenceSend, EmailSequenceStep, Experiment, ExperimentAssignment, Export,
		Industry, Lead, LeadAssignment, LeadNote, LeadRecommendation,
		LeadStatusHistory, MarketReport, Organization, OrganizationMember, Referral,
		SMSCampaign, SMSMessage, SavedSearch, Subscription, Territory, TerritoryMember,
		UsageLog, User, UserBehavior, Webhook []ent.Interceptor
	}
)
